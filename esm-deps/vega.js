var __defProp = Object.defineProperty;
var __markAsModule = (target2) => __defProp(target2, "__esModule", { value: true });
var __export = (target2, all) => {
  __markAsModule(target2);
  for (var name2 in all)
    __defProp(target2, name2, { get: all[name2], enumerable: true });
};

// node_modules/vega-util/build/vega-util.module.js
function accessor(fn, fields, name2) {
  fn.fields = fields || [];
  fn.fname = name2;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path3) {
  return path3.length === 1 ? get1(path3[0]) : getN(path3);
}
var get1 = (field3) => function(obj) {
  return obj[field3];
};
var getN = (path3) => {
  const len = path3.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path3[i]];
    }
    return obj;
  };
};
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path3 = [], n = p.length;
  let q = null, b2 = 0, s = "", i, j, c2;
  p = p + "";
  function push() {
    path3.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c2 = p[j];
    if (c2 === "\\") {
      s += p.substring(i, j);
      s += p.substring(++j, ++j);
      i = j;
    } else if (c2 === q) {
      push();
      q = null;
      b2 = -1;
    } else if (q) {
      continue;
    } else if (i === b2 && c2 === '"') {
      i = j + 1;
      q = c2;
    } else if (i === b2 && c2 === "'") {
      i = j + 1;
      q = c2;
    } else if (c2 === "." && !b2) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c2 === "[") {
      if (j > i)
        push();
      b2 = i = j + 1;
    } else if (c2 === "]") {
      if (!b2)
        error("Access path missing open bracket: " + p);
      if (b2 > 0)
        push();
      b2 = 0;
      i = j + 1;
    }
  }
  if (b2)
    error("Access path missing closing bracket: " + p);
  if (q)
    error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path3;
}
function field(field3, name2, opt) {
  const path3 = splitAccessPath(field3);
  field3 = path3.length === 1 ? path3[0] : field3;
  return accessor((opt && opt.get || getter)(path3), [field3], name2 || field3);
}
var id = field("id");
var identity = accessor((_) => _, [], "identity");
var zero = accessor(() => 0, [], "zero");
var one = accessor(() => 1, [], "one");
var truthy = accessor(() => true, [], "true");
var falsy = accessor(() => false, [], "false");
function log$1(method2, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method2].apply(console, args);
}
var None = 0;
var Error$1 = 1;
var Warn = 2;
var Info = 3;
var Debug = 4;
function logger(_, method2) {
  let level = _ || None;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1)
        log$1(method2 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn)
        log$1(method2 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info)
        log$1(method2 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug)
        log$1(method2 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray = Array.isArray;
function isObject(_) {
  return _ === Object(_);
}
var isLegalKey = (key2) => key2 !== "__proto__";
function mergeConfig(...configs) {
  return configs.reduce((out, source3) => {
    for (const key2 in source3) {
      if (key2 === "signals") {
        out.signals = mergeNamed(out.signals, source3.signals);
      } else {
        const r = key2 === "legend" ? {
          layout: 1
        } : key2 === "style" ? true : null;
        writeConfig(out, key2, source3[key2], r);
      }
    }
    return out;
  }, {});
}
function writeConfig(output3, key2, value3, recurse2) {
  if (!isLegalKey(key2))
    return;
  let k, o;
  if (isObject(value3) && !isArray(value3)) {
    o = isObject(output3[key2]) ? output3[key2] : output3[key2] = {};
    for (k in value3) {
      if (recurse2 && (recurse2 === true || recurse2[k])) {
        writeConfig(o, k, value3[k]);
      } else if (isLegalKey(k)) {
        o[k] = value3[k];
      }
    }
  } else {
    output3[key2] = value3;
  }
}
function mergeNamed(a2, b2) {
  if (a2 == null)
    return b2;
  const map3 = {}, out = [];
  function add5(_) {
    if (!map3[_.name]) {
      map3[_.name] = 1;
      out.push(_);
    }
  }
  b2.forEach(add5);
  a2.forEach(add5);
  return out;
}
function peek(array4) {
  return array4[array4.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp = (sign3) => (x5) => sign3 * Math.exp(x5);
var log = (sign3) => (x5) => Math.log(sign3 * x5);
var symlog = (c2) => (x5) => Math.sign(x5) * Math.log1p(Math.abs(x5 / c2));
var symexp = (c2) => (x5) => Math.sign(x5) * Math.expm1(Math.abs(x5)) * c2;
var pow = (exponent) => (x5) => x5 < 0 ? -Math.pow(-x5, exponent) : Math.pow(x5, exponent);
function pan(domain2, delta, lift, ground) {
  const d0 = lift(domain2[0]), d1 = lift(peek(domain2)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain2, delta) {
  return pan(domain2, delta, toNumber, identity);
}
function panLog(domain2, delta) {
  var sign3 = Math.sign(domain2[0]);
  return pan(domain2, delta, log(sign3), exp(sign3));
}
function panPow(domain2, delta, exponent) {
  return pan(domain2, delta, pow(exponent), pow(1 / exponent));
}
function panSymlog(domain2, delta, constant2) {
  return pan(domain2, delta, symlog(constant2), symexp(constant2));
}
function zoom(domain2, anchor, scale6, lift, ground) {
  const d0 = lift(domain2[0]), d1 = lift(peek(domain2)), da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale6), ground(da + (d1 - da) * scale6)];
}
function zoomLinear(domain2, anchor, scale6) {
  return zoom(domain2, anchor, scale6, toNumber, identity);
}
function zoomLog(domain2, anchor, scale6) {
  const sign3 = Math.sign(domain2[0]);
  return zoom(domain2, anchor, scale6, log(sign3), exp(sign3));
}
function zoomPow(domain2, anchor, scale6, exponent) {
  return zoom(domain2, anchor, scale6, pow(exponent), pow(1 / exponent));
}
function zoomSymlog(domain2, anchor, scale6, constant2) {
  return zoom(domain2, anchor, scale6, symlog(constant2), symexp(constant2));
}
function quarter(date2) {
  return 1 + ~~(new Date(date2).getMonth() / 3);
}
function utcquarter(date2) {
  return 1 + ~~(new Date(date2).getUTCMonth() / 3);
}
function array(_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}
function clampRange(range4, min4, max4) {
  let lo = range4[0], hi = range4[1], span2;
  if (hi < lo) {
    span2 = hi;
    hi = lo;
    lo = span2;
  }
  span2 = hi - lo;
  return span2 >= max4 - min4 ? [min4, max4] : [lo = Math.min(Math.max(lo, min4), max4 - span2), lo + span2];
}
function isFunction(_) {
  return typeof _ === "function";
}
var DESCENDING = "descending";
function compare(fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [], get6 = [], fmap = {}, gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get6.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get6.length === 0 ? null : accessor(gen(get6, ord), Object.keys(fmap));
}
var ascending = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
var comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
var compare1 = (field3, order) => function(a2, b2) {
  return ascending(field3(a2), field3(b2)) * order;
};
var compareN = (fields, orders, n) => {
  orders.push(0);
  return function(a2, b2) {
    let f, c2 = 0, i = -1;
    while (c2 === 0 && ++i < n) {
      f = fields[i];
      c2 = ascending(f(a2), f(b2));
    }
    return c2 * orders[i];
  };
};
function constant(_) {
  return isFunction(_) ? _ : () => _;
}
function debounce(delay, handler) {
  let tid;
  return (e) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e), tid = null), delay);
  };
}
function extend(_) {
  for (let x5, k, i = 1, len = arguments.length; i < len; ++i) {
    x5 = arguments[i];
    for (k in x5) {
      _[k] = x5[k];
    }
  }
  return _;
}
function extent(array4, f) {
  let i = 0, n, v, min4, max4;
  if (array4 && (n = array4.length)) {
    if (f == null) {
      for (v = array4[i]; i < n && (v == null || v !== v); v = array4[++i])
        ;
      min4 = max4 = v;
      for (; i < n; ++i) {
        v = array4[i];
        if (v != null) {
          if (v < min4)
            min4 = v;
          if (v > max4)
            max4 = v;
        }
      }
    } else {
      for (v = f(array4[i]); i < n && (v == null || v !== v); v = f(array4[++i]))
        ;
      min4 = max4 = v;
      for (; i < n; ++i) {
        v = f(array4[i]);
        if (v != null) {
          if (v < min4)
            min4 = v;
          if (v > max4)
            max4 = v;
        }
      }
    }
  }
  return [min4, max4];
}
function extentIndex(array4, f) {
  const n = array4.length;
  let i = -1, a2, b2, c2, u, v;
  if (f == null) {
    while (++i < n) {
      b2 = array4[i];
      if (b2 != null && b2 >= b2) {
        a2 = c2 = b2;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b2 = array4[i];
      if (b2 != null) {
        if (a2 > b2) {
          a2 = b2;
          u = i;
        }
        if (c2 < b2) {
          c2 = b2;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b2 = f(array4[i], i, array4);
      if (b2 != null && b2 >= b2) {
        a2 = c2 = b2;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b2 = f(array4[i], i, array4);
      if (b2 != null) {
        if (a2 > b2) {
          a2 = b2;
          u = i;
        }
        if (c2 < b2) {
          c2 = b2;
          v = i;
        }
      }
    }
  }
  return [u, v];
}
var hop = Object.prototype.hasOwnProperty;
function has(object2, property2) {
  return hop.call(object2, property2);
}
var NULL = {};
function fastmap(input) {
  let obj = {}, test2;
  function has$1(key2) {
    return has(obj, key2) && obj[key2] !== NULL;
  }
  const map3 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key2) {
      return has$1(key2) ? obj[key2] : void 0;
    },
    set(key2, value3) {
      if (!has$1(key2)) {
        ++map3.size;
        if (obj[key2] === NULL)
          --map3.empty;
      }
      obj[key2] = value3;
      return this;
    },
    delete(key2) {
      if (has$1(key2)) {
        --map3.size;
        ++map3.empty;
        obj[key2] = NULL;
      }
      return this;
    },
    clear() {
      map3.size = map3.empty = 0;
      map3.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map3;
      } else {
        return test2;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key2 in obj) {
        const value3 = obj[key2];
        if (value3 !== NULL && (!test2 || !test2(value3))) {
          next[key2] = value3;
          ++size;
        }
      }
      map3.size = size;
      map3.empty = 0;
      map3.object = obj = next;
    }
  };
  if (input)
    Object.keys(input).forEach((key2) => {
      map3.set(key2, input[key2]);
    });
  return map3;
}
function flush(range4, value3, threshold2, left, right, center) {
  if (!threshold2 && threshold2 !== 0)
    return center;
  const t = +threshold2;
  let a2 = range4[0], b2 = peek(range4), l;
  if (b2 < a2) {
    l = a2;
    a2 = b2;
    b2 = l;
  }
  l = Math.abs(value3 - a2);
  const r = Math.abs(b2 - value3);
  return l < r && l <= t ? left : r <= t ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}
function inrange(value3, range4, left, right) {
  let r0 = range4[0], r1 = range4[range4.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value3 : r0 < value3) && (right ? value3 <= r1 : value3 < r1);
}
function isBoolean(_) {
  return typeof _ === "boolean";
}
function isDate(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction(_[Symbol.iterator]);
}
function isNumber(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map3 = (f) => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get6 = map3(fields[0]);
    fn = function(_) {
      return "" + get6(_);
    };
  } else {
    const get6 = fields.map(map3);
    fn = function(_) {
      let s = "" + get6[0](_), i = 0;
      while (++i < len)
        s += "|" + get6[i](_);
      return s;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array4, frac) {
  const lo = array4[0], hi = peek(array4), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
var DEFAULT_MAX_SIZE = 1e4;
function lruCache(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key2, value3) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key2] = value3;
  };
  clear();
  return {
    clear,
    has: (key2) => has(curr, key2) || has(prev, key2),
    get: (key2) => has(curr, key2) ? curr[key2] : has(prev, key2) ? update3(key2, prev[key2]) : void 0,
    set: (key2, value3) => has(curr, key2) ? curr[key2] = value3 : update3(key2, value3)
  };
}
function merge(compare3, array0, array1, output3) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1)
    return array0;
  if (!n0)
    return array1;
  const merged = output3 || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare3(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s = "";
  while (--reps >= 0)
    s += str;
  return s;
}
function pad(str, length2, padchar, align) {
  const c2 = padchar || " ", s = str + "", n = length2 - s.length;
  return n <= 0 ? s : align === "left" ? repeat(c2, n) + s : align === "center" ? repeat(c2, ~~(n / 2)) + s + repeat(c2, Math.ceil(n / 2)) : s + repeat(c2, n);
}
function span(array4) {
  return array4 && peek(array4) - array4[0] || 0;
}
function $(x5) {
  return isArray(x5) ? "[" + x5.map($) + "]" : isObject(x5) || isString(x5) ? JSON.stringify(x5).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : x5;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser = (_) => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
function toDate(_, parser3) {
  parser3 = parser3 || defaultParser;
  return _ == null || _ === "" ? null : parser3(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s[_[i]] = true;
  return s;
}
function truncate(str, length2, align, ellipsis) {
  const e = ellipsis != null ? ellipsis : "\u2026", s = str + "", n = s.length, l = Math.max(0, length2 - e.length);
  return n <= length2 ? s : align === "left" ? e + s.slice(n - l) : align === "center" ? s.slice(0, Math.ceil(l / 2)) + e + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e;
}
function visitArray(array4, filter3, visitor) {
  if (array4) {
    if (filter3) {
      const n = array4.length;
      for (let i = 0; i < n; ++i) {
        const t = filter3(array4[i]);
        if (t)
          visitor(t, i, array4);
      }
    } else {
      array4.forEach(visitor);
    }
  }
}

// node_modules/vega-loader/src/loader.js
var protocol_re = /^([A-Za-z]+:)?\/\//;
var allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol = "file://";
function loader_default(fetch2, fs) {
  return (options) => ({
    options: options || {},
    sanitize,
    load,
    fileAccess: !!fs,
    file: fileLoader(fs),
    http: httpLoader(fetch2)
  });
}
async function load(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options);
}
async function sanitize(uri, options) {
  options = extend({}, this.options, options);
  const fileAccess = this.fileAccess, result = { href: null };
  let isFile, loadFile, base2;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error("Sanitize failure, invalid URI: " + $(uri));
  }
  const hasProtocol = protocol_re.test(uri);
  if ((base2 = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && base2[base2.length - 1] !== "/") {
      uri = "/" + uri;
    }
    uri = base2 + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", { value: !!loadFile });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader(fs) {
  return fs ? (filename) => new Promise((accept, reject) => {
    fs.readFile(filename, (error2, data3) => {
      if (error2)
        reject(error2);
      else
        accept(data3);
    });
  }) : fileReject;
}
async function fileReject() {
  error("No file system access.");
}
function httpLoader(fetch2) {
  return fetch2 ? async function(url, options) {
    const opt = extend({}, this.options.http, options), type2 = options && options.response, response = await fetch2(url, opt);
    return !response.ok ? error(response.status + "" + response.statusText) : isFunction(response[type2]) ? response[type2]() : response.text();
  } : httpReject;
}
async function httpReject() {
  error("No HTTP fetch method available.");
}

// node_modules/vega-loader/src/type.js
var isValid = (_) => _ != null && _ === _;
var isBoolean2 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
var isDate2 = (_) => !Number.isNaN(Date.parse(_));
var isNumber2 = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
var isInteger = (_) => isNumber2(_) && Number.isInteger(+_);
var typeParsers = {
  boolean: toBoolean,
  integer: toNumber,
  number: toNumber,
  date: toDate,
  string: toString,
  unknown: identity
};
var typeTests = [
  isBoolean2,
  isInteger,
  isNumber2,
  isDate2
];
var typeList = [
  "boolean",
  "integer",
  "number",
  "date"
];
function inferType(values2, field3) {
  if (!values2 || !values2.length)
    return "unknown";
  const n = values2.length, m2 = typeTests.length, a2 = typeTests.map((_, i) => i + 1);
  for (let i = 0, t = 0, j, value3; i < n; ++i) {
    value3 = field3 ? values2[i][field3] : values2[i];
    for (j = 0; j < m2; ++j) {
      if (a2[j] && isValid(value3) && !typeTests[j](value3)) {
        a2[j] = 0;
        ++t;
        if (t === typeTests.length)
          return "string";
      }
    }
  }
  return typeList[a2.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data3, fields) {
  return fields.reduce((types2, field3) => {
    types2[field3] = inferType(data3, field3);
    return types2;
  }, {});
}

// node_modules/vega-loader/node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i) {
    return JSON.stringify(name2) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object2 = objectConverter(columns);
  return function(row, i) {
    return f(object2(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad2(value3, width2) {
  var s = value3 + "", length2 = s.length;
  return length2 < width2 ? new Array(width2 - length2 + 1).join(0) + s : s;
}
function formatYear(year2) {
  return year2 < 0 ? "-" + pad2(-year2, 6) : year2 > 9999 ? "+" + pad2(year2, 6) : pad2(year2, 4);
}
function formatDate(date2) {
  var hours2 = date2.getUTCHours(), minutes2 = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad2(date2.getUTCMonth() + 1, 2) + "-" + pad2(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + ":" + pad2(seconds2, 2) + "." + pad2(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + ":" + pad2(seconds2, 2) + "Z" : minutes2 || hours2 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse6(text2, f) {
    var convert, columns, rows = parseRows(text2, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f) {
    var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text2.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text2.charCodeAt(N - 1) === RETURN)
      --N;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c2;
      if (text2.charCodeAt(j) === QUOTE) {
        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c2 = text2.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text2.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c2 = text2.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c2 !== DELIMITER)
          continue;
        return text2.slice(j, i);
      }
      return eof = true, text2.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue3(row[column]);
      }).join(delimiter);
    });
  }
  function format5(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue3).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue3).join(delimiter);
  }
  function formatValue3(value3) {
    return value3 == null ? "" : value3 instanceof Date ? formatDate(value3) : reFormat.test(value3 += "") ? '"' + value3.replace(/"/g, '""') + '"' : value3;
  }
  return {
    parse: parse6,
    parseRows,
    format: format5,
    formatBody,
    formatRows,
    formatRow,
    formatValue: formatValue3
  };
}

// node_modules/vega-loader/src/formats/dsv.js
function delimitedFormat(delimiter) {
  const parse6 = function(data3, format5) {
    const delim = { delimiter };
    return dsv(data3, format5 ? extend(format5, delim) : delim);
  };
  parse6.responseType = "text";
  return parse6;
}
function dsv(data3, format5) {
  if (format5.header) {
    data3 = format5.header.map($).join(format5.delimiter) + "\n" + data3;
  }
  return dsv_default(format5.delimiter).parse(data3 + "");
}
dsv.responseType = "text";

// node_modules/vega-loader/src/formats/json.js
function isBuffer(_) {
  return typeof Buffer === "function" && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json(data3, format5) {
  const prop = format5 && format5.property ? field(format5.property) : identity;
  return isObject(data3) && !isBuffer(data3) ? parseJSON(prop(data3), format5) : prop(JSON.parse(data3));
}
json.responseType = "json";
function parseJSON(data3, format5) {
  if (!isArray(data3) && isIterable(data3)) {
    data3 = [...data3];
  }
  return format5 && format5.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}

// node_modules/topojson-client/src/identity.js
function identity_default(x5) {
  return x5;
}

// node_modules/topojson-client/src/transform.js
function transform_default(transform4) {
  if (transform4 == null)
    return identity_default;
  var x06, y06, kx = transform4.scale[0], ky = transform4.scale[1], dx = transform4.translate[0], dy = transform4.translate[1];
  return function(input, i) {
    if (!i)
      x06 = y06 = 0;
    var j = 2, n = input.length, output3 = new Array(n);
    output3[0] = (x06 += input[0]) * kx + dx;
    output3[1] = (y06 += input[1]) * ky + dy;
    while (j < n)
      output3[j] = input[j], ++j;
    return output3;
  };
}

// node_modules/topojson-client/src/reverse.js
function reverse_default(array4, n) {
  var t, j = array4.length, i = j - n;
  while (i < --j)
    t = array4[i], array4[i++] = array4[j], array4[j] = t;
}

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o) {
  if (typeof o === "string")
    o = topology.objects[o];
  return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
    return feature(topology, o2);
  }) } : feature(topology, o);
}
function feature(topology, o) {
  var id2 = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
  return id2 == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id: id2, properties, geometry } : { type: "Feature", id: id2, bbox, properties, geometry };
}
function object(topology, o) {
  var transformPoint = transform_default(topology.transform), arcs = topology.arcs;
  function arc3(i, points2) {
    if (points2.length)
      points2.pop();
    for (var a2 = arcs[i < 0 ? ~i : i], k = 0, n = a2.length; k < n; ++k) {
      points2.push(transformPoint(a2[k], k));
    }
    if (i < 0)
      reverse_default(points2, n);
  }
  function point7(p) {
    return transformPoint(p);
  }
  function line3(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i)
      arc3(arcs2[i], points2);
    if (points2.length < 2)
      points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line3(arcs2);
    while (points2.length < 4)
      points2.push(points2[0]);
    return points2;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o2) {
    var type2 = o2.type, coordinates;
    switch (type2) {
      case "GeometryCollection":
        return { type: type2, geometries: o2.geometries.map(geometry) };
      case "Point":
        coordinates = point7(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point7);
        break;
      case "LineString":
        coordinates = line3(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line3);
        break;
      case "Polygon":
        coordinates = polygon(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type: type2, coordinates };
  }
  return geometry(o);
}

// node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc3 = topology.arcs[i < 0 ? ~i : i], t;
    if (arc3.length < 3 && !arc3[1][0] && !arc3[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e = ends(i), start = e[0], end = e[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc3 = topology.arcs[i < 0 ? ~i : i], p02 = arc3[0], p1;
    if (topology.transform)
      p1 = [0, 0], arc3.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc3[arc3.length - 1];
    return i < 0 ? [p1, p02] : [p02, p1];
  }
  function flush2(fragmentByEnd2, fragmentByStart2) {
    for (var k in fragmentByEnd2) {
      var f = fragmentByEnd2[k];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush2(fragmentByEnd, fragmentByStart);
  flush2(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i])
      fragments.push([i]);
  });
  return fragments;
}

// node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter3) {
  var arcs, i, n;
  if (arguments.length > 1)
    arcs = extractArcs(topology, object2, filter3);
  else
    for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)
      arcs[i] = i;
  return { type: "MultiLineString", arcs: stitch_default(topology, arcs) };
}
function extractArcs(topology, object2, filter3) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;
      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter3 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter3(geoms[0].g, geoms[geoms.length - 1].g))
      arcs.push(geoms[0].i);
  });
  return arcs;
}

// node_modules/vega-loader/src/formats/topojson.js
var filters = {
  interior: (a2, b2) => a2 !== b2,
  exterior: (a2, b2) => a2 === b2
};
function topojson(data3, format5) {
  let method2, object2, property2, filter3;
  data3 = json(data3, format5);
  if (format5 && format5.feature) {
    method2 = feature_default;
    property2 = format5.feature;
  } else if (format5 && format5.mesh) {
    method2 = mesh_default;
    property2 = format5.mesh;
    filter3 = filters[format5.filter];
  } else {
    error("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method2(data3, object2, filter3) : error("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson.responseType = "json";

// node_modules/vega-loader/src/formats/index.js
var format = {
  dsv,
  csv: delimitedFormat(","),
  tsv: delimitedFormat("	"),
  json,
  topojson
};
function formats(name2, reader) {
  if (arguments.length > 1) {
    format[name2] = reader;
    return this;
  } else {
    return has(format, name2) ? format[name2] : null;
  }
}
function responseType(type2) {
  const f = formats(type2);
  return f && f.responseType || "text";
}

// node_modules/d3-array/src/ascending.js
function ascending_default(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare3 = f;
  if (f.length === 1) {
    delta = (d, x5) => f(d) - x5;
    compare3 = ascendingComparator(f);
  }
  function left(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare3(a2[mid], x5) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare3(a2[mid], x5) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    const i = left(a2, x5, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x5) > -delta(a2[i], x5) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x5) => ascending_default(f(d), x5);
}

// node_modules/d3-array/src/number.js
function number_default(x5) {
  return x5 === null ? NaN : +x5;
}
function* numbers(values2, valueof) {
  if (valueof === void 0) {
    for (let value3 of values2) {
      if (value3 != null && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  } else {
    let index3 = -1;
    for (let value3 of values2) {
      if ((value3 = valueof(value3, ++index3, values2)) != null && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;
var bisect_default2 = bisectRight;

// node_modules/d3-array/src/variance.js
function variance(values2, valueof) {
  let count2 = 0;
  let delta;
  let mean2 = 0;
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value3 of values2) {
      if (value3 != null && (value3 = +value3) >= value3) {
        delta = value3 - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value3 - mean2);
      }
    }
  } else {
    let index3 = -1;
    for (let value3 of values2) {
      if ((value3 = valueof(value3, ++index3, values2)) != null && (value3 = +value3) >= value3) {
        delta = value3 - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value3 - mean2);
      }
    }
  }
  if (count2 > 1)
    return sum2 / (count2 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values2, valueof) {
  const v = variance(values2, valueof);
  return v ? Math.sqrt(v) : v;
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x5) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y5 = p[j], hi = x5 + y5, lo = Math.abs(x5) < Math.abs(y5) ? x5 - (hi - y5) : y5 - (hi - x5);
      if (lo)
        p[i++] = lo;
      x5 = hi;
    }
    p[i] = x5;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x5, y5, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x5 = hi;
        y5 = p[--n];
        hi = x5 + y5;
        lo = y5 - (hi - x5);
        if (lo)
          break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y5 = lo * 2;
        x5 = hi + y5;
        if (y5 == x5 - hi)
          hi = x5;
      }
    }
    return hi;
  }
};

// node_modules/d3-array/src/permute.js
function permute_default(source3, keys3) {
  return Array.from(keys3, (key2) => source3[key2]);
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function ticks_default(start, stop2, count2) {
  var reverse2, i = -1, n, ticks, step;
  stop2 = +stop2, start = +start, count2 = +count2;
  if (start === stop2 && count2 > 0)
    return [start];
  if (reverse2 = stop2 < start)
    n = start, start = stop2, stop2 = n;
  if ((step = tickIncrement(start, stop2, count2)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop2 / step);
    if (r0 * step < start)
      ++r0;
    if (r1 * step > stop2)
      --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop2 * step);
    if (r0 / step < start)
      ++r0;
    if (r1 / step > stop2)
      --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks[i] = (r0 + i) / step;
  }
  if (reverse2)
    ticks.reverse();
  return ticks;
}
function tickIncrement(start, stop2, count2) {
  var step = (stop2 - start) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error2 = step / Math.pow(10, power);
  return power >= 0 ? (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
}
function tickStep(start, stop2, count2) {
  var step0 = Math.abs(stop2 - start) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error2 = step0 / step1;
  if (error2 >= e10)
    step1 *= 10;
  else if (error2 >= e5)
    step1 *= 5;
  else if (error2 >= e2)
    step1 *= 2;
  return stop2 < start ? -step1 : step1;
}

// node_modules/d3-array/src/max.js
function max(values2, valueof) {
  let max4;
  if (valueof === void 0) {
    for (const value3 of values2) {
      if (value3 != null && (max4 < value3 || max4 === void 0 && value3 >= value3)) {
        max4 = value3;
      }
    }
  } else {
    let index3 = -1;
    for (let value3 of values2) {
      if ((value3 = valueof(value3, ++index3, values2)) != null && (max4 < value3 || max4 === void 0 && value3 >= value3)) {
        max4 = value3;
      }
    }
  }
  return max4;
}

// node_modules/d3-array/src/min.js
function min(values2, valueof) {
  let min4;
  if (valueof === void 0) {
    for (const value3 of values2) {
      if (value3 != null && (min4 > value3 || min4 === void 0 && value3 >= value3)) {
        min4 = value3;
      }
    }
  } else {
    let index3 = -1;
    for (let value3 of values2) {
      if ((value3 = valueof(value3, ++index3, values2)) != null && (min4 > value3 || min4 === void 0 && value3 >= value3)) {
        min4 = value3;
      }
    }
  }
  return min4;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array4, k, left = 0, right = array4.length - 1, compare3 = ascending_default) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m2 = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m2 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m2 * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m2) * s / n + sd));
      quickselect(array4, k, newLeft, newRight, compare3);
    }
    const t = array4[k];
    let i = left;
    let j = right;
    swap(array4, left, k);
    if (compare3(array4[right], t) > 0)
      swap(array4, left, right);
    while (i < j) {
      swap(array4, i, j), ++i, --j;
      while (compare3(array4[i], t) < 0)
        ++i;
      while (compare3(array4[j], t) > 0)
        --j;
    }
    if (compare3(array4[left], t) === 0)
      swap(array4, left, j);
    else
      ++j, swap(array4, j, right);
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
  return array4;
}
function swap(array4, i, j) {
  const t = array4[i];
  array4[i] = array4[j];
  array4[j] = t;
}

// node_modules/d3-array/src/quantile.js
function quantile(values2, p, valueof) {
  values2 = Float64Array.from(numbers(values2, valueof));
  if (!(n = values2.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return min(values2);
  if (p >= 1)
    return max(values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values2, p, valueof = number_default) {
  if (!(n = values2.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return +valueof(values2[0], 0, values2);
  if (p >= 1)
    return +valueof(values2[n - 1], n - 1, values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/mean.js
function mean(values2, valueof) {
  let count2 = 0;
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value3 of values2) {
      if (value3 != null && (value3 = +value3) >= value3) {
        ++count2, sum2 += value3;
      }
    }
  } else {
    let index3 = -1;
    for (let value3 of values2) {
      if ((value3 = valueof(value3, ++index3, values2)) != null && (value3 = +value3) >= value3) {
        ++count2, sum2 += value3;
      }
    }
  }
  if (count2)
    return sum2 / count2;
}

// node_modules/d3-array/src/median.js
function median_default(values2, valueof) {
  return quantile(values2, 0.5, valueof);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array4 of arrays) {
    yield* array4;
  }
}
function merge2(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/range.js
function range_default(start, stop2, step) {
  start = +start, stop2 = +stop2, step = (n = arguments.length) < 2 ? (stop2 = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop2 - start) / step)) | 0, range4 = new Array(n);
  while (++i < n) {
    range4[i] = start + i * step;
  }
  return range4;
}

// node_modules/d3-array/src/sum.js
function sum(values2, valueof) {
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value3 of values2) {
      if (value3 = +value3) {
        sum2 += value3;
      }
    }
  } else {
    let index3 = -1;
    for (let value3 of values2) {
      if (value3 = +valueof(value3, ++index3, values2)) {
        sum2 += value3;
      }
    }
  }
  return sum2;
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x5) {
  return Math.abs(x5 = Math.round(x5)) >= 1e21 ? x5.toLocaleString("en").replace(/,/g, "") : x5.toString(10);
}
function formatDecimalParts(x5, p) {
  if ((i = (x5 = p ? x5.toExponential(p - 1) : x5.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x5.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x5.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x5) {
  return x5 = formatDecimalParts(Math.abs(x5)), x5 ? x5[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value3, width2) {
    var i = value3.length, t = [], j = 0, g = grouping[0], length2 = 0;
    while (i > 0 && g > 0) {
      if (length2 + g + 1 > width2)
        g = Math.max(1, width2 - length2);
      t.push(value3.substring(i -= g, i + g));
      if ((length2 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value3) {
    return value3.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x5, p) {
  var d = formatDecimalParts(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x5, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x5, p) {
  var d = formatDecimalParts(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x5, p) => (x5 * 100).toFixed(p),
  "b": (x5) => Math.round(x5).toString(2),
  "c": (x5) => x5 + "",
  "d": formatDecimal_default,
  "e": (x5, p) => x5.toExponential(p),
  "f": (x5, p) => x5.toFixed(p),
  "g": (x5, p) => x5.toPrecision(p),
  "o": (x5) => Math.round(x5).toString(8),
  "p": (x5, p) => formatRounded_default(x5 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x5) => Math.round(x5).toString(16).toUpperCase(),
  "x": (x5) => Math.round(x5).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x5) {
  return x5;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale4) {
  var group2 = locale4.grouping === void 0 || locale4.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale4.grouping, Number), locale4.thousands + ""), currencyPrefix = locale4.currency === void 0 ? "" : locale4.currency[0] + "", currencySuffix = locale4.currency === void 0 ? "" : locale4.currency[1] + "", decimal = locale4.decimal === void 0 ? "." : locale4.decimal + "", numerals = locale4.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale4.numerals, String)), percent = locale4.percent === void 0 ? "%" : locale4.percent + "", minus = locale4.minus === void 0 ? "\u2212" : locale4.minus + "", nan = locale4.nan === void 0 ? "NaN" : locale4.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero5 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero5 || fill2 === "0" && align === "=")
      zero5 = true, fill2 = "0", align = "=";
    var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format5(value3) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value3) + valueSuffix;
        value3 = "";
      } else {
        value3 = +value3;
        var valueNegative = value3 < 0 || 1 / value3 < 0;
        value3 = isNaN(value3) ? nan : formatType(Math.abs(value3), precision);
        if (trim)
          value3 = formatTrim_default(value3);
        if (valueNegative && +value3 === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value3.length;
          while (++i < n) {
            if (c2 = value3.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value3.slice(i + 1) : value3.slice(i)) + valueSuffix;
              value3 = value3.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero5)
        value3 = group2(value3, Infinity);
      var length2 = valuePrefix.length + value3.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill2) : "";
      if (comma && zero5)
        value3 = group2(padding2 + value3, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
      switch (align) {
        case "<":
          value3 = valuePrefix + value3 + valueSuffix + padding2;
          break;
        case "=":
          value3 = valuePrefix + padding2 + value3 + valueSuffix;
          break;
        case "^":
          value3 = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value3 + valueSuffix + padding2.slice(length2);
          break;
        default:
          value3 = padding2 + valuePrefix + value3 + valueSuffix;
          break;
      }
      return numerals(value3);
    }
    format5.toString = function() {
      return specifier + "";
    };
    return format5;
  }
  function formatPrefix2(specifier, value3) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value3) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value4) {
      return f(k * value4) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format2;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition3) {
  locale = locale_default(definition3);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value3) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value3) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}

// node_modules/d3-time/src/interval.js
var t0 = new Date();
var t1 = new Date();
function newInterval(floori, offseti, count2, field3) {
  function interval3(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval3.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval3.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval3.round = function(date2) {
    var d0 = interval3(date2), d1 = interval3.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval3.offset = function(date2, step) {
    return offseti(date2 = new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval3.range = function(start, stop2, step) {
    var range4 = [], previous;
    start = interval3.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop2) || !(step > 0))
      return range4;
    do
      range4.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop2);
    return range4;
  };
  interval3.filter = function(test2) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test2(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test2(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test2(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval3.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval3.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval3 : interval3.filter(field3 ? function(d) {
        return field3(d) % step === 0;
      } : function(d) {
        return interval3.count(0, d) % step === 0;
      });
    };
  }
  return interval3;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start, end) {
  return end - start;
});
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0))
    return null;
  if (!(k > 1))
    return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k) * k);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var millisecond_default = millisecond;
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date2) {
  return date2.getUTCSeconds();
});
var second_default = second;
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getMinutes();
});
var minute_default = minute;
var minutes = minute.range;

// node_modules/d3-time/src/hour.js
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getHours();
});
var hour_default = hour;
var hours = hour.range;

// node_modules/d3-time/src/day.js
var day = newInterval((date2) => date2.setHours(0, 0, 0, 0), (date2, step) => date2.setDate(date2.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, (date2) => date2.getDate() - 1);
var day_default = day;
var days = day.range;

// node_modules/d3-time/src/week.js
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// node_modules/d3-time/src/month.js
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
var month_default = month;
var months = month.range;

// node_modules/d3-time/src/year.js
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
var year_default = year;
var years = year.range;

// node_modules/d3-time/src/utcMinute.js
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getUTCMinutes();
});
var utcMinute_default = utcMinute;
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/utcHour.js
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getUTCHours();
});
var utcHour_default = utcHour;
var utcHours = utcHour.range;

// node_modules/d3-time/src/utcDay.js
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
var utcDay_default = utcDay;
var utcDays = utcDay.range;

// node_modules/d3-time/src/utcWeek.js
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/utcMonth.js
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
var utcMonth_default = utcMonth;
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/utcYear.js
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
var utcYear_default = utcYear;
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year2, month2, week2, day2, hour2, minute2) {
  const tickIntervals = [
    [second_default, 1, durationSecond],
    [second_default, 5, 5 * durationSecond],
    [second_default, 15, 15 * durationSecond],
    [second_default, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week2, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks(start, stop2, count2) {
    const reverse2 = stop2 < start;
    if (reverse2)
      [start, stop2] = [stop2, start];
    const interval3 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop2, count2);
    const ticks2 = interval3 ? interval3.range(start, +stop2 + 1) : [];
    return reverse2 ? ticks2.reverse() : ticks2;
  }
  function tickInterval(start, stop2, count2) {
    const target2 = Math.abs(stop2 - start) / count2;
    const i = bisector_default(([, , step2]) => step2).right(tickIntervals, target2);
    if (i === tickIntervals.length)
      return year2.every(tickStep(start / durationYear, stop2 / durationYear, count2));
    if (i === 0)
      return millisecond_default.every(Math.max(tickStep(start, stop2, count2), 1));
    const [t, step] = tickIntervals[target2 / tickIntervals[i - 1][2] < tickIntervals[i][2] / target2 ? i - 1 : i];
    return t.every(step);
  }
  return [ticks, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default);
var [timeTicks, timeTickInterval] = ticker(year_default, month_default, sunday, day_default, hour_default, minute_default);

// node_modules/vega-time/build/vega-time.module.js
var YEAR = "year";
var QUARTER = "quarter";
var MONTH = "month";
var WEEK = "week";
var DATE = "date";
var DAY = "day";
var DAYOFYEAR = "dayofyear";
var HOURS = "hours";
var MINUTES = "minutes";
var SECONDS = "seconds";
var MILLISECONDS = "milliseconds";
var TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
var UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
function timeUnits(units) {
  const u = array(units).slice(), m2 = {};
  if (!u.length)
    error("Missing time unit.");
  u.forEach((unit2) => {
    if (has(UNITS, unit2)) {
      m2[unit2] = 1;
    } else {
      error("Invalid time unit: ".concat(unit2, "."));
    }
  });
  const numTypes = (m2[WEEK] || m2[DAY] ? 1 : 0) + (m2[QUARTER] || m2[MONTH] || m2[DATE] ? 1 : 0) + (m2[DAYOFYEAR] ? 1 : 0);
  if (numTypes > 1) {
    error("Incompatible time units: ".concat(units));
  }
  u.sort((a2, b2) => UNITS[a2] - UNITS[b2]);
  return u;
}
var defaultSpecifiers = {
  [YEAR]: "%Y ",
  [QUARTER]: "Q%q ",
  [MONTH]: "%b ",
  [DATE]: "%d ",
  [WEEK]: "W%U ",
  [DAY]: "%a ",
  [DAYOFYEAR]: "%j ",
  [HOURS]: "%H:00",
  [MINUTES]: "00:%M",
  [SECONDS]: ":%S",
  [MILLISECONDS]: ".%L",
  ["".concat(YEAR, "-").concat(MONTH)]: "%Y-%m ",
  ["".concat(YEAR, "-").concat(MONTH, "-").concat(DATE)]: "%Y-%m-%d ",
  ["".concat(HOURS, "-").concat(MINUTES)]: "%H:%M"
};
function timeUnitSpecifier(units, specifiers) {
  const s = extend({}, defaultSpecifiers, specifiers), u = timeUnits(units), n = u.length;
  let fmt = "", start = 0, end, key2;
  for (start = 0; start < n; ) {
    for (end = u.length; end > start; --end) {
      key2 = u.slice(start, end).join("-");
      if (s[key2] != null) {
        fmt += s[key2];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}
var t02 = new Date();
function localYear(y5) {
  t02.setFullYear(y5);
  t02.setMonth(0);
  t02.setDate(1);
  t02.setHours(0, 0, 0, 0);
  return t02;
}
function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return day_default.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return sunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y5) {
  return localYear(y5).getDay();
}
function localDate(y5, m2, d, H, M2, S, L) {
  if (0 <= y5 && y5 < 100) {
    const date2 = new Date(-1, m2, d, H, M2, S, L);
    date2.setFullYear(y5);
    return date2;
  }
  return new Date(y5, m2, d, H, M2, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y5 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay_default.count(y5 - 1, d);
}
function utcWeekNum(d) {
  const y5 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y5 - 1, d);
}
function utcFirst(y5) {
  t02.setTime(Date.UTC(y5, 0, 1));
  return t02.getUTCDay();
}
function utcDate(y5, m2, d, H, M2, S, L) {
  if (0 <= y5 && y5 < 100) {
    const date2 = new Date(Date.UTC(-1, m2, d, H, M2, S, L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(y5, m2, d, H, M2, S, L));
}
function floor(units, step, get6, inv, newDate2) {
  const s = step || 1, b2 = peek(units), _ = (unit2, p, key2) => {
    key2 = key2 || unit2;
    return getUnit(get6[key2], inv[key2], unit2 === b2 && s, p);
  };
  const t = new Date(), u = toSet(units), y5 = u[YEAR] ? _(YEAR) : constant(2012), m2 = u[MONTH] ? _(MONTH) : u[QUARTER] ? _(QUARTER) : zero, d = u[WEEK] && u[DAY] ? _(DAY, 1, WEEK + DAY) : u[WEEK] ? _(WEEK, 1) : u[DAY] ? _(DAY, 1) : u[DATE] ? _(DATE, 1) : u[DAYOFYEAR] ? _(DAYOFYEAR, 1) : one, H = u[HOURS] ? _(HOURS) : zero, M2 = u[MINUTES] ? _(MINUTES) : zero, S = u[SECONDS] ? _(SECONDS) : zero, L = u[MILLISECONDS] ? _(MILLISECONDS) : zero;
  return function(v) {
    t.setTime(+v);
    const year2 = y5(t);
    return newDate2(year2, m2(t), d(t, year2), H(t), M2(t), S(t), L(t));
  };
}
function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y5) => phase + step * Math.floor((f(d, y5) - phase) / step) : (d, y5) => step * Math.floor(f(d, y5) / step);
  return inv ? (d, y5) => inv(u(d, y5), y5) : u;
}
function weekday2(week2, day2, firstDay) {
  return day2 + week2 * 7 - (firstDay + 6) % 7;
}
var localGet = {
  [YEAR]: (d) => d.getFullYear(),
  [QUARTER]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH]: (d) => d.getMonth(),
  [DATE]: (d) => d.getDate(),
  [HOURS]: (d) => d.getHours(),
  [MINUTES]: (d) => d.getMinutes(),
  [SECONDS]: (d) => d.getSeconds(),
  [MILLISECONDS]: (d) => d.getMilliseconds(),
  [DAYOFYEAR]: (d) => localDayOfYear(d),
  [WEEK]: (d) => localWeekNum(d),
  [WEEK + DAY]: (d, y5) => weekday2(localWeekNum(d), d.getDay(), localFirst(y5)),
  [DAY]: (d, y5) => weekday2(1, d.getDay(), localFirst(y5))
};
var localInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w2, y5) => weekday2(w2, 0, localFirst(y5))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate);
}
var utcGet = {
  [YEAR]: (d) => d.getUTCFullYear(),
  [QUARTER]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: (d) => d.getUTCMonth(),
  [DATE]: (d) => d.getUTCDate(),
  [HOURS]: (d) => d.getUTCHours(),
  [MINUTES]: (d) => d.getUTCMinutes(),
  [SECONDS]: (d) => d.getUTCSeconds(),
  [MILLISECONDS]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR]: (d) => utcDayOfYear(d),
  [WEEK]: (d) => utcWeekNum(d),
  [DAY]: (d, y5) => weekday2(1, d.getUTCDay(), utcFirst(y5)),
  [WEEK + DAY]: (d, y5) => weekday2(utcWeekNum(d), d.getUTCDay(), utcFirst(y5))
};
var utcInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w2, y5) => weekday2(w2, 0, utcFirst(y5))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate);
}
var timeIntervals = {
  [YEAR]: year_default,
  [QUARTER]: month_default.every(3),
  [MONTH]: month_default,
  [WEEK]: sunday,
  [DATE]: day_default,
  [DAY]: day_default,
  [DAYOFYEAR]: day_default,
  [HOURS]: hour_default,
  [MINUTES]: minute_default,
  [SECONDS]: second_default,
  [MILLISECONDS]: millisecond_default
};
var utcIntervals = {
  [YEAR]: utcYear_default,
  [QUARTER]: utcMonth_default.every(3),
  [MONTH]: utcMonth_default,
  [WEEK]: utcSunday,
  [DATE]: utcDay_default,
  [DAY]: utcDay_default,
  [DAYOFYEAR]: utcDay_default,
  [HOURS]: utcHour_default,
  [MINUTES]: utcMinute_default,
  [SECONDS]: second_default,
  [MILLISECONDS]: millisecond_default
};
function timeInterval(unit2) {
  return timeIntervals[unit2];
}
function utcInterval(unit2) {
  return utcIntervals[unit2];
}
function offset(ival, date2, step) {
  return ival ? ival.offset(date2, step) : void 0;
}
function timeOffset(unit2, date2, step) {
  return offset(timeInterval(unit2), date2, step);
}
function utcOffset(unit2, date2, step) {
  return offset(utcInterval(unit2), date2, step);
}
function sequence(ival, start, stop2, step) {
  return ival ? ival.range(start, stop2, step) : void 0;
}
function timeSequence(unit2, start, stop2, step) {
  return sequence(timeInterval(unit2), start, stop2, step);
}
function utcSequence(unit2, start, stop2, step) {
  return sequence(utcInterval(unit2), start, stop2, step);
}
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth2 = durationDay2 * 30;
var durationYear2 = durationDay2 * 365;
var Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS];
var Seconds = Milli.slice(0, -1);
var Minutes = Seconds.slice(0, -1);
var Hours = Minutes.slice(0, -1);
var Day = Hours.slice(0, -1);
var Week = [YEAR, WEEK];
var Month = [YEAR, MONTH];
var Year = [YEAR];
var intervals = [[Seconds, 1, durationSecond2], [Seconds, 5, 5 * durationSecond2], [Seconds, 15, 15 * durationSecond2], [Seconds, 30, 30 * durationSecond2], [Minutes, 1, durationMinute2], [Minutes, 5, 5 * durationMinute2], [Minutes, 15, 15 * durationMinute2], [Minutes, 30, 30 * durationMinute2], [Hours, 1, durationHour2], [Hours, 3, 3 * durationHour2], [Hours, 6, 6 * durationHour2], [Hours, 12, 12 * durationHour2], [Day, 1, durationDay2], [Week, 1, durationWeek2], [Month, 1, durationMonth2], [Month, 3, 3 * durationMonth2], [Year, 1, durationYear2]];
function bin(opt) {
  const ext = opt.extent, max4 = opt.maxbins || 40, target2 = Math.abs(span(ext)) / max4;
  let i = bisector_default((i2) => i2[2]).right(intervals, target2), units, step;
  if (i === intervals.length) {
    units = Year, step = tickStep(ext[0] / durationYear2, ext[1] / durationYear2, max4);
  } else if (i) {
    i = intervals[target2 / intervals[i - 1][2] < intervals[i][2] / target2 ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max(tickStep(ext[0], ext[1], max4), 1);
  }
  return {
    units,
    step
  };
}

// node_modules/d3-time-format/src/locale.js
function localDate2(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate2(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y5, m2, d) {
  return { y: y5, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale4) {
  var locale_dateTime = locale4.dateTime, locale_date = locale4.date, locale_time = locale4.time, locale_periods = locale4.periods, locale_weekdays = locale4.days, locale_shortWeekdays = locale4.shortDays, locale_months = locale4.months, locale_shortMonths = locale4.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats3 = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats3.x = newFormat(locale_date, formats3);
  formats3.X = newFormat(locale_time, formats3);
  formats3.c = newFormat(locale_dateTime, formats3);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats4) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c2, pad4, format5;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad4 = pads[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad4 = c2 === "e" ? " " : "0";
          if (format5 = formats4[c2])
            c2 = format5(date2, pad4);
          string.push(c2);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week2, day2;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week2 = utcDate2(newDate(d.y, 0, 1)), day2 = week2.getUTCDay();
          week2 = day2 > 4 || day2 === 0 ? utcMonday.ceil(week2) : utcMonday(week2);
          week2 = utcDay_default.offset(week2, (d.V - 1) * 7);
          d.y = week2.getUTCFullYear();
          d.m = week2.getUTCMonth();
          d.d = week2.getUTCDate() + (d.w + 6) % 7;
        } else {
          week2 = localDate2(newDate(d.y, 0, 1)), day2 = week2.getDay();
          week2 = day2 > 4 || day2 === 0 ? monday.ceil(week2) : monday(week2);
          week2 = day_default.offset(week2, (d.V - 1) * 7);
          d.y = week2.getFullYear();
          d.m = week2.getMonth();
          d.d = week2.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate2(newDate(d.y, 0, 1)).getUTCDay() : localDate2(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate2(d);
      }
      return localDate2(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m2 = string.length, c2, parse6;
    while (i < n) {
      if (j >= m2)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse6 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse6 || (j = parse6(d, string, j)) < 0)
          return -1;
      } else if (c2 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats3);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad3(value3, fill2, width2) {
  var sign3 = value3 < 0 ? "-" : "", string = (sign3 ? -value3 : value3) + "", length2 = string.length;
  return sign3 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill2) + string : string);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad3(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad3(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad3(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad3(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad3(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad3(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad3(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad3(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad3(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad3(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad3(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad3(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad3(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad3(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad3(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad3(z / 60 | 0, "0", 2) + pad3(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad3(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad3(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad3(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad3(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad3(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad3(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad3(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad3(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad3(utcSunday.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad3(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad3(utcMonday.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad3(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad3(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad3(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad3(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition3) {
  locale2 = formatLocale(definition3);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/vega-format/build/vega-format.module.js
function memoize(method2) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method2(spec));
}
function trimZeroes(numberFormat, decimalChar) {
  return (x5) => {
    const str = numberFormat(x5), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit(str, dec) {
  let i = str.lastIndexOf("e"), c2;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c2 = str.charCodeAt(i);
    if (c2 >= 48 && c2 <= 57)
      return i + 1;
  }
}
function numberLocale(locale4) {
  const format5 = memoize(locale4.format), formatPrefix2 = locale4.formatPrefix;
  return {
    format: format5,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s = formatSpecifier(spec || ",");
      if (s.precision == null) {
        s.precision = 12;
        switch (s.type) {
          case "%":
            s.precision -= 2;
            break;
          case "e":
            s.precision -= 1;
            break;
        }
        return trimZeroes(format5(s), format5(".1f")(1)[1]);
      } else {
        return format5(s);
      }
    },
    formatSpan(start, stop2, count2, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count2), value3 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value3))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value3);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value3))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format5(specifier);
    }
  };
}
var defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format: format2,
    formatPrefix
  });
}
function numberFormatLocale(definition3) {
  return numberLocale(locale_default(definition3));
}
function numberFormatDefaultLocale(definition3) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition3) : defaultNumberLocale;
}
function timeMultiFormat(format5, interval3, spec) {
  spec = spec || {};
  if (!isObject(spec)) {
    error("Invalid time multi-format specifier: ".concat(spec));
  }
  const second2 = interval3(SECONDS), minute2 = interval3(MINUTES), hour2 = interval3(HOURS), day2 = interval3(DATE), week2 = interval3(WEEK), month2 = interval3(MONTH), quarter2 = interval3(QUARTER), year2 = interval3(YEAR), L = format5(spec[MILLISECONDS] || ".%L"), S = format5(spec[SECONDS] || ":%S"), M2 = format5(spec[MINUTES] || "%I:%M"), H = format5(spec[HOURS] || "%I %p"), d = format5(spec[DATE] || spec[DAY] || "%a %d"), w2 = format5(spec[WEEK] || "%b %d"), m2 = format5(spec[MONTH] || "%B"), q = format5(spec[QUARTER] || "%B"), y5 = format5(spec[YEAR] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute2(date2) < date2 ? S : hour2(date2) < date2 ? M2 : day2(date2) < date2 ? H : month2(date2) < date2 ? week2(date2) < date2 ? d : w2 : year2(date2) < date2 ? quarter2(date2) < date2 ? m2 : q : y5)(date2);
}
function timeLocale(locale4) {
  const timeFormat3 = memoize(locale4.format), utcFormat3 = memoize(locale4.utcFormat);
  return {
    timeFormat: (spec) => isString(spec) ? timeFormat3(spec) : timeMultiFormat(timeFormat3, timeInterval, spec),
    utcFormat: (spec) => isString(spec) ? utcFormat3(spec) : timeMultiFormat(utcFormat3, utcInterval, spec),
    timeParse: memoize(locale4.parse),
    utcParse: memoize(locale4.utcParse)
  };
}
var defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}
function timeFormatLocale(definition3) {
  return timeLocale(formatLocale(definition3));
}
function timeFormatDefaultLocale(definition3) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition3) : defaultTimeLocale;
}
var createLocale = (number7, time3) => extend({}, number7, time3);
function locale3(numberSpec, timeSpec) {
  const number7 = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time3 = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number7, time3);
}
function defaultLocale3(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale3();
}

// node_modules/vega-loader/src/read.js
function read_default(data3, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || "json");
  if (!reader)
    error("Unknown data format type: " + schema.type);
  data3 = reader(data3, schema);
  if (schema.parse)
    parse(data3, schema.parse, timeParser, utcParser);
  if (has(data3, "columns"))
    delete data3.columns;
  return data3;
}
function parse(data3, types2, timeParser, utcParser) {
  if (!data3.length)
    return;
  const locale4 = timeFormatDefaultLocale();
  timeParser = timeParser || locale4.timeParse;
  utcParser = utcParser || locale4.utcParse;
  let fields = data3.columns || Object.keys(data3[0]), datum2, field3, i, j, n, m2;
  if (types2 === "auto")
    types2 = inferTypes(data3, fields);
  fields = Object.keys(types2);
  const parsers = fields.map((field4) => {
    const type2 = types2[field4];
    let parts, pattern;
    if (type2 && (type2.startsWith("date:") || type2.startsWith("utc:"))) {
      parts = type2.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse6 = parts[0] === "utc" ? utcParser : timeParser;
      return parse6(pattern);
    }
    if (!typeParsers[type2]) {
      throw Error("Illegal format pattern: " + field4 + ":" + type2);
    }
    return typeParsers[type2];
  });
  for (i = 0, n = data3.length, m2 = fields.length; i < n; ++i) {
    datum2 = data3[i];
    for (j = 0; j < m2; ++j) {
      field3 = fields[j];
      datum2[field3] = parsers[j](datum2[field3]);
    }
  }
}

// node_modules/vega-loader/index.browser.js
var loader = loader_default(typeof fetch !== "undefined" && fetch, null);

// node_modules/vega-dataflow/build/vega-dataflow.module.js
function UniqueList(idFunc) {
  const $2 = idFunc || identity, list = [], ids = {};
  list.add = (_) => {
    const id2 = $2(_);
    if (!ids[id2]) {
      ids[id2] = 1;
      list.push(_);
    }
    return list;
  };
  list.remove = (_) => {
    const id2 = $2(_);
    if (ids[id2]) {
      ids[id2] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0)
        list.splice(idx, 1);
    }
    return list;
  };
  return list;
}
async function asyncCallback(df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}
var TUPLE_ID_KEY = Symbol("vega_id");
var TUPLE_ID = 1;
function isTuple(t) {
  return !!(t && tupleid(t));
}
function tupleid(t) {
  return t[TUPLE_ID_KEY];
}
function setid(t, id2) {
  t[TUPLE_ID_KEY] = id2;
  return t;
}
function ingest$1(datum2) {
  const t = datum2 === Object(datum2) ? datum2 : {
    data: datum2
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}
function derive(t) {
  return rederive(t, ingest$1({}));
}
function rederive(t, d) {
  for (const k in t)
    d[k] = t[k];
  return d;
}
function replace(t, d) {
  return setid(d, tupleid(t));
}
function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a2, b2) => cmp(a2, b2) || tupleid(f(a2)) - tupleid(f(b2)) : (a2, b2) => cmp(a2, b2) || tupleid(a2) - tupleid(b2);
}
function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add5 = [], rem2 = [], mod = [], remp = [], modp = [];
  let clean = null, reflow2 = false;
  return {
    constructor: changeset,
    insert(t) {
      const d = array(t), n = d.length;
      for (let i = 0; i < n; ++i)
        add5.push(d[i]);
      return this;
    },
    remove(t) {
      const a2 = isFunction(t) ? remp : rem2, d = array(t), n = d.length;
      for (let i = 0; i < n; ++i)
        a2.push(d[i]);
      return this;
    },
    modify(t, field3, value3) {
      const m2 = {
        field: field3,
        value: constant(value3)
      };
      if (isFunction(t)) {
        m2.filter = t;
        modp.push(m2);
      } else {
        m2.tuple = t;
        mod.push(m2);
      }
      return this;
    },
    encode(t, set5) {
      if (isFunction(t))
        modp.push({
          filter: t,
          field: set5
        });
      else
        mod.push({
          tuple: t,
          field: set5
        });
      return this;
    },
    clean(value3) {
      clean = value3;
      return this;
    },
    reflow() {
      reflow2 = true;
      return this;
    },
    pulse(pulse2, tuples) {
      const cur = {}, out = {};
      let i, n, m2, f, t, id2;
      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      }
      for (i = 0, n = rem2.length; i < n; ++i) {
        t = rem2[i];
        cur[tupleid(t)] = -1;
      }
      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach((t4) => {
          if (f(t4))
            cur[tupleid(t4)] = -1;
        });
      }
      for (i = 0, n = add5.length; i < n; ++i) {
        t = add5[i];
        id2 = tupleid(t);
        if (cur[id2]) {
          cur[id2] = 1;
        } else {
          pulse2.add.push(ingest$1(add5[i]));
        }
      }
      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0)
          pulse2.rem.push(t);
      }
      function modify2(t4, f2, v) {
        if (v) {
          t4[f2] = v(t4);
        } else {
          pulse2.encode = f2;
        }
        if (!reflow2)
          out[tupleid(t4)] = t4;
      }
      for (i = 0, n = mod.length; i < n; ++i) {
        m2 = mod[i];
        t = m2.tuple;
        f = m2.field;
        id2 = cur[tupleid(t)];
        if (id2 > 0) {
          modify2(t, f, m2.value);
          pulse2.modifies(f);
        }
      }
      for (i = 0, n = modp.length; i < n; ++i) {
        m2 = modp[i];
        f = m2.filter;
        tuples.forEach((t4) => {
          if (f(t4) && cur[tupleid(t4)] > 0) {
            modify2(t4, m2.field, m2.value);
          }
        });
        pulse2.modifies(m2.field);
      }
      if (reflow2) {
        pulse2.mod = rem2.length || remp.length ? tuples.filter((t4) => cur[tupleid(t4)] > 0) : tuples.slice();
      } else {
        for (id2 in out)
          pulse2.mod.push(out[id2]);
      }
      if (clean || clean == null && (rem2.length || remp.length)) {
        pulse2.clean(true);
      }
      return pulse2;
    }
  };
}
var CACHE = "_:mod:_";
function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  set(name2, index3, value3, force) {
    const o = this, v = o[name2], mod = o[CACHE];
    if (index3 != null && index3 >= 0) {
      if (v[index3] !== value3 || force) {
        v[index3] = value3;
        mod[index3 + ":" + name2] = -1;
        mod[name2] = -1;
      }
    } else if (v !== value3 || force) {
      o[name2] = value3;
      mod[name2] = isArray(value3) ? 1 + value3.length : -1;
    }
    return o;
  },
  modified(name2, index3) {
    const mod = this[CACHE];
    if (!arguments.length) {
      for (const k in mod) {
        if (mod[k])
          return true;
      }
      return false;
    } else if (isArray(name2)) {
      for (let k = 0; k < name2.length; ++k) {
        if (mod[name2[k]])
          return true;
      }
      return false;
    }
    return index3 != null && index3 >= 0 ? index3 + 1 < mod[name2] || !!mod[index3 + ":" + name2] : !!mod[name2];
  },
  clear() {
    this[CACHE] = {};
    return this;
  }
};
var OP_ID = 0;
var PULSE = "pulse";
var NO_PARAMS = new Parameters();
var SKIP$1 = 1;
var MODIFIED = 2;
function Operator(init2, update3, params2, react) {
  this.id = ++OP_ID;
  this.value = init2;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;
  if (update3) {
    this._update = update3;
  }
  if (params2)
    this.parameters(params2, react);
}
function flag(bit) {
  return function(state) {
    const f = this.flags;
    if (arguments.length === 0)
      return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}
Operator.prototype = {
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  set(value3) {
    if (this.value !== value3) {
      this.value = value3;
      return 1;
    } else {
      return 0;
    }
  },
  skip: flag(SKIP$1),
  modified: flag(MODIFIED),
  parameters(params2, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(), argops = this._argops = this._argops || [], deps = [];
    let name2, value3, n, i;
    const add5 = (name3, index3, value4) => {
      if (value4 instanceof Operator) {
        if (value4 !== this) {
          if (react)
            value4.targets().add(this);
          deps.push(value4);
        }
        argops.push({
          op: value4,
          name: name3,
          index: index3
        });
      } else {
        argval.set(name3, index3, value4);
      }
    };
    for (name2 in params2) {
      value3 = params2[name2];
      if (name2 === PULSE) {
        array(value3).forEach((op) => {
          if (!(op instanceof Operator)) {
            error("Pulse parameters must be operator instances.");
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value3;
      } else if (isArray(value3)) {
        argval.set(name2, -1, Array(n = value3.length));
        for (i = 0; i < n; ++i)
          add5(name2, i, value3[i]);
      } else {
        add5(name2, -1, value3);
      }
    }
    this.marshall().clear();
    if (initonly)
      argops.initonly = true;
    return deps;
  },
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS, argops = this._argops;
    let item, i, op, mod;
    if (argops) {
      const n = argops.length;
      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }
      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }
        this._argops = null;
        this._update = null;
      }
    }
    return argval;
  },
  detach() {
    const argops = this._argops;
    let i, n, item, op;
    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;
        if (op._targets) {
          op._targets.remove(this);
        }
      }
    }
    this.pulse = null;
    this.source = null;
  },
  evaluate(pulse2) {
    const update3 = this._update;
    if (update3) {
      const params2 = this.marshall(pulse2.stamp), v = update3.call(this, params2, pulse2);
      params2.clear();
      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse2.StopPropagation;
      }
    }
  },
  run(pulse2) {
    if (pulse2.stamp < this.stamp)
      return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse2);
    }
    return this.pulse = rv || pulse2;
  }
};
function add(init2, update3, params2, react) {
  let shift = 1, op;
  if (init2 instanceof Operator) {
    op = init2;
  } else if (init2 && init2.prototype instanceof Operator) {
    op = new init2();
  } else if (isFunction(init2)) {
    op = new Operator(null, init2);
  } else {
    shift = 0;
    op = new Operator(init2, update3);
  }
  this.rank(op);
  if (shift) {
    react = params2;
    params2 = update3;
  }
  if (params2)
    this.connect(op, op.parameters(params2, react));
  this.touch(op);
  return op;
}
function connect(target2, sources) {
  const targetRank = target2.rank, n = sources.length;
  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target2);
      return;
    }
  }
}
var STREAM_ID = 0;
function EventStream(filter3, apply2, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive)
    this.receive = receive;
  if (filter3)
    this._filter = filter3;
  if (apply2)
    this._apply = apply2;
}
function stream(filter3, apply2, receive) {
  return new EventStream(filter3, apply2, receive);
}
EventStream.prototype = {
  _filter: truthy,
  _apply: identity,
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  consume(_) {
    if (!arguments.length)
      return !!this._consume;
    this._consume = !!_;
    return this;
  },
  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt), trg = this._targets, n = trg ? trg.length : 0;
      for (let i = 0; i < n; ++i)
        trg[i].receive(val);
      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },
  filter(filter3) {
    const s = stream(filter3);
    this.targets().add(s);
    return s;
  },
  apply(apply2) {
    const s = stream(null, apply2);
    this.targets().add(s);
    return s;
  },
  merge() {
    const s = stream();
    this.targets().add(s);
    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }
    return s;
  },
  throttle(pause) {
    let t = -1;
    return this.filter(() => {
      const now3 = Date.now();
      if (now3 - t > pause) {
        t = now3;
        return 1;
      } else {
        return 0;
      }
    });
  },
  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, debounce(delay, (e) => {
      const df = e.dataflow;
      s.receive(e);
      if (df && df.run)
        df.run();
    })));
    return s;
  },
  between(a2, b2) {
    let active = false;
    a2.targets().add(stream(null, null, () => active = true));
    b2.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },
  detach() {
    this._filter = truthy;
    this._targets = null;
  }
};
function events(source3, type2, filter3, apply2) {
  const df = this, s = stream(filter3, apply2), send = function(e) {
    e.dataflow = df;
    try {
      s.receive(e);
    } catch (error2) {
      df.error(error2);
    } finally {
      df.run();
    }
  };
  let sources;
  if (typeof source3 === "string" && typeof document !== "undefined") {
    sources = document.querySelectorAll(source3);
  } else {
    sources = array(source3);
  }
  const n = sources.length;
  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type2, send);
  }
  return s;
}
function parse2(data3, format5) {
  const locale4 = this.locale();
  return read_default(data3, format5, locale4.timeParse, locale4.utcParse);
}
function ingest(target2, data3, format5) {
  data3 = this.parse(data3, format5);
  return this.pulse(target2, this.changeset().insert(data3));
}
async function request(url, format5) {
  const df = this;
  let status = 0, data3;
  try {
    data3 = await df.loader().load(url, {
      context: "dataflow",
      response: responseType(format5 && format5.type)
    });
    try {
      data3 = df.parse(data3, format5);
    } catch (err) {
      status = -2;
      df.warn("Data ingestion failed", url, err);
    }
  } catch (err) {
    status = -1;
    df.warn("Loading failed", url, err);
  }
  return {
    data: data3,
    status
  };
}
async function preload(target2, url, format5) {
  const df = this, pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format5);
  df.pulse(target2, df.changeset().remove(truthy).insert(res.data || []));
  pending.done();
  return res;
}
function loadPending(df) {
  let accept;
  const pending = new Promise((a2) => accept = a2);
  pending.requests = 0;
  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };
  return df._pending = pending;
}
var SKIP = {
  skip: true
};
function on(source3, target2, update3, params2, options) {
  const fn = source3 instanceof Operator ? onOperator : onStream;
  fn(this, source3, target2, update3, params2, options);
  return this;
}
function onStream(df, stream2, target2, update3, params2, options) {
  const opt = extend({}, options, SKIP);
  let func, op;
  if (!isFunction(target2))
    target2 = constant(target2);
  if (update3 === void 0) {
    func = (e) => df.touch(target2(e));
  } else if (isFunction(update3)) {
    op = new Operator(null, update3, params2, false);
    func = (e) => {
      op.evaluate(e);
      const t = target2(e), v = op.value;
      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);
    };
  } else {
    func = (e) => df.update(target2(e), update3, opt);
  }
  stream2.apply(func);
}
function onOperator(df, source3, target2, update3, params2, options) {
  if (update3 === void 0) {
    source3.targets().add(target2);
  } else {
    const opt = options || {}, op = new Operator(null, updater(target2, update3), params2, false);
    op.modified(opt.force);
    op.rank = source3.rank;
    source3.targets().add(op);
    if (target2) {
      op.skip(true);
      op.value = target2.value;
      op.targets().add(target2);
      df.connect(target2, [op]);
    }
  }
}
function updater(target2, update3) {
  update3 = isFunction(update3) ? update3 : constant(update3);
  return target2 ? function(_, pulse2) {
    const value3 = update3(_, pulse2);
    if (!target2.skip()) {
      target2.skip(value3 !== this.value).value = value3;
    }
    return value3;
  } : update3;
}
function rank(op) {
  op.rank = ++this._rank;
}
function rerank(op) {
  const queue = [op];
  let cur, list, i;
  while (queue.length) {
    this.rank(cur = queue.pop());
    if (list = cur._targets) {
      for (i = list.length; --i >= 0; ) {
        queue.push(cur = list[i]);
        if (cur === op)
          error("Cycle detected in dataflow graph.");
      }
    }
  }
}
var StopPropagation = {};
var ADD = 1 << 0;
var REM = 1 << 1;
var MOD = 1 << 2;
var ADD_REM = ADD | REM;
var ADD_MOD = ADD | MOD;
var ALL = ADD | REM | MOD;
var REFLOW = 1 << 3;
var SOURCE = 1 << 4;
var NO_SOURCE = 1 << 5;
var NO_FIELDS = 1 << 6;
function Pulse(dataflow, stamp, encode2) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode2 || null;
}
function materialize(data3, filter3) {
  const out = [];
  visitArray(data3, filter3, (_) => out.push(_));
  return out;
}
function filter(pulse2, flags) {
  const map3 = {};
  pulse2.visit(flags, (t) => {
    map3[tupleid(t)] = 1;
  });
  return (t) => map3[tupleid(t)] ? null : t;
}
function addFilter(a2, b2) {
  return a2 ? (t, i) => a2(t, i) && b2(t, i) : b2;
}
Pulse.prototype = {
  StopPropagation,
  ADD,
  REM,
  MOD,
  ADD_REM,
  ADD_MOD,
  ALL,
  REFLOW,
  SOURCE,
  NO_SOURCE,
  NO_FIELDS,
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source)
      p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem || !p.rem.length && p.source.length === p.add.length;
    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = [];
      return p;
    }
  },
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;
    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }
    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }
    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }
    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }
    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans)
        p.cleans = src.cleans;
    }
    return p;
  },
  runAfter(func) {
    this.dataflow.runAfter(func);
  },
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },
  reflow(fork) {
    if (fork)
      return this.fork(ALL).reflow();
    const len = this.add.length, src = this.source && this.source.length;
    if (src && src !== len) {
      this.mod = this.source;
      if (len)
        this.filter(MOD, filter(this, ADD));
    }
    return this;
  },
  clean(value3) {
    if (arguments.length) {
      this.cleans = !!value3;
      return this;
    } else {
      return this.cleans;
    }
  },
  modifies(_) {
    const hash = this.fields || (this.fields = {});
    if (isArray(_)) {
      _.forEach((f) => hash[f] = true);
    } else {
      hash[_] = true;
    }
    return this;
  },
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some((f) => fields[f]) : fields[_];
  },
  filter(flags, filter3) {
    const p = this;
    if (flags & ADD)
      p.addF = addFilter(p.addF, filter3);
    if (flags & REM)
      p.remF = addFilter(p.remF, filter3);
    if (flags & MOD)
      p.modF = addFilter(p.modF, filter3);
    if (flags & SOURCE)
      p.srcF = addFilter(p.srcF, filter3);
    return p;
  },
  materialize(flags) {
    flags = flags || ALL;
    const p = this;
    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }
    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }
    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }
    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }
    return p;
  },
  visit(flags, visitor) {
    const p = this, v = visitor;
    if (flags & SOURCE) {
      visitArray(p.source, p.srcF, v);
      return p;
    }
    if (flags & ADD)
      visitArray(p.add, p.addF, v);
    if (flags & REM)
      visitArray(p.rem, p.remF, v);
    if (flags & MOD)
      visitArray(p.mod, p.modF, v);
    const src = p.source;
    if (flags & REFLOW && src) {
      const sum2 = p.add.length + p.mod.length;
      if (sum2 === src.length)
        ;
      else if (sum2) {
        visitArray(src, filter(p, ADD_MOD), v);
      } else {
        visitArray(src, p.srcF, v);
      }
    }
    return p;
  }
};
function MultiPulse(dataflow, stamp, pulses, encode2) {
  const p = this, n = pulses.length;
  let c2 = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode2 || null;
  this.pulses = pulses;
  for (let i = 0; i < n; ++i) {
    const pulse2 = pulses[i];
    if (pulse2.stamp !== stamp)
      continue;
    if (pulse2.fields) {
      const hash = p.fields || (p.fields = {});
      for (const f in pulse2.fields) {
        hash[f] = 1;
      }
    }
    if (pulse2.changed(p.ADD))
      c2 |= p.ADD;
    if (pulse2.changed(p.REM))
      c2 |= p.REM;
    if (pulse2.changed(p.MOD))
      c2 |= p.MOD;
  }
  this.changes = c2;
}
inherits(MultiPulse, Pulse, {
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
    if (flags !== void 0) {
      if (flags & p.ADD)
        this.visit(p.ADD, (t) => p.add.push(t));
      if (flags & p.REM)
        this.visit(p.REM, (t) => p.rem.push(t));
      if (flags & p.MOD)
        this.visit(p.MOD, (t) => p.mod.push(t));
    }
    return p;
  },
  changed(flags) {
    return this.changes & flags;
  },
  modified(_) {
    const p = this, fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some((f) => fields[f]) : fields[_];
  },
  filter() {
    error("MultiPulse does not support filtering.");
  },
  materialize() {
    error("MultiPulse does not support materialization.");
  },
  visit(flags, visitor) {
    const p = this, pulses = p.pulses, n = pulses.length;
    let i = 0;
    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }
    return p;
  }
});
async function evaluate(encode2, prerun, postrun) {
  const df = this, async = [];
  if (df._pulse)
    return reentrant(df);
  if (df._pending)
    await df._pending;
  if (prerun)
    await asyncCallback(df, prerun);
  if (!df._touched.length) {
    df.debug("Dataflow invoked, but nothing to do.");
    return df;
  }
  const stamp = ++df._clock;
  df._pulse = new Pulse(df, stamp, encode2);
  df._touched.forEach((op2) => df._enqueue(op2, true));
  df._touched = UniqueList(id);
  let count2 = 0, op, next, error2;
  try {
    while (df._heap.size() > 0) {
      op = df._heap.pop();
      if (op.rank !== op.qrank) {
        df._enqueue(op, true);
        continue;
      }
      next = op.run(df._getPulse(op, encode2));
      if (next.then) {
        next = await next;
      } else if (next.async) {
        async.push(next.async);
        next = StopPropagation;
      }
      if (next !== StopPropagation) {
        if (op._targets)
          op._targets.forEach((op2) => df._enqueue(op2));
      }
      ++count2;
    }
  } catch (err) {
    df._heap.clear();
    error2 = err;
  }
  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count2} operators`);
  if (error2) {
    df._postrun = [];
    df.error(error2);
  }
  if (df._postrun.length) {
    const pr = df._postrun.sort((a2, b2) => b2.priority - a2.priority);
    df._postrun = [];
    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  }
  if (postrun)
    await asyncCallback(df, postrun);
  if (async.length) {
    Promise.all(async).then((cb) => df.runAsync(null, () => {
      cb.forEach((f) => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }
  return df;
}
async function runAsync(encode2, prerun, postrun) {
  while (this._running)
    await this._running;
  const clear = () => this._running = null;
  (this._running = this.evaluate(encode2, prerun, postrun)).then(clear, clear);
  return this._running;
}
function run(encode2, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode2, prerun, postrun), this);
}
function runAfter(callback, enqueue2, priority) {
  if (this._pulse || enqueue2) {
    this._postrun.push({
      priority: priority || 0,
      callback
    });
  } else {
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
function reentrant(df) {
  df.error("Dataflow already running. Use runAsync() to chain invocations.");
  return df;
}
function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q)
    op.stamp = this._clock;
  if (q || force) {
    op.qrank = op.rank;
    this._heap.push(op);
  }
}
function getPulse(op, encode2) {
  const s = op.source, stamp = this._clock;
  return s && isArray(s) ? new MultiPulse(this, stamp, s.map((_) => _.pulse), encode2) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}
function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }
  p = p.fork();
  if (s && s !== StopPropagation) {
    p.source = s.source;
  }
  return p;
}
var NO_OPT = {
  skip: false,
  force: false
};
function touch(op, options) {
  const opt = options || NO_OPT;
  if (this._pulse) {
    this._enqueue(op);
  } else {
    this._touched.add(op);
  }
  if (opt.skip)
    op.skip(true);
  return this;
}
function update(op, value3, options) {
  const opt = options || NO_OPT;
  if (op.set(value3) || opt.force) {
    this.touch(op, opt);
  }
  return this;
}
function pulse(op, changeset2, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset2.pulse(p, t);
  return this;
}
function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: (x5) => {
      nodes.push(x5);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;
      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }
      return item;
    }
  };
}
function siftdown(array4, start, idx, cmp) {
  let parent, pidx;
  const item = array4[idx];
  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array4[pidx];
    if (cmp(item, parent) < 0) {
      array4[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return array4[idx] = item;
}
function siftup(array4, idx, cmp) {
  const start = idx, end = array4.length, item = array4[idx];
  let cidx = (idx << 1) + 1, ridx;
  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp(array4[cidx], array4[ridx]) >= 0) {
      cidx = ridx;
    }
    array4[idx] = array4[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }
  array4[idx] = item;
  return siftdown(array4, start, idx, cmp);
}
function Dataflow() {
  this.logger(logger());
  this.logLevel(Error$1);
  this._clock = 0;
  this._rank = 0;
  this._locale = defaultLocale3();
  try {
    this._loader = loader();
  } catch (e) {
  }
  this._touched = UniqueList(id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a2, b2) => a2.qrank - b2.qrank);
  this._postrun = [];
}
function logMethod(method2) {
  return function() {
    return this._log[method2].apply(this, arguments);
  };
}
Dataflow.prototype = {
  stamp() {
    return this._clock;
  },
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },
  logger(logger2) {
    if (arguments.length) {
      this._log = logger2;
      return this;
    } else {
      return this._log;
    }
  },
  error: logMethod("error"),
  warn: logMethod("warn"),
  info: logMethod("info"),
  debug: logMethod("debug"),
  logLevel: logMethod("level"),
  cleanThreshold: 1e4,
  add,
  connect,
  rank,
  rerank,
  pulse,
  touch,
  update,
  changeset,
  ingest,
  parse: parse2,
  preload,
  request,
  events,
  on,
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};
function Transform(init2, params2) {
  Operator.call(this, init2, null, params2);
}
inherits(Transform, Operator, {
  run(pulse2) {
    if (pulse2.stamp < this.stamp)
      return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse2);
    }
    rv = rv || pulse2;
    if (rv.then) {
      rv = rv.then((_) => this.pulse = _);
    } else if (rv !== pulse2.StopPropagation) {
      this.pulse = rv;
    }
    return rv;
  },
  evaluate(pulse2) {
    const params2 = this.marshall(pulse2.stamp), out = this.transform(params2, pulse2);
    params2.clear();
    return out;
  },
  transform() {
  }
});
var transforms = {};
function definition(type2) {
  const t = transform(type2);
  return t && t.Definition || null;
}
function transform(type2) {
  type2 = type2 && type2.toLowerCase();
  return has(transforms, type2) ? transforms[type2] : null;
}

// node_modules/vega-transforms/build/vega-transforms.module.js
var vega_transforms_module_exports = {};
__export(vega_transforms_module_exports, {
  aggregate: () => Aggregate,
  bin: () => Bin,
  collect: () => Collect,
  compare: () => Compare,
  countpattern: () => CountPattern,
  cross: () => Cross,
  density: () => Density,
  dotbin: () => DotBin,
  expression: () => Expression,
  extent: () => Extent,
  facet: () => Facet,
  field: () => Field,
  filter: () => Filter,
  flatten: () => Flatten,
  fold: () => Fold,
  formula: () => Formula,
  generate: () => Generate,
  impute: () => Impute,
  joinaggregate: () => JoinAggregate,
  kde: () => KDE,
  key: () => Key,
  load: () => Load,
  lookup: () => Lookup,
  multiextent: () => MultiExtent,
  multivalues: () => MultiValues,
  params: () => Params,
  pivot: () => Pivot,
  prefacet: () => PreFacet,
  project: () => Project,
  proxy: () => Proxy,
  quantile: () => Quantile,
  relay: () => Relay,
  sample: () => Sample,
  sequence: () => Sequence,
  sieve: () => Sieve,
  subflow: () => Subflow,
  timeunit: () => TimeUnit,
  tupleindex: () => TupleIndex,
  values: () => Values,
  window: () => Window
});

// node_modules/vega-statistics/build/vega-statistics.module.js
function* numbers2(values2, valueof) {
  if (valueof == null) {
    for (let value3 of values2) {
      if (value3 != null && value3 !== "" && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  } else {
    let index3 = -1;
    for (let value3 of values2) {
      value3 = valueof(value3, ++index3, values2);
      if (value3 != null && value3 !== "" && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  }
}
function quantiles(array4, p, f) {
  const values2 = Float64Array.from(numbers2(array4, f));
  values2.sort(ascending_default);
  return p.map((_) => quantileSorted(values2, _));
}
function quartiles(array4, f) {
  return quantiles(array4, [0.25, 0.5, 0.75], f);
}
function estimateBandwidth(array4, f) {
  const n = array4.length, d = deviation(array4, f), q = quartiles(array4, f), h2 = (q[2] - q[0]) / 1.34, v = Math.min(d, h2) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}
function bin2(_) {
  const maxb = _.maxbins || 20, base2 = _.base || 10, logb = Math.log(base2), div = _.divide || [5, 2];
  let min4 = _.extent[0], max4 = _.extent[1], step, level, minstep, v, i, n;
  const span2 = _.span || max4 - min4 || Math.abs(min4) || 1;
  if (_.step) {
    step = _.step;
  } else if (_.steps) {
    v = span2 / maxb;
    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i)
      ;
    step = _.steps[Math.max(0, i - 1)];
  } else {
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base2, Math.round(Math.log(span2) / logb) - level));
    while (Math.ceil(span2 / step) > maxb) {
      step *= base2;
    }
    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span2 / v <= maxb)
        step = v;
    }
  }
  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1, eps = Math.pow(base2, -precision - 1);
  if (_.nice || _.nice === void 0) {
    v = Math.floor(min4 / step + eps) * step;
    min4 = min4 < v ? v - step : v;
    max4 = Math.ceil(max4 / step) * step;
  }
  return {
    start: min4,
    stop: max4 === min4 ? min4 + step : max4,
    step
  };
}
var random = Math.random;
function setRandom(r) {
  random = r;
}
function bootstrapCI(array4, samples, alpha, f) {
  if (!array4.length)
    return [void 0, void 0];
  const values2 = Float64Array.from(numbers2(array4, f)), n = values2.length, m2 = samples;
  let a2, i, j, mu;
  for (j = 0, mu = Array(m2); j < m2; ++j) {
    for (a2 = 0, i = 0; i < n; ++i) {
      a2 += values2[~~(random() * n)];
    }
    mu[j] = a2 / n;
  }
  mu.sort(ascending_default);
  return [quantile(mu, alpha / 2), quantile(mu, 1 - alpha / 2)];
}
function dotbin(array4, step, smooth, f) {
  f = f || ((_) => _);
  const n = array4.length, v = new Float64Array(n);
  let i = 0, j = 1, a2 = f(array4[0]), b2 = a2, w2 = a2 + step, x5;
  for (; j < n; ++j) {
    x5 = f(array4[j]);
    if (x5 >= w2) {
      b2 = (a2 + b2) / 2;
      for (; i < j; ++i)
        v[i] = b2;
      w2 = x5 + step;
      a2 = x5;
    }
    b2 = x5;
  }
  b2 = (a2 + b2) / 2;
  for (; i < j; ++i)
    v[i] = b2;
  return smooth ? smoothing(v, step + step / 4) : v;
}
function smoothing(v, thresh) {
  const n = v.length;
  let a2 = 0, b2 = 1, c2, d;
  while (v[a2] === v[b2])
    ++b2;
  while (b2 < n) {
    c2 = b2 + 1;
    while (v[b2] === v[c2])
      ++c2;
    if (v[b2] - v[b2 - 1] < thresh) {
      d = b2 + (a2 + c2 - b2 - b2 >> 1);
      while (d < b2)
        v[d++] = v[b2];
      while (d > b2)
        v[d--] = v[a2];
    }
    a2 = b2;
    b2 = c2;
  }
  return v;
}
function lcg(seed) {
  return function() {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}
function integer(min4, max4) {
  if (max4 == null) {
    max4 = min4;
    min4 = 0;
  }
  let a2, b2, d;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a2 = _ || 0;
        d = b2 - a2;
        return dist2;
      } else {
        return a2;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ || 0;
        d = b2 - a2;
        return dist2;
      } else {
        return b2;
      }
    },
    sample() {
      return a2 + Math.floor(d * random());
    },
    pdf(x5) {
      return x5 === Math.floor(x5) && x5 >= a2 && x5 < b2 ? 1 / d : 0;
    },
    cdf(x5) {
      const v = Math.floor(x5);
      return v < a2 ? 0 : v >= b2 ? 1 : (v - a2 + 1) / d;
    },
    icdf(p) {
      return p >= 0 && p <= 1 ? a2 - 1 + Math.floor(p * d) : NaN;
    }
  };
  return dist2.min(min4).max(max4);
}
var SQRT2PI = Math.sqrt(2 * Math.PI);
var SQRT2 = Math.SQRT2;
var nextSample = NaN;
function sampleNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  let x5 = 0, y5 = 0, rds, c2;
  if (nextSample === nextSample) {
    x5 = nextSample;
    nextSample = NaN;
  } else {
    do {
      x5 = random() * 2 - 1;
      y5 = random() * 2 - 1;
      rds = x5 * x5 + y5 * y5;
    } while (rds === 0 || rds > 1);
    c2 = Math.sqrt(-2 * Math.log(rds) / rds);
    x5 *= c2;
    nextSample = y5 * c2;
  }
  return mean2 + x5 * stdev;
}
function densityNormal(value3, mean2, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value3 - (mean2 || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
}
function cumulativeNormal(value3, mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value3 - mean2) / stdev, Z = Math.abs(z);
  let cd;
  if (Z > 37) {
    cd = 0;
  } else {
    const exp4 = Math.exp(-Z * Z / 2);
    let sum2;
    if (Z < 7.07106781186547) {
      sum2 = 0.0352624965998911 * Z + 0.700383064443688;
      sum2 = sum2 * Z + 6.37396220353165;
      sum2 = sum2 * Z + 33.912866078383;
      sum2 = sum2 * Z + 112.079291497871;
      sum2 = sum2 * Z + 221.213596169931;
      sum2 = sum2 * Z + 220.206867912376;
      cd = exp4 * sum2;
      sum2 = 0.0883883476483184 * Z + 1.75566716318264;
      sum2 = sum2 * Z + 16.064177579207;
      sum2 = sum2 * Z + 86.7807322029461;
      sum2 = sum2 * Z + 296.564248779674;
      sum2 = sum2 * Z + 637.333633378831;
      sum2 = sum2 * Z + 793.826512519948;
      sum2 = sum2 * Z + 440.413735824752;
      cd = cd / sum2;
    } else {
      sum2 = Z + 0.65;
      sum2 = Z + 4 / sum2;
      sum2 = Z + 3 / sum2;
      sum2 = Z + 2 / sum2;
      sum2 = Z + 1 / sum2;
      cd = exp4 / sum2 / 2.506628274631;
    }
  }
  return z > 0 ? 1 - cd : cd;
}
function quantileNormal(p, mean2, stdev) {
  if (p < 0 || p > 1)
    return NaN;
  return (mean2 || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}
function erfinv(x5) {
  let w2 = -Math.log((1 - x5) * (1 + x5)), p;
  if (w2 < 6.25) {
    w2 -= 3.125;
    p = -364441206401782e-35;
    p = -16850591381820166e-35 + p * w2;
    p = 128584807152564e-32 + p * w2;
    p = 11157877678025181e-33 + p * w2;
    p = -1333171662854621e-31 + p * w2;
    p = 20972767875968562e-33 + p * w2;
    p = 6637638134358324e-30 + p * w2;
    p = -4054566272975207e-29 + p * w2;
    p = -8151934197605472e-29 + p * w2;
    p = 26335093153082323e-28 + p * w2;
    p = -12975133253453532e-27 + p * w2;
    p = -5415412054294628e-26 + p * w2;
    p = 10512122733215323e-25 + p * w2;
    p = -4112633980346984e-24 + p * w2;
    p = -29070369957882005e-24 + p * w2;
    p = 42347877827932404e-23 + p * w2;
    p = -13654692000834679e-22 + p * w2;
    p = -13882523362786469e-21 + p * w2;
    p = 18673420803405714e-20 + p * w2;
    p = -740702534166267e-18 + p * w2;
    p = -0.006033670871430149 + p * w2;
    p = 0.24015818242558962 + p * w2;
    p = 1.6536545626831027 + p * w2;
  } else if (w2 < 16) {
    w2 = Math.sqrt(w2) - 3.25;
    p = 22137376921775787e-25;
    p = 9075656193888539e-23 + p * w2;
    p = -27517406297064545e-23 + p * w2;
    p = 18239629214389228e-24 + p * w2;
    p = 15027403968909828e-22 + p * w2;
    p = -4013867526981546e-21 + p * w2;
    p = 29234449089955446e-22 + p * w2;
    p = 12475304481671779e-21 + p * w2;
    p = -47318229009055734e-21 + p * w2;
    p = 6828485145957318e-20 + p * w2;
    p = 24031110387097894e-21 + p * w2;
    p = -3550375203628475e-19 + p * w2;
    p = 9532893797373805e-19 + p * w2;
    p = -0.0016882755560235047 + p * w2;
    p = 0.002491442096107851 + p * w2;
    p = -0.003751208507569241 + p * w2;
    p = 0.005370914553590064 + p * w2;
    p = 1.0052589676941592 + p * w2;
    p = 3.0838856104922208 + p * w2;
  } else if (Number.isFinite(w2)) {
    w2 = Math.sqrt(w2) - 5;
    p = -27109920616438573e-27;
    p = -2555641816996525e-25 + p * w2;
    p = 15076572693500548e-25 + p * w2;
    p = -3789465440126737e-24 + p * w2;
    p = 761570120807834e-23 + p * w2;
    p = -1496002662714924e-23 + p * w2;
    p = 2914795345090108e-23 + p * w2;
    p = -6771199775845234e-23 + p * w2;
    p = 22900482228026655e-23 + p * w2;
    p = -99298272942317e-20 + p * w2;
    p = 4526062597223154e-21 + p * w2;
    p = -1968177810553167e-20 + p * w2;
    p = 7599527703001776e-20 + p * w2;
    p = -21503011930044477e-20 + p * w2;
    p = -13871931833623122e-20 + p * w2;
    p = 1.0103004648645344 + p * w2;
    p = 4.849906401408584 + p * w2;
  } else {
    p = Infinity;
  }
  return p * x5;
}
function gaussian(mean2, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: (value3) => densityNormal(value3, mu, sigma),
    cdf: (value3) => cumulativeNormal(value3, mu, sigma),
    icdf: (p) => quantileNormal(p, mu, sigma)
  };
  return dist2.mean(mean2).stdev(stdev);
}
function kde(support, bandwidth2) {
  const kernel = gaussian();
  let n = 0;
  const dist2 = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist2.bandwidth(bandwidth2);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length)
        return bandwidth2;
      bandwidth2 = _;
      if (!bandwidth2 && support)
        bandwidth2 = estimateBandwidth(support);
      return dist2;
    },
    sample() {
      return support[~~(random() * n)] + bandwidth2 * kernel.sample();
    },
    pdf(x5) {
      let y5 = 0, i = 0;
      for (; i < n; ++i) {
        y5 += kernel.pdf((x5 - support[i]) / bandwidth2);
      }
      return y5 / bandwidth2 / n;
    },
    cdf(x5) {
      let y5 = 0, i = 0;
      for (; i < n; ++i) {
        y5 += kernel.cdf((x5 - support[i]) / bandwidth2);
      }
      return y5 / n;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return dist2.data(support);
}
function sampleLogNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean2 + sampleNormal() * stdev);
}
function densityLogNormal(value3, mean2, stdev) {
  if (value3 <= 0)
    return 0;
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value3) - mean2) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value3);
}
function cumulativeLogNormal(value3, mean2, stdev) {
  return cumulativeNormal(Math.log(value3), mean2, stdev);
}
function quantileLogNormal(p, mean2, stdev) {
  return Math.exp(quantileNormal(p, mean2, stdev));
}
function lognormal(mean2, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleLogNormal(mu, sigma),
    pdf: (value3) => densityLogNormal(value3, mu, sigma),
    cdf: (value3) => cumulativeLogNormal(value3, mu, sigma),
    icdf: (p) => quantileLogNormal(p, mu, sigma)
  };
  return dist2.mean(mean2).stdev(stdev);
}
function mixture(dists, weights) {
  let m2 = 0, w2;
  function normalize2(x5) {
    const w3 = [];
    let sum2 = 0, i;
    for (i = 0; i < m2; ++i) {
      sum2 += w3[i] = x5[i] == null ? 1 : +x5[i];
    }
    for (i = 0; i < m2; ++i) {
      w3[i] /= sum2;
    }
    return w3;
  }
  const dist2 = {
    weights(_) {
      if (arguments.length) {
        w2 = normalize2(weights = _ || []);
        return dist2;
      }
      return weights;
    },
    distributions(_) {
      if (arguments.length) {
        if (_) {
          m2 = _.length;
          dists = _;
        } else {
          m2 = 0;
          dists = [];
        }
        return dist2.weights(weights);
      }
      return dists;
    },
    sample() {
      const r = random();
      let d = dists[m2 - 1], v = w2[0], i = 0;
      for (; i < m2 - 1; v += w2[++i]) {
        if (r < v) {
          d = dists[i];
          break;
        }
      }
      return d.sample();
    },
    pdf(x5) {
      let p = 0, i = 0;
      for (; i < m2; ++i) {
        p += w2[i] * dists[i].pdf(x5);
      }
      return p;
    },
    cdf(x5) {
      let p = 0, i = 0;
      for (; i < m2; ++i) {
        p += w2[i] * dists[i].cdf(x5);
      }
      return p;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return dist2.distributions(dists).weights(weights);
}
function sampleUniform(min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return min4 + (max4 - min4) * random();
}
function densityUniform(value3, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return value3 >= min4 && value3 <= max4 ? 1 / (max4 - min4) : 0;
}
function cumulativeUniform(value3, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return value3 < min4 ? 0 : value3 > max4 ? 1 : (value3 - min4) / (max4 - min4);
}
function quantileUniform(p, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return p >= 0 && p <= 1 ? min4 + p * (max4 - min4) : NaN;
}
function uniform(min4, max4) {
  let a2, b2;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a2 = _ || 0;
        return dist2;
      } else {
        return a2;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ == null ? 1 : _;
        return dist2;
      } else {
        return b2;
      }
    },
    sample: () => sampleUniform(a2, b2),
    pdf: (value3) => densityUniform(value3, a2, b2),
    cdf: (value3) => cumulativeUniform(value3, a2, b2),
    icdf: (p) => quantileUniform(p, a2, b2)
  };
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return dist2.min(min4).max(max4);
}
function ols(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function points(data3, x5, y5, sort2) {
  data3 = data3.filter((d2) => {
    let u = x5(d2), v = y5(d2);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });
  if (sort2) {
    data3.sort((a2, b2) => x5(a2) - x5(b2));
  }
  const n = data3.length, X3 = new Float64Array(n), Y3 = new Float64Array(n);
  let i = 0, ux = 0, uy = 0, xv, yv, d;
  for (d of data3) {
    X3[i] = xv = +x5(d);
    Y3[i] = yv = +y5(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (i = 0; i < n; ++i) {
    X3[i] -= ux;
    Y3[i] -= uy;
  }
  return [X3, Y3, ux, uy];
}
function visitPoints(data3, x5, y5, callback) {
  let i = -1, u, v;
  for (const d of data3) {
    u = x5(d);
    v = y5(d);
    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}
function rSquared(data3, x5, y5, uY, predict) {
  let SSE = 0, SST = 0;
  visitPoints(data3, x5, y5, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function linear(data3, x5, y5) {
  let X3 = 0, Y3 = 0, XY = 0, X23 = 0, n = 0;
  visitPoints(data3, x5, y5, (dx, dy) => {
    ++n;
    X3 += (dx - X3) / n;
    Y3 += (dy - Y3) / n;
    XY += (dx * dy - XY) / n;
    X23 += (dx * dx - X23) / n;
  });
  const coef = ols(X3, Y3, XY, X23), predict = (x6) => coef[0] + coef[1] * x6;
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x5, y5, Y3, predict)
  };
}
function log2(data3, x5, y5) {
  let X3 = 0, Y3 = 0, XY = 0, X23 = 0, n = 0;
  visitPoints(data3, x5, y5, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X3 += (dx - X3) / n;
    Y3 += (dy - Y3) / n;
    XY += (dx * dy - XY) / n;
    X23 += (dx * dx - X23) / n;
  });
  const coef = ols(X3, Y3, XY, X23), predict = (x6) => coef[0] + coef[1] * Math.log(x6);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x5, y5, Y3, predict)
  };
}
function exp2(data3, x5, y5) {
  const [xv, yv, ux, uy] = points(data3, x5, y5);
  let YL = 0, XY = 0, XYL = 0, X2Y = 0, n = 0, dx, ly2, xy;
  visitPoints(data3, x5, y5, (_, dy) => {
    dx = xv[n++];
    ly2 = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly2 - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly2 - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });
  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy), predict = (x6) => Math.exp(c0 + c1 * (x6 - ux));
  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict,
    rSquared: rSquared(data3, x5, y5, uy, predict)
  };
}
function pow2(data3, x5, y5) {
  let X3 = 0, Y3 = 0, XY = 0, X23 = 0, YS = 0, n = 0;
  visitPoints(data3, x5, y5, (dx, dy) => {
    const lx2 = Math.log(dx), ly2 = Math.log(dy);
    ++n;
    X3 += (lx2 - X3) / n;
    Y3 += (ly2 - Y3) / n;
    XY += (lx2 * ly2 - XY) / n;
    X23 += (lx2 * lx2 - X23) / n;
    YS += (dy - YS) / n;
  });
  const coef = ols(X3, Y3, XY, X23), predict = (x6) => coef[0] * Math.pow(x6, coef[1]);
  coef[0] = Math.exp(coef[0]);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x5, y5, YS, predict)
  };
}
function quad(data3, x5, y5) {
  const [xv, yv, ux, uy] = points(data3, x5, y5), n = xv.length;
  let X23 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
  for (i = 0; i < n; ) {
    dx = xv[i];
    dy = yv[i++];
    x22 = dx * dx;
    X23 += (x22 - X23) / i;
    X3 += (x22 * dx - X3) / i;
    X4 += (x22 * x22 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x22 * dy - X2Y) / i;
  }
  const X2X2 = X4 - X23 * X23, d = X23 * X2X2 - X3 * X3, a2 = (X2Y * X23 - XY * X3) / d, b2 = (XY * X2X2 - X2Y * X3) / d, c2 = -a2 * X23, predict = (x6) => {
    x6 = x6 - ux;
    return a2 * x6 * x6 + b2 * x6 + c2 + uy;
  };
  return {
    coef: [c2 - b2 * ux + a2 * ux * ux + uy, b2 - 2 * a2 * ux, a2],
    predict,
    rSquared: rSquared(data3, x5, y5, uy, predict)
  };
}
function poly(data3, x5, y5, order) {
  if (order === 1)
    return linear(data3, x5, y5);
  if (order === 2)
    return quad(data3, x5, y5);
  const [xv, yv, ux, uy] = points(data3, x5, y5), n = xv.length, lhs = [], rhs = [], k = order + 1;
  let i, j, l, v, c2;
  for (i = 0; i < k; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }
    lhs.push(v);
    c2 = new Float64Array(k);
    for (j = 0; j < k; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }
      c2[j] = v;
    }
    rhs.push(c2);
  }
  rhs.push(lhs);
  const coef = gaussianElimination(rhs), predict = (x6) => {
    x6 -= ux;
    let y6 = uy + coef[0] + coef[1] * x6 + coef[2] * x6 * x6;
    for (i = 3; i < k; ++i)
      y6 += coef[i] * Math.pow(x6, i);
    return y6;
  };
  return {
    coef: uncenter(k, coef, -ux, uy),
    predict,
    rSquared: rSquared(data3, x5, y5, uy, predict)
  };
}
function uncenter(k, a2, x5, y5) {
  const z = Array(k);
  let i, j, v, c2;
  for (i = 0; i < k; ++i)
    z[i] = 0;
  for (i = k - 1; i >= 0; --i) {
    v = a2[i];
    c2 = 1;
    z[i] += v;
    for (j = 1; j <= i; ++j) {
      c2 *= (i + 1 - j) / j;
      z[i - j] += v * Math.pow(x5, j) * c2;
    }
  }
  z[0] += y5;
  return z;
}
function gaussianElimination(matrix) {
  const n = matrix.length - 1, coef = [];
  let i, j, k, r, t;
  for (i = 0; i < n; ++i) {
    r = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }
    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r];
      matrix[k][r] = t;
    }
    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t = 0;
    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}
var maxiters = 2;
var epsilon = 1e-12;
function loess(data3, x5, y5, bandwidth2) {
  const [xv, yv, ux, uy] = points(data3, x5, y5, true), n = xv.length, bw = Math.max(2, ~~(bandwidth2 * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
  for (let iter = -1; ++iter <= maxiters; ) {
    const interval3 = [0, bw - 1];
    for (let i = 0; i < n; ++i) {
      const dx = xv[i], i0 = interval3[0], i1 = interval3[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0, X3 = 0, Y3 = 0, XY = 0, X23 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1);
      for (let k = i0; k <= i1; ++k) {
        const xk = xv[k], yk = yv[k], w2 = tricube(Math.abs(dx - xk) * denom) * robustWeights[k], xkw = xk * w2;
        W += w2;
        X3 += xkw;
        Y3 += yk * w2;
        XY += yk * xkw;
        X23 += xk * xkw;
      }
      const [a2, b2] = ols(X3 / W, Y3 / W, XY / W, X23 / W);
      yhat[i] = a2 + b2 * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval3);
    }
    if (iter === maxiters) {
      break;
    }
    const medianResidual = median_default(residuals);
    if (Math.abs(medianResidual) < epsilon)
      break;
    for (let i = 0, arg, w2; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual);
      robustWeights[i] = arg >= 1 ? epsilon : (w2 = 1 - arg * arg) * w2;
    }
  }
  return output(xv, yhat, ux, uy);
}
function tricube(x5) {
  return (x5 = 1 - x5 * x5 * x5) * x5 * x5;
}
function updateInterval(xv, i, interval3) {
  const val = xv[i];
  let left = interval3[0], right = interval3[1] + 1;
  if (right >= xv.length)
    return;
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval3[0] = ++left;
    interval3[1] = right;
    ++right;
  }
}
function output(xv, yhat, ux, uy) {
  const n = xv.length, out = [];
  let i = 0, cnt = 0, prev = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
var MIN_RADIANS = 0.1 * Math.PI / 180;
function sampleCurve(f, extent2, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point7 = (x5) => [x5, f(x5)], minX = extent2[0], maxX = extent2[1], span2 = maxX - minX, stop2 = span2 / maxSteps, prev = [point7(minX)], next = [];
  if (minSteps === maxSteps) {
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point7(minX + i / minSteps * span2));
    }
    prev.push(point7(maxX));
    return prev;
  } else {
    next.push(point7(maxX));
    for (let i = minSteps; --i > 0; ) {
      next.push(point7(minX + i / minSteps * span2));
    }
  }
  let p02 = prev[0], p1 = next[next.length - 1];
  while (p1) {
    const pm = point7((p02[0] + p1[0]) / 2);
    if (pm[0] - p02[0] >= stop2 && angleDelta(p02, pm, p1) > MIN_RADIANS) {
      next.push(pm);
    } else {
      p02 = p1;
      prev.push(p1);
      next.pop();
    }
    p1 = next[next.length - 1];
  }
  return prev;
}
function angleDelta(p, q, r) {
  const a0 = Math.atan2(r[1] - p[1], r[0] - p[0]), a1 = Math.atan2(q[1] - p[1], q[0] - p[0]);
  return Math.abs(a0 - a1);
}

// node_modules/vega-transforms/build/vega-transforms.module.js
function multikey(f) {
  return (x5) => {
    const n = f.length;
    let i = 1, k = String(f[0](x5));
    for (; i < n; ++i) {
      k += "|" + f[i](x5);
    }
    return k;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function() {
    return "";
  } : fields.length === 1 ? fields[0] : multikey(fields);
}
function measureName(op, field3, as) {
  return as || op + (!field3 ? "" : "_" + field3);
}
var noop = () => {
};
var base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
var AggregateOps = {
  values: {
    init: (m2) => m2.cell.store = true,
    value: (m2) => m2.cell.data.values(),
    idx: -1
  },
  count: {
    value: (m2) => m2.cell.num
  },
  __count__: {
    value: (m2) => m2.missing + m2.valid
  },
  missing: {
    value: (m2) => m2.missing
  },
  valid: {
    value: (m2) => m2.valid
  },
  sum: {
    init: (m2) => m2.sum = 0,
    value: (m2) => m2.sum,
    add: (m2, v) => m2.sum += +v,
    rem: (m2, v) => m2.sum -= v
  },
  product: {
    init: (m2) => m2.product = 1,
    value: (m2) => m2.valid ? m2.product : void 0,
    add: (m2, v) => m2.product *= v,
    rem: (m2, v) => m2.product /= v
  },
  mean: {
    init: (m2) => m2.mean = 0,
    value: (m2) => m2.valid ? m2.mean : void 0,
    add: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean += m2.mean_d / m2.valid),
    rem: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean -= m2.valid ? m2.mean_d / m2.valid : m2.mean)
  },
  average: {
    value: (m2) => m2.valid ? m2.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (m2) => m2.dev = 0,
    value: (m2) => m2.valid > 1 ? m2.dev / (m2.valid - 1) : void 0,
    add: (m2, v) => m2.dev += m2.mean_d * (v - m2.mean),
    rem: (m2, v) => m2.dev -= m2.mean_d * (v - m2.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (m2) => m2.valid > 1 ? m2.dev / m2.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / m2.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid * (m2.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (m2) => m2.cell.data.distinct(m2.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (m2) => m2.cell.data.ci0(m2.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (m2) => m2.cell.data.ci1(m2.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (m2) => m2.cell.data.q2(m2.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (m2) => m2.cell.data.q1(m2.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (m2) => m2.cell.data.q3(m2.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (m2) => m2.min = void 0,
    value: (m2) => m2.min = Number.isNaN(m2.min) ? m2.cell.data.min(m2.get) : m2.min,
    add: (m2, v) => {
      if (v < m2.min || m2.min === void 0)
        m2.min = v;
    },
    rem: (m2, v) => {
      if (v <= m2.min)
        m2.min = NaN;
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (m2) => m2.max = void 0,
    value: (m2) => m2.max = Number.isNaN(m2.max) ? m2.cell.data.max(m2.get) : m2.max,
    add: (m2, v) => {
      if (v > m2.max || m2.max === void 0)
        m2.max = v;
    },
    rem: (m2, v) => {
      if (v >= m2.max)
        m2.max = NaN;
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (m2) => m2.argmin = void 0,
    value: (m2) => m2.argmin || m2.cell.data.argmin(m2.get),
    add: (m2, v, t) => {
      if (v < m2.min)
        m2.argmin = t;
    },
    rem: (m2, v) => {
      if (v <= m2.min)
        m2.argmin = void 0;
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (m2) => m2.argmax = void 0,
    value: (m2) => m2.argmax || m2.cell.data.argmax(m2.get),
    add: (m2, v, t) => {
      if (v > m2.max)
        m2.argmax = t;
    },
    rem: (m2, v) => {
      if (v >= m2.max)
        m2.argmax = void 0;
    },
    req: ["max", "values"],
    idx: 3
  }
};
var ValidAggregateOps = Object.keys(AggregateOps);
function measure(key2, value3) {
  return (out) => extend({
    name: key2,
    out: out || key2
  }, base_op, value3);
}
ValidAggregateOps.forEach((key2) => {
  AggregateOps[key2] = measure(key2, AggregateOps[key2]);
});
function createMeasure(op, name2) {
  return AggregateOps[op](name2);
}
function compareIndex(a2, b2) {
  return a2.idx - b2.idx;
}
function resolve(agg) {
  const map3 = {};
  agg.forEach((a2) => map3[a2.name] = a2);
  const getreqs = (a2) => {
    if (!a2.req)
      return;
    a2.req.forEach((key2) => {
      if (!map3[key2])
        getreqs(map3[key2] = AggregateOps[key2]());
    });
  };
  agg.forEach(getreqs);
  return Object.values(map3).sort(compareIndex);
}
function init() {
  this.valid = 0;
  this.missing = 0;
  this._ops.forEach((op) => op.init(this));
}
function add2(v, t) {
  if (v == null || v === "") {
    ++this.missing;
    return;
  }
  if (v !== v)
    return;
  ++this.valid;
  this._ops.forEach((op) => op.add(this, v, t));
}
function rem(v, t) {
  if (v == null || v === "") {
    --this.missing;
    return;
  }
  if (v !== v)
    return;
  --this.valid;
  this._ops.forEach((op) => op.rem(this, v, t));
}
function set(t) {
  this._out.forEach((op) => t[op.out] = op.value(this));
  return t;
}
function compileMeasures(agg, field3) {
  const get6 = field3 || identity, ops2 = resolve(agg), out = agg.slice().sort(compareIndex);
  function ctr(cell2) {
    this._ops = ops2;
    this._out = out;
    this.cell = cell2;
    this.init();
  }
  ctr.prototype.init = init;
  ctr.prototype.add = add2;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set;
  ctr.prototype.get = get6;
  ctr.fields = agg.map((op) => op.out);
  return ctr;
}
function TupleStore(key2) {
  this._key = key2 ? field(key2) : tupleid;
  this.reset();
}
var prototype$1 = TupleStore.prototype;
prototype$1.reset = function() {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};
prototype$1.add = function(v) {
  this._add.push(v);
};
prototype$1.rem = function(v) {
  this._rem.push(v);
};
prototype$1.values = function() {
  this._get = null;
  if (this._rem.length === 0)
    return this._add;
  const a2 = this._add, r = this._rem, k = this._key, n = a2.length, m2 = r.length, x5 = Array(n - m2), map3 = {};
  let i, j, v;
  for (i = 0; i < m2; ++i) {
    map3[k(r[i])] = 1;
  }
  for (i = 0, j = 0; i < n; ++i) {
    if (map3[k(v = a2[i])]) {
      map3[k(v)] = 0;
    } else {
      x5[j++] = v;
    }
  }
  this._rem = [];
  return this._add = x5;
};
prototype$1.distinct = function(get6) {
  const v = this.values(), map3 = {};
  let n = v.length, count2 = 0, s;
  while (--n >= 0) {
    s = get6(v[n]) + "";
    if (!has(map3, s)) {
      map3[s] = 1;
      ++count2;
    }
  }
  return count2;
};
prototype$1.extent = function(get6) {
  if (this._get !== get6 || !this._ext) {
    const v = this.values(), i = extentIndex(v, get6);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get6;
  }
  return this._ext;
};
prototype$1.argmin = function(get6) {
  return this.extent(get6)[0] || {};
};
prototype$1.argmax = function(get6) {
  return this.extent(get6)[1] || {};
};
prototype$1.min = function(get6) {
  const m2 = this.extent(get6)[0];
  return m2 != null ? get6(m2) : void 0;
};
prototype$1.max = function(get6) {
  const m2 = this.extent(get6)[1];
  return m2 != null ? get6(m2) : void 0;
};
prototype$1.quartile = function(get6) {
  if (this._get !== get6 || !this._q) {
    this._q = quartiles(this.values(), get6);
    this._get = get6;
  }
  return this._q;
};
prototype$1.q1 = function(get6) {
  return this.quartile(get6)[0];
};
prototype$1.q2 = function(get6) {
  return this.quartile(get6)[1];
};
prototype$1.q3 = function(get6) {
  return this.quartile(get6)[2];
};
prototype$1.ci = function(get6) {
  if (this._get !== get6 || !this._ci) {
    this._ci = bootstrapCI(this.values(), 1e3, 0.05, get6);
    this._get = get6;
  }
  return this._ci;
};
prototype$1.ci0 = function(get6) {
  return this.ci(get6)[0];
};
prototype$1.ci1 = function(get6) {
  return this.ci(get6)[1];
};
function Aggregate(params2) {
  Transform.call(this, null, params2);
  this._adds = [];
  this._mods = [];
  this._alen = 0;
  this._mlen = 0;
  this._drop = true;
  this._cross = false;
  this._dims = [];
  this._dnames = [];
  this._measures = [];
  this._countOnly = false;
  this._counts = null;
  this._prev = null;
  this._inputs = null;
  this._outputs = null;
}
Aggregate.Definition = {
  "type": "Aggregate",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "drop",
    "type": "boolean",
    "default": true
  }, {
    "name": "cross",
    "type": "boolean",
    "default": false
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(Aggregate, Transform, {
  transform(_, pulse2) {
    const aggr = this, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), mod = _.modified();
    aggr.stamp = out.stamp;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
      pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
    }
    out.modifies(aggr._outputs);
    aggr._drop = _.drop !== false;
    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }
    if (pulse2.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }
    return aggr.changes(out);
  },
  cross() {
    const aggr = this, curr = aggr.value, dims = aggr._dnames, vals = dims.map(() => ({})), n = dims.length;
    function collect2(cells) {
      let key2, i, t, v;
      for (key2 in cells) {
        t = cells[key2].tuple;
        for (i = 0; i < n; ++i) {
          vals[i][v = t[dims[i]]] = v;
        }
      }
    }
    collect2(aggr._prev);
    collect2(curr);
    function generate2(base2, tuple, index3) {
      const name2 = dims[index3], v = vals[index3++];
      for (const k in v) {
        const key2 = base2 ? base2 + "|" + k : k;
        tuple[name2] = v[k];
        if (index3 < n)
          generate2(key2, tuple, index3);
        else if (!curr[key2])
          aggr.cell(key2, tuple);
      }
    }
    generate2("", {}, 0);
  },
  init(_) {
    const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
    function inputVisit(get6) {
      const fields2 = array(accessorFields(get6)), n2 = fields2.length;
      let i2 = 0, f;
      for (; i2 < n2; ++i2) {
        if (!inputMap[f = fields2[i2]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    }
    this._dims = array(_.groupby);
    this._dnames = this._dims.map((d) => {
      const dname = accessorName(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims);
    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null], ops2 = _.ops || ["count"], as = _.as || [], n = fields.length, map3 = {};
    let field3, op, m2, mname, outname, i;
    if (n !== ops2.length) {
      error("Unmatched number of fields and aggregate ops.");
    }
    for (i = 0; i < n; ++i) {
      field3 = fields[i];
      op = ops2[i];
      if (field3 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      mname = accessorName(field3);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);
      if (op === "count") {
        this._counts.push(outname);
        continue;
      }
      m2 = map3[mname];
      if (!m2) {
        inputVisit(field3);
        m2 = map3[mname] = [];
        m2.field = field3;
        this._measures.push(m2);
      }
      if (op !== "count")
        this._countOnly = false;
      m2.push(createMeasure(op, outname));
    }
    this._measures = this._measures.map((m3) => compileMeasures(m3, m3.field));
    return {};
  },
  cellkey: groupkey(),
  cell(key2, t) {
    let cell2 = this.value[key2];
    if (!cell2) {
      cell2 = this.value[key2] = this.newcell(key2, t);
      this._adds[this._alen++] = cell2;
    } else if (cell2.num === 0 && this._drop && cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._adds[this._alen++] = cell2;
    } else if (cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._mods[this._mlen++] = cell2;
    }
    return cell2;
  },
  newcell(key2, t) {
    const cell2 = {
      key: key2,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[key2]),
      stamp: this.stamp,
      store: false
    };
    if (!this._countOnly) {
      const measures = this._measures, n = measures.length;
      cell2.agg = Array(n);
      for (let i = 0; i < n; ++i) {
        cell2.agg[i] = new measures[i](cell2);
      }
    }
    if (cell2.store) {
      cell2.data = new TupleStore();
    }
    return cell2;
  },
  newtuple(t, p) {
    const names = this._dnames, dims = this._dims, n = dims.length, x5 = {};
    for (let i = 0; i < n; ++i) {
      x5[names[i]] = dims[i](t);
    }
    return p ? replace(p.tuple, x5) : ingest$1(x5);
  },
  clean() {
    const cells = this.value;
    for (const key2 in cells) {
      if (cells[key2].num === 0) {
        delete cells[key2];
      }
    }
  },
  add(t) {
    const key2 = this.cellkey(t), cell2 = this.cell(key2, t);
    cell2.num += 1;
    if (this._countOnly)
      return;
    if (cell2.store)
      cell2.data.add(t);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t), t);
    }
  },
  rem(t) {
    const key2 = this.cellkey(t), cell2 = this.cell(key2, t);
    cell2.num -= 1;
    if (this._countOnly)
      return;
    if (cell2.store)
      cell2.data.rem(t);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t), t);
    }
  },
  celltuple(cell2) {
    const tuple = cell2.tuple, counts = this._counts;
    if (cell2.store) {
      cell2.data.values();
    }
    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell2.num;
    }
    if (!this._countOnly) {
      const agg = cell2.agg;
      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }
    return tuple;
  },
  changes(out) {
    const adds = this._adds, mods = this._mods, prev = this._prev, drop = this._drop, add5 = out.add, rem2 = out.rem, mod = out.mod;
    let cell2, key2, i, n;
    if (prev)
      for (key2 in prev) {
        cell2 = prev[key2];
        if (!drop || cell2.num)
          rem2.push(cell2.tuple);
      }
    for (i = 0, n = this._alen; i < n; ++i) {
      add5.push(this.celltuple(adds[i]));
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      cell2 = mods[i];
      (cell2.num === 0 && drop ? rem2 : mod).push(this.celltuple(cell2));
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
    this._prev = null;
    return out;
  }
});
var EPSILON$1 = 1e-14;
function Bin(params2) {
  Transform.call(this, null, params2);
}
Bin.Definition = {
  "type": "Bin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "anchor",
    "type": "number"
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 20
  }, {
    "name": "base",
    "type": "number",
    "default": 10
  }, {
    "name": "divide",
    "type": "number",
    "array": true,
    "default": [5, 2]
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "span",
    "type": "number"
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "steps",
    "type": "number",
    "array": true
  }, {
    "name": "minstep",
    "type": "number",
    "default": 0
  }, {
    "name": "nice",
    "type": "boolean",
    "default": true
  }, {
    "name": "name",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["bin0", "bin1"]
  }]
};
inherits(Bin, Transform, {
  transform(_, pulse2) {
    const band2 = _.interval !== false, bins = this._bins(_), start = bins.start, step = bins.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
    let flag2;
    if (_.modified()) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
    } else {
      flag2 = pulse2.modified(accessorFields(_.field)) ? pulse2.ADD_MOD : pulse2.ADD;
    }
    pulse2.visit(flag2, band2 ? (t) => {
      const v = bins(t);
      t[b0] = v;
      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : (t) => t[b0] = bins(t));
    return pulse2.modifies(band2 ? as : b0);
  },
  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }
    const field3 = _.field, bins = bin2(_), step = bins.step;
    let start = bins.start, stop2 = start + Math.ceil((bins.stop - start) / step) * step, a2, d;
    if ((a2 = _.anchor) != null) {
      d = a2 - (start + step * Math.floor((a2 - start) / step));
      start += d;
      stop2 += d;
    }
    const f = function(t) {
      let v = toNumber(field3(t));
      return v == null ? null : v < start ? -Infinity : v > stop2 ? Infinity : (v = Math.max(start, Math.min(v, stop2 - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
    };
    f.start = start;
    f.stop = bins.stop;
    f.step = step;
    return this.value = accessor(f, accessorFields(field3), _.name || "bin_" + accessorName(field3));
  }
});
function SortedList(idFunc, source3, input) {
  const $2 = idFunc;
  let data3 = source3 || [], add5 = input || [], rem2 = {}, cnt = 0;
  return {
    add: (t) => add5.push(t),
    remove: (t) => rem2[$2(t)] = ++cnt,
    size: () => data3.length,
    data: (compare3, resort) => {
      if (cnt) {
        data3 = data3.filter((t) => !rem2[$2(t)]);
        rem2 = {};
        cnt = 0;
      }
      if (resort && compare3) {
        data3.sort(compare3);
      }
      if (add5.length) {
        data3 = compare3 ? merge(compare3, data3, add5.sort(compare3)) : data3.concat(add5);
        add5 = [];
      }
      return data3;
    }
  };
}
function Collect(params2) {
  Transform.call(this, [], params2);
}
Collect.Definition = {
  "type": "Collect",
  "metadata": {
    "source": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }]
};
inherits(Collect, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), list = SortedList(tupleid, this.value, out.materialize(out.ADD).add), sort2 = _.sort, mod = pulse2.changed() || sort2 && (_.modified("sort") || pulse2.modified(sort2.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data(stableCompare(sort2), mod);
    if (pulse2.source && pulse2.source.root) {
      this.value.root = pulse2.source.root;
    }
    return out;
  }
});
function Compare(params2) {
  Operator.call(this, null, update$5, params2);
}
inherits(Compare, Operator);
function update$5(_) {
  return this.value && !_.modified() ? this.value : compare(_.fields, _.orders);
}
function CountPattern(params2) {
  Transform.call(this, null, params2);
}
CountPattern.Definition = {
  "type": "CountPattern",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "case",
    "type": "enum",
    "values": ["upper", "lower", "mixed"],
    "default": "mixed"
  }, {
    "name": "pattern",
    "type": "string",
    "default": '[\\w"]+'
  }, {
    "name": "stopwords",
    "type": "string",
    "default": ""
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["text", "count"]
  }]
};
function tokenize(text2, tcase, match2) {
  switch (tcase) {
    case "upper":
      text2 = text2.toUpperCase();
      break;
    case "lower":
      text2 = text2.toLowerCase();
      break;
  }
  return text2.match(match2);
}
inherits(CountPattern, Transform, {
  transform(_, pulse2) {
    const process = (update3) => (tuple) => {
      var tokens = tokenize(get6(tuple), _.case, match2) || [], t;
      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop2.test(t = tokens[i]))
          update3(t);
      }
    };
    const init2 = this._parameterCheck(_, pulse2), counts = this._counts, match2 = this._match, stop2 = this._stop, get6 = _.field, as = _.as || ["text", "count"], add5 = process((t) => counts[t] = 1 + (counts[t] || 0)), rem2 = process((t) => counts[t] -= 1);
    if (init2) {
      pulse2.visit(pulse2.SOURCE, add5);
    } else {
      pulse2.visit(pulse2.ADD, add5);
      pulse2.visit(pulse2.REM, rem2);
    }
    return this._finish(pulse2, as);
  },
  _parameterCheck(_, pulse2) {
    let init2 = false;
    if (_.modified("stopwords") || !this._stop) {
      this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i");
      init2 = true;
    }
    if (_.modified("pattern") || !this._match) {
      this._match = new RegExp(_.pattern || "[\\w']+", "g");
      init2 = true;
    }
    if (_.modified("field") || pulse2.modified(_.field.fields)) {
      init2 = true;
    }
    if (init2)
      this._counts = {};
    return init2;
  },
  _finish(pulse2, as) {
    const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text2 = as[0], count2 = as[1], out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    let w2, t, c2;
    for (w2 in counts) {
      t = tuples[w2];
      c2 = counts[w2] || 0;
      if (!t && c2) {
        tuples[w2] = t = ingest$1({});
        t[text2] = w2;
        t[count2] = c2;
        out.add.push(t);
      } else if (c2 === 0) {
        if (t)
          out.rem.push(t);
        counts[w2] = null;
        tuples[w2] = null;
      } else if (t[count2] !== c2) {
        t[count2] = c2;
        out.mod.push(t);
      }
    }
    return out.modifies(as);
  }
});
function Cross(params2) {
  Transform.call(this, null, params2);
}
Cross.Definition = {
  "type": "Cross",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "filter",
    "type": "expr"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["a", "b"]
  }]
};
inherits(Cross, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), as = _.as || ["a", "b"], a2 = as[0], b2 = as[1], reset2 = !this.value || pulse2.changed(pulse2.ADD_REM) || _.modified("as") || _.modified("filter");
    let data3 = this.value;
    if (reset2) {
      if (data3)
        out.rem = data3;
      data3 = pulse2.materialize(pulse2.SOURCE).source;
      out.add = this.value = cross(data3, a2, b2, _.filter || truthy);
    } else {
      out.mod = data3;
    }
    out.source = this.value;
    return out.modifies(as);
  }
});
function cross(input, a2, b2, filter3) {
  var data3 = [], t = {}, n = input.length, i = 0, j, left;
  for (; i < n; ++i) {
    t[a2] = left = input[i];
    for (j = 0; j < n; ++j) {
      t[b2] = input[j];
      if (filter3(t)) {
        data3.push(ingest$1(t));
        t = {};
        t[a2] = left;
      }
    }
  }
  return data3;
}
var Distributions = {
  kde,
  mixture,
  normal: gaussian,
  lognormal,
  uniform
};
var DISTRIBUTIONS = "distributions";
var FUNCTION = "function";
var FIELD = "field";
function parse3(def2, data3) {
  const func = def2[FUNCTION];
  if (!has(Distributions, func)) {
    error("Unknown distribution function: " + func);
  }
  const d = Distributions[func]();
  for (const name2 in def2) {
    if (name2 === FIELD) {
      d.data((def2.from || data3()).map(def2[name2]));
    } else if (name2 === DISTRIBUTIONS) {
      d[name2](def2[name2].map((_) => parse3(_, data3)));
    } else if (typeof d[name2] === FUNCTION) {
      d[name2](def2[name2]);
    }
  }
  return d;
}
function Density(params2) {
  Transform.call(this, null, params2);
}
var distributions = [{
  "key": {
    "function": "normal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "lognormal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "uniform"
  },
  "params": [{
    "name": "min",
    "type": "number",
    "default": 0
  }, {
    "name": "max",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "kde"
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "from",
    "type": "data"
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }]
}];
var mixture2 = {
  "key": {
    "function": "mixture"
  },
  "params": [{
    "name": "distributions",
    "type": "param",
    "array": true,
    "params": distributions
  }, {
    "name": "weights",
    "type": "number",
    "array": true
  }]
};
Density.Definition = {
  "type": "Density",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "method",
    "type": "string",
    "default": "pdf",
    "values": ["pdf", "cdf"]
  }, {
    "name": "distribution",
    "type": "param",
    "params": distributions.concat(mixture2)
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits(Density, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const dist2 = parse3(_.distribution, source(pulse2)), minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      let method2 = _.method || "pdf";
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (!_.extent && !dist2.data) {
        error("Missing density extent parameter.");
      }
      method2 = dist2[method2];
      const as = _.as || ["value", "density"], domain2 = _.extent || extent(dist2.data()), values2 = sampleCurve(method2, domain2, minsteps, maxsteps).map((v) => {
        const tuple = {};
        tuple[as[0]] = v[0];
        tuple[as[1]] = v[1];
        return ingest$1(tuple);
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
function source(pulse2) {
  return () => pulse2.materialize(pulse2.SOURCE).source;
}
function fieldNames(fields, as) {
  if (!fields)
    return null;
  return fields.map((f, i) => as[i] || accessorName(f));
}
function partition$1(data3, groupby, field3) {
  const groups = [], get6 = (f) => f(t);
  let map3, i, n, t, k, g;
  if (groupby == null) {
    groups.push(data3.map(field3));
  } else {
    for (map3 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k = groupby.map(get6);
      g = map3[k];
      if (!g) {
        map3[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(field3(t));
    }
  }
  return groups;
}
var Output = "bin";
function DotBin(params2) {
  Transform.call(this, null, params2);
}
DotBin.Definition = {
  "type": "DotBin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": Output
  }]
};
var autostep = (data3, field3) => span(extent(data3, field3)) / 30;
inherits(DotBin, Transform, {
  transform(_, pulse2) {
    if (this.value && !(_.modified() || pulse2.changed())) {
      return pulse2;
    }
    const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(pulse2.source, _.groupby, identity), smooth = _.smooth || false, field3 = _.field, step = _.step || autostep(source3, field3), sort2 = stableCompare((a2, b2) => field3(a2) - field3(b2)), as = _.as || Output, n = groups.length;
    let min4 = Infinity, max4 = -Infinity, i = 0, j;
    for (; i < n; ++i) {
      const g = groups[i].sort(sort2);
      j = -1;
      for (const v of dotbin(g, step, smooth, field3)) {
        if (v < min4)
          min4 = v;
        if (v > max4)
          max4 = v;
        g[++j][as] = v;
      }
    }
    this.value = {
      start: min4,
      stop: max4,
      step
    };
    return pulse2.reflow(true).modifies(as);
  }
});
function Expression(params2) {
  Operator.call(this, null, update$4, params2);
  this.modified(true);
}
inherits(Expression, Operator);
function update$4(_) {
  const expr2 = _.expr;
  return this.value && !_.modified("expr") ? this.value : accessor((datum2) => expr2(datum2, _), accessorFields(expr2), accessorName(expr2));
}
function Extent(params2) {
  Transform.call(this, [void 0, void 0], params2);
}
Extent.Definition = {
  "type": "Extent",
  "metadata": {},
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }]
};
inherits(Extent, Transform, {
  transform(_, pulse2) {
    const extent2 = this.value, field3 = _.field, mod = pulse2.changed() || pulse2.modified(field3.fields) || _.modified("field");
    let min4 = extent2[0], max4 = extent2[1];
    if (mod || min4 == null) {
      min4 = Infinity;
      max4 = -Infinity;
    }
    pulse2.visit(mod ? pulse2.SOURCE : pulse2.ADD, (t) => {
      const v = toNumber(field3(t));
      if (v != null) {
        if (v < min4)
          min4 = v;
        if (v > max4)
          max4 = v;
      }
    });
    if (!Number.isFinite(min4) || !Number.isFinite(max4)) {
      let name2 = accessorName(field3);
      if (name2)
        name2 = ` for field "${name2}"`;
      pulse2.dataflow.warn(`Infinite extent${name2}: [${min4}, ${max4}]`);
      min4 = max4 = void 0;
    }
    this.value = [min4, max4];
  }
});
function Subflow(pulse2, parent) {
  Operator.call(this, pulse2);
  this.parent = parent;
  this.count = 0;
}
inherits(Subflow, Operator, {
  connect(target2) {
    this.detachSubflow = target2.detachSubflow;
    this.targets().add(target2);
    return target2.source = this;
  },
  add(t) {
    this.count += 1;
    this.value.add.push(t);
  },
  rem(t) {
    this.count -= 1;
    this.value.rem.push(t);
  },
  mod(t) {
    this.value.mod.push(t);
  },
  init(pulse2) {
    this.value.init(pulse2, pulse2.NO_SOURCE);
  },
  evaluate() {
    return this.value;
  }
});
function Facet(params2) {
  Transform.call(this, {}, params2);
  this._keys = fastmap();
  const a2 = this._targets = [];
  a2.active = 0;
  a2.forEach = (f) => {
    for (let i = 0, n = a2.active; i < n; ++i) {
      f(a2[i], i, a2);
    }
  };
}
inherits(Facet, Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },
  subflow(key2, flow, pulse2, parent) {
    const flows = this.value;
    let sf = has(flows, key2) && flows[key2], df, p;
    if (!sf) {
      p = parent || (p = this._group[key2]) && p.tuple;
      df = pulse2.dataflow;
      sf = new Subflow(pulse2.fork(pulse2.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key2, p));
      flows[key2] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse2.stamp) {
      sf.init(pulse2);
      this.activate(sf);
    }
    return sf;
  },
  clean() {
    const flows = this.value;
    let detached = 0;
    for (const key2 in flows) {
      if (flows[key2].count === 0) {
        const detach = flows[key2].detachSubflow;
        if (detach)
          detach();
        delete flows[key2];
        ++detached;
      }
    }
    if (detached) {
      const active = this._targets.filter((sf) => sf && sf.count > 0);
      this.initTargets(active);
    }
  },
  initTargets(act) {
    const a2 = this._targets, n = a2.length, m2 = act ? act.length : 0;
    let i = 0;
    for (; i < m2; ++i) {
      a2[i] = act[i];
    }
    for (; i < n && a2[i] != null; ++i) {
      a2[i] = null;
    }
    a2.active = m2;
  },
  transform(_, pulse2) {
    const df = pulse2.dataflow, key2 = _.key, flow = _.subflow, cache2 = this._keys, rekey = _.modified("key"), subflow = (key3) => this.subflow(key3, flow, pulse2);
    this._group = _.group || {};
    this.initTargets();
    pulse2.visit(pulse2.REM, (t) => {
      const id2 = tupleid(t), k = cache2.get(id2);
      if (k !== void 0) {
        cache2.delete(id2);
        subflow(k).rem(t);
      }
    });
    pulse2.visit(pulse2.ADD, (t) => {
      const k = key2(t);
      cache2.set(tupleid(t), k);
      subflow(k).add(t);
    });
    if (rekey || pulse2.modified(key2.fields)) {
      pulse2.visit(pulse2.MOD, (t) => {
        const id2 = tupleid(t), k0 = cache2.get(id2), k1 = key2(t);
        if (k0 === k1) {
          subflow(k1).mod(t);
        } else {
          cache2.set(id2, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t) => {
        subflow(cache2.get(tupleid(t))).mod(t);
      });
    }
    if (rekey) {
      pulse2.visit(pulse2.REFLOW, (t) => {
        const id2 = tupleid(t), k0 = cache2.get(id2), k1 = key2(t);
        if (k0 !== k1) {
          cache2.set(id2, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    }
    if (pulse2.clean()) {
      df.runAfter(() => {
        this.clean();
        cache2.clean();
      });
    } else if (cache2.empty > df.cleanThreshold) {
      df.runAfter(cache2.clean);
    }
    return pulse2;
  }
});
function Field(params2) {
  Operator.call(this, null, update$3, params2);
}
inherits(Field, Operator);
function update$3(_) {
  return this.value && !_.modified() ? this.value : isArray(_.name) ? array(_.name).map((f) => field(f)) : field(_.name, _.as);
}
function Filter(params2) {
  Transform.call(this, fastmap(), params2);
}
Filter.Definition = {
  "type": "Filter",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }]
};
inherits(Filter, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, cache2 = this.value, output3 = pulse2.fork(), add5 = output3.add, rem2 = output3.rem, mod = output3.mod, test2 = _.expr;
    let isMod = true;
    pulse2.visit(pulse2.REM, (t) => {
      const id2 = tupleid(t);
      if (!cache2.has(id2))
        rem2.push(t);
      else
        cache2.delete(id2);
    });
    pulse2.visit(pulse2.ADD, (t) => {
      if (test2(t, _))
        add5.push(t);
      else
        cache2.set(tupleid(t), 1);
    });
    function revisit(t) {
      const id2 = tupleid(t), b2 = test2(t, _), s = cache2.get(id2);
      if (b2 && s) {
        cache2.delete(id2);
        add5.push(t);
      } else if (!b2 && !s) {
        cache2.set(id2, 1);
        rem2.push(t);
      } else if (isMod && b2 && !s) {
        mod.push(t);
      }
    }
    pulse2.visit(pulse2.MOD, revisit);
    if (_.modified()) {
      isMod = false;
      pulse2.visit(pulse2.REFLOW, revisit);
    }
    if (cache2.empty > df.cleanThreshold)
      df.runAfter(cache2.clean);
    return output3;
  }
});
function Flatten(params2) {
  Transform.call(this, [], params2);
}
Flatten.Definition = {
  "type": "Flatten",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "index",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Flatten, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index3 = _.index || null, m2 = as.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t) => {
      const arrays = fields.map((f) => f(t)), maxlen = arrays.reduce((l, a2) => Math.max(l, a2.length), 0);
      let i = 0, j, d, v;
      for (; i < maxlen; ++i) {
        d = derive(t);
        for (j = 0; j < m2; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }
        if (index3) {
          d[index3] = i;
        }
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index3)
      out.modifies(index3);
    return out.modifies(as);
  }
});
function Fold(params2) {
  Transform.call(this, [], params2);
}
Fold.Definition = {
  "type": "Fold",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["key", "value"]
  }]
};
inherits(Fold, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, fnames = fields.map(accessorName), as = _.as || ["key", "value"], k = as[0], v = as[1], n = fields.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t) => {
      for (let i = 0, d; i < n; ++i) {
        d = derive(t);
        d[k] = fnames[i];
        d[v] = fields[i](t);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }
});
function Formula(params2) {
  Transform.call(this, null, params2);
}
Formula.Definition = {
  "type": "Formula",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "required": true
  }, {
    "name": "initonly",
    "type": "boolean"
  }]
};
inherits(Formula, Transform, {
  transform(_, pulse2) {
    const func = _.expr, as = _.as, mod = _.modified(), flag2 = _.initonly ? pulse2.ADD : mod ? pulse2.SOURCE : pulse2.modified(func.fields) || pulse2.modified(as) ? pulse2.ADD_MOD : pulse2.ADD;
    if (mod) {
      pulse2 = pulse2.materialize().reflow(true);
    }
    if (!_.initonly) {
      pulse2.modifies(as);
    }
    return pulse2.visit(flag2, (t) => t[as] = func(t, _));
  }
});
function Generate(params2) {
  Transform.call(this, [], params2);
}
inherits(Generate, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), gen = _.generator;
    let data3 = this.value, num = _.size - data3.length, add5, rem2, t;
    if (num > 0) {
      for (add5 = []; --num >= 0; ) {
        add5.push(t = ingest$1(gen(_)));
        data3.push(t);
      }
      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add5) : add5;
    } else {
      rem2 = data3.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem2) : rem2;
      data3 = data3.slice(-num);
    }
    out.source = this.value = data3;
    return out;
  }
});
var Methods = {
  value: "value",
  median: median_default,
  mean,
  min,
  max
};
var Empty = [];
function Impute(params2) {
  Transform.call(this, [], params2);
}
Impute.Definition = {
  "type": "Impute",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "keyvals",
    "array": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "enum",
    "default": "value",
    "values": ["value", "mean", "median", "max", "min"]
  }, {
    "name": "value",
    "default": 0
  }]
};
function getValue(_) {
  var m2 = _.method || Methods.value, v;
  if (Methods[m2] == null) {
    error("Unrecognized imputation method: " + m2);
  } else if (m2 === Methods.value) {
    v = _.value !== void 0 ? _.value : 0;
    return () => v;
  } else {
    return Methods[m2];
  }
}
function getField(_) {
  const f = _.field;
  return (t) => t ? f(t) : NaN;
}
inherits(Impute, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), impute = getValue(_), field3 = getField(_), fName = accessorName(_.field), kName = accessorName(_.key), gNames = (_.groupby || []).map(accessorName), groups = partition(pulse2.source, _.groupby, _.key, _.keyvals), curr = [], prev = this.value, m2 = groups.domain.length, group2, value3, gVals, kVal, g, i, j, l, n, t;
    for (g = 0, l = groups.length; g < l; ++g) {
      group2 = groups[g];
      gVals = group2.values;
      value3 = NaN;
      for (j = 0; j < m2; ++j) {
        if (group2[j] != null)
          continue;
        kVal = groups.domain[j];
        t = {
          _impute: true
        };
        for (i = 0, n = gVals.length; i < n; ++i)
          t[gNames[i]] = gVals[i];
        t[kName] = kVal;
        t[fName] = Number.isNaN(value3) ? value3 = impute(group2, field3) : value3;
        curr.push(ingest$1(t));
      }
    }
    if (curr.length)
      out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length)
      out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }
});
function partition(data3, groupby, key2, keyvals) {
  var get6 = (f) => f(t), groups = [], domain2 = keyvals ? keyvals.slice() : [], kMap = {}, gMap = {}, gVals, gKey, group2, i, j, k, n, t;
  domain2.forEach((k2, i2) => kMap[k2] = i2 + 1);
  for (i = 0, n = data3.length; i < n; ++i) {
    t = data3[i];
    k = key2(t);
    j = kMap[k] || (kMap[k] = domain2.push(k));
    gKey = (gVals = groupby ? groupby.map(get6) : Empty) + "";
    if (!(group2 = gMap[gKey])) {
      group2 = gMap[gKey] = [];
      groups.push(group2);
      group2.values = gVals;
    }
    group2[j - 1] = t;
  }
  groups.domain = domain2;
  return groups;
}
function JoinAggregate(params2) {
  Aggregate.call(this, params2);
}
JoinAggregate.Definition = {
  "type": "JoinAggregate",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(JoinAggregate, Aggregate, {
  transform(_, pulse2) {
    const aggr = this, mod = _.modified();
    let cells;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
      pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
    }
    aggr.changes();
    pulse2.visit(pulse2.SOURCE, (t) => {
      extend(t, cells[aggr.cellkey(t)].tuple);
    });
    return pulse2.reflow(mod).modifies(this._outputs);
  },
  changes() {
    const adds = this._adds, mods = this._mods;
    let i, n;
    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
  }
});
function KDE(params2) {
  Transform.call(this, null, params2);
}
KDE.Definition = {
  "type": "KDE",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "cumulative",
    "type": "boolean",
    "default": false
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits(KDE, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(source3, _.groupby, _.field), names = (_.groupby || []).map(accessorName), bandwidth2 = _.bandwidth, method2 = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values2 = [];
      let domain2 = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (_.resolve === "shared") {
        if (!domain2)
          domain2 = extent(source3, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }
      groups.forEach((g) => {
        const density = kde(g, bandwidth2)[method2], scale6 = _.counts ? g.length : 1, local = domain2 || extent(g);
        sampleCurve(density, local, minsteps, maxsteps).forEach((v) => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = v[0];
          t[as[1]] = v[1] * scale6;
          values2.push(ingest$1(t));
        });
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
function Key(params2) {
  Operator.call(this, null, update$2, params2);
}
inherits(Key, Operator);
function update$2(_) {
  return this.value && !_.modified() ? this.value : key(_.fields, _.flat);
}
function Load(params2) {
  Transform.call(this, [], params2);
  this._pending = null;
}
inherits(Load, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow;
    if (this._pending) {
      return output2(this, pulse2, this._pending);
    }
    if (stop(_))
      return pulse2.StopPropagation;
    if (_.values) {
      return output2(this, pulse2, df.parse(_.values, _.format));
    } else if (_.async) {
      const p = df.request(_.url, _.format).then((res) => {
        this._pending = array(res.data);
        return (df2) => df2.touch(this);
      });
      return {
        async: p
      };
    } else {
      return df.request(_.url, _.format).then((res) => output2(this, pulse2, array(res.data)));
    }
  }
});
function stop(_) {
  return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
}
function output2(op, pulse2, data3) {
  data3.forEach(ingest$1);
  const out = pulse2.fork(pulse2.NO_FIELDS & pulse2.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data3;
  op._pending = null;
  if (out.rem.length)
    out.clean(true);
  return out;
}
function Lookup(params2) {
  Transform.call(this, {}, params2);
}
Lookup.Definition = {
  "type": "Lookup",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "index",
    "type": "index",
    "params": [{
      "name": "from",
      "type": "data",
      "required": true
    }, {
      "name": "key",
      "type": "field",
      "required": true
    }]
  }, {
    "name": "values",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }, {
    "name": "default",
    "default": null
  }]
};
inherits(Lookup, Transform, {
  transform(_, pulse2) {
    const keys3 = _.fields, index3 = _.index, values2 = _.values, defaultValue = _.default == null ? null : _.default, reset2 = _.modified(), n = keys3.length;
    let flag2 = reset2 ? pulse2.SOURCE : pulse2.ADD, out = pulse2, as = _.as, set5, m2, mods;
    if (values2) {
      m2 = values2.length;
      if (n > 1 && !as) {
        error('Multi-field lookup requires explicit "as" parameter.');
      }
      if (as && as.length !== n * m2) {
        error('The "as" parameter has too few output field names.');
      }
      as = as || values2.map(accessorName);
      set5 = function(t) {
        for (var i = 0, k = 0, j, v; i < n; ++i) {
          v = index3.get(keys3[i](t));
          if (v == null)
            for (j = 0; j < m2; ++j, ++k)
              t[as[k]] = defaultValue;
          else
            for (j = 0; j < m2; ++j, ++k)
              t[as[k]] = values2[j](v);
        }
      };
    } else {
      if (!as) {
        error("Missing output field names.");
      }
      set5 = function(t) {
        for (var i = 0, v; i < n; ++i) {
          v = index3.get(keys3[i](t));
          t[as[i]] = v == null ? defaultValue : v;
        }
      };
    }
    if (reset2) {
      out = pulse2.reflow(true);
    } else {
      mods = keys3.some((k) => pulse2.modified(k.fields));
      flag2 |= mods ? pulse2.MOD : 0;
    }
    pulse2.visit(flag2, set5);
    return out.modifies(as);
  }
});
function MultiExtent(params2) {
  Operator.call(this, null, update$1, params2);
}
inherits(MultiExtent, Operator);
function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }
  const ext = _.extents, n = ext.length;
  let min4 = Infinity, max4 = -Infinity, i, e;
  for (i = 0; i < n; ++i) {
    e = ext[i];
    if (e[0] < min4)
      min4 = e[0];
    if (e[1] > max4)
      max4 = e[1];
  }
  return [min4, max4];
}
function MultiValues(params2) {
  Operator.call(this, null, update2, params2);
}
inherits(MultiValues, Operator);
function update2(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data3, _2) => data3.concat(_2), []);
}
function Params(params2) {
  Transform.call(this, null, params2);
}
inherits(Params, Transform, {
  transform(_, pulse2) {
    this.modified(_.modified());
    this.value = _;
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function Pivot(params2) {
  Aggregate.call(this, params2);
}
Pivot.Definition = {
  "type": "Pivot",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "value",
    "type": "field",
    "required": true
  }, {
    "name": "op",
    "type": "enum",
    "values": ValidAggregateOps,
    "default": "sum"
  }, {
    "name": "limit",
    "type": "number",
    "default": 0
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,
  transform(_, pulse2) {
    return this._transform(aggregateParams(_, pulse2), pulse2);
  }
});
function aggregateParams(_, pulse2) {
  const key2 = _.field, value3 = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = accessorFields(key2).concat(accessorFields(value3)), keys3 = pivotKeys(key2, _.limit || 0, pulse2);
  if (pulse2.changed())
    _.set("__pivot__", null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys3.map(() => op),
    fields: keys3.map((k) => get(k, key2, value3, fields)),
    as: keys3.map((k) => k + ""),
    modified: _.modified.bind(_)
  };
}
function get(k, key2, value3, fields) {
  return accessor((d) => key2(d) === k ? value3(d) : NaN, fields, k + "");
}
function pivotKeys(key2, limit, pulse2) {
  const map3 = {}, list = [];
  pulse2.visit(pulse2.SOURCE, (t) => {
    const k = key2(t);
    if (!map3[k]) {
      map3[k] = 1;
      list.push(k);
    }
  });
  list.sort(ascending);
  return limit ? list.slice(0, limit) : list;
}
function PreFacet(params2) {
  Facet.call(this, params2);
}
inherits(PreFacet, Facet, {
  transform(_, pulse2) {
    const flow = _.subflow, field3 = _.field, subflow = (t) => this.subflow(tupleid(t), flow, pulse2, t);
    if (_.modified("field") || field3 && pulse2.modified(accessorFields(field3))) {
      error("PreFacet does not support field modification.");
    }
    this.initTargets();
    if (field3) {
      pulse2.visit(pulse2.MOD, (t) => {
        const sf = subflow(t);
        field3(t).forEach((_2) => sf.mod(_2));
      });
      pulse2.visit(pulse2.ADD, (t) => {
        const sf = subflow(t);
        field3(t).forEach((_2) => sf.add(ingest$1(_2)));
      });
      pulse2.visit(pulse2.REM, (t) => {
        const sf = subflow(t);
        field3(t).forEach((_2) => sf.rem(_2));
      });
    } else {
      pulse2.visit(pulse2.MOD, (t) => subflow(t).mod(t));
      pulse2.visit(pulse2.ADD, (t) => subflow(t).add(t));
      pulse2.visit(pulse2.REM, (t) => subflow(t).rem(t));
    }
    if (pulse2.clean()) {
      pulse2.runAfter(() => this.clean());
    }
    return pulse2;
  }
});
function Project(params2) {
  Transform.call(this, null, params2);
}
Project.Definition = {
  "type": "Project",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }]
};
inherits(Project, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive2 = fields ? (s, t) => project(s, t, fields, as) : rederive;
    let lut;
    if (this.value) {
      lut = this.value;
    } else {
      pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    pulse2.visit(pulse2.REM, (t) => {
      const id2 = tupleid(t);
      out.rem.push(lut[id2]);
      lut[id2] = null;
    });
    pulse2.visit(pulse2.ADD, (t) => {
      const dt = derive2(t, ingest$1({}));
      lut[tupleid(t)] = dt;
      out.add.push(dt);
    });
    pulse2.visit(pulse2.MOD, (t) => {
      out.mod.push(derive2(t, lut[tupleid(t)]));
    });
    return out;
  }
});
function project(s, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s);
  }
  return t;
}
function Proxy(params2) {
  Transform.call(this, null, params2);
}
inherits(Proxy, Transform, {
  transform(_, pulse2) {
    this.value = _.value;
    return _.modified("value") ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function Quantile(params2) {
  Transform.call(this, null, params2);
}
Quantile.Definition = {
  "type": "Quantile",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "probs",
    "type": "number",
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 0.01
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["prob", "value"]
  }]
};
var EPSILON = 1e-14;
inherits(Quantile, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), as = _.as || ["prob", "value"];
    if (this.value && !_.modified() && !pulse2.changed()) {
      out.source = this.value;
      return out;
    }
    const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(source3, _.groupby, _.field), names = (_.groupby || []).map(accessorName), values2 = [], step = _.step || 0.01, p = _.probs || range_default(step / 2, 1 - EPSILON, step), n = p.length;
    groups.forEach((g) => {
      const q = quantiles(g, p);
      for (let i = 0; i < n; ++i) {
        const t = {};
        for (let i2 = 0; i2 < names.length; ++i2) {
          t[names[i2]] = g.dims[i2];
        }
        t[as[0]] = p[i];
        t[as[1]] = q[i];
        values2.push(ingest$1(t));
      }
    });
    if (this.value)
      out.rem = this.value;
    this.value = out.add = out.source = values2;
    return out;
  }
});
function Relay(params2) {
  Transform.call(this, null, params2);
}
inherits(Relay, Transform, {
  transform(_, pulse2) {
    let out, lut;
    if (this.value) {
      lut = this.value;
    } else {
      out = pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    if (_.derive) {
      out = pulse2.fork(pulse2.NO_SOURCE);
      pulse2.visit(pulse2.REM, (t) => {
        const id2 = tupleid(t);
        out.rem.push(lut[id2]);
        lut[id2] = null;
      });
      pulse2.visit(pulse2.ADD, (t) => {
        const dt = derive(t);
        lut[tupleid(t)] = dt;
        out.add.push(dt);
      });
      pulse2.visit(pulse2.MOD, (t) => {
        const dt = lut[tupleid(t)];
        for (const k in t) {
          dt[k] = t[k];
          out.modifies(k);
        }
        out.mod.push(dt);
      });
    }
    return out;
  }
});
function Sample(params2) {
  Transform.call(this, [], params2);
  this.count = 0;
}
Sample.Definition = {
  "type": "Sample",
  "metadata": {},
  "params": [{
    "name": "size",
    "type": "number",
    "default": 1e3
  }]
};
inherits(Sample, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), mod = _.modified("size"), num = _.size, map3 = this.value.reduce((m2, t) => (m2[tupleid(t)] = 1, m2), {});
    let res = this.value, cnt = this.count, cap = 0;
    function update3(t) {
      let p, idx;
      if (res.length < num) {
        res.push(t);
      } else {
        idx = ~~((cnt + 1) * random());
        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map3[tupleid(p)])
            out.rem.push(p);
          res[idx] = t;
        }
      }
      ++cnt;
    }
    if (pulse2.rem.length) {
      pulse2.visit(pulse2.REM, (t) => {
        const id2 = tupleid(t);
        if (map3[id2]) {
          map3[id2] = -1;
          out.rem.push(t);
        }
        --cnt;
      });
      res = res.filter((t) => map3[tupleid(t)] !== -1);
    }
    if ((pulse2.rem.length || mod) && res.length < num && pulse2.source) {
      cap = cnt = res.length;
      pulse2.visit(pulse2.SOURCE, (t) => {
        if (!map3[tupleid(t)])
          update3(t);
      });
      cap = -1;
    }
    if (mod && res.length > num) {
      const n = res.length - num;
      for (let i = 0; i < n; ++i) {
        map3[tupleid(res[i])] = -1;
        out.rem.push(res[i]);
      }
      res = res.slice(n);
    }
    if (pulse2.mod.length) {
      pulse2.visit(pulse2.MOD, (t) => {
        if (map3[tupleid(t)])
          out.mod.push(t);
      });
    }
    if (pulse2.add.length) {
      pulse2.visit(pulse2.ADD, update3);
    }
    if (pulse2.add.length || cap < 0) {
      out.add = res.filter((t) => !map3[tupleid(t)]);
    }
    this.count = cnt;
    this.value = out.source = res;
    return out;
  }
});
function Sequence(params2) {
  Transform.call(this, null, params2);
}
Sequence.Definition = {
  "type": "Sequence",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "start",
    "type": "number",
    "required": true
  }, {
    "name": "stop",
    "type": "number",
    "required": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "as",
    "type": "string",
    "default": "data"
  }]
};
inherits(Sequence, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified())
      return;
    const out = pulse2.materialize().fork(pulse2.MOD), as = _.as || "data";
    out.rem = this.value ? pulse2.rem.concat(this.value) : pulse2.rem;
    this.value = range_default(_.start, _.stop, _.step || 1).map((v) => {
      const t = {};
      t[as] = v;
      return ingest$1(t);
    });
    out.add = pulse2.add.concat(this.value);
    return out;
  }
});
function Sieve(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Sieve, Transform, {
  transform(_, pulse2) {
    this.value = pulse2.source;
    return pulse2.changed() ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function TimeUnit(params2) {
  Transform.call(this, null, params2);
}
var OUTPUT = ["unit0", "unit1"];
TimeUnit.Definition = {
  "type": "TimeUnit",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "units",
    "type": "enum",
    "values": TIME_UNITS,
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 40
  }, {
    "name": "extent",
    "type": "date",
    "array": true
  }, {
    "name": "timezone",
    "type": "enum",
    "default": "local",
    "values": ["local", "utc"]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": OUTPUT
  }]
};
inherits(TimeUnit, Transform, {
  transform(_, pulse2) {
    const field3 = _.field, band2 = _.interval !== false, utc = _.timezone === "utc", floor2 = this._floor(_, pulse2), offset4 = (utc ? utcInterval : timeInterval)(floor2.unit).offset, as = _.as || OUTPUT, u0 = as[0], u1 = as[1], step = floor2.step;
    let min4 = floor2.start || Infinity, max4 = floor2.stop || -Infinity, flag2 = pulse2.ADD;
    if (_.modified() || pulse2.modified(accessorFields(field3))) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
      min4 = Infinity;
      max4 = -Infinity;
    }
    pulse2.visit(flag2, (t) => {
      const v = field3(t);
      let a2, b2;
      if (v == null) {
        t[u0] = null;
        if (band2)
          t[u1] = null;
      } else {
        t[u0] = a2 = b2 = floor2(v);
        if (band2)
          t[u1] = b2 = offset4(a2, step);
        if (a2 < min4)
          min4 = a2;
        if (b2 > max4)
          max4 = b2;
      }
    });
    floor2.start = min4;
    floor2.stop = max4;
    return pulse2.modifies(band2 ? as : u0);
  },
  _floor(_, pulse2) {
    const utc = _.timezone === "utc";
    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : bin({
      extent: _.extent || extent(pulse2.materialize(pulse2.SOURCE).source, _.field),
      maxbins: _.maxbins
    });
    const tunits = timeUnits(units), prev = this.value || {}, floor2 = (utc ? utcFloor : timeFloor)(tunits, step);
    floor2.unit = peek(tunits);
    floor2.units = tunits;
    floor2.step = step;
    floor2.start = prev.start;
    floor2.stop = prev.stop;
    return this.value = floor2;
  }
});
function TupleIndex(params2) {
  Transform.call(this, fastmap(), params2);
}
inherits(TupleIndex, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, field3 = _.field, index3 = this.value, set5 = (t) => index3.set(field3(t), t);
    let mod = true;
    if (_.modified("field") || pulse2.modified(field3.fields)) {
      index3.clear();
      pulse2.visit(pulse2.SOURCE, set5);
    } else if (pulse2.changed()) {
      pulse2.visit(pulse2.REM, (t) => index3.delete(field3(t)));
      pulse2.visit(pulse2.ADD, set5);
    } else {
      mod = false;
    }
    this.modified(mod);
    if (index3.empty > df.cleanThreshold)
      df.runAfter(index3.clean);
    return pulse2.fork();
  }
});
function Values(params2) {
  Transform.call(this, null, params2);
}
inherits(Values, Transform, {
  transform(_, pulse2) {
    const run2 = !this.value || _.modified("field") || _.modified("sort") || pulse2.changed() || _.sort && pulse2.modified(_.sort.fields);
    if (run2) {
      this.value = (_.sort ? pulse2.source.slice().sort(stableCompare(_.sort)) : pulse2.source).map(_.field);
    }
  }
});
function WindowOp(op, field3, param2, as) {
  const fn = WindowOps[op](field3, param2);
  return {
    init: fn.init || zero,
    update: function(w2, t) {
      t[as] = fn.next(w2);
    }
  };
}
var WindowOps = {
  row_number: function() {
    return {
      next: (w2) => w2.index + 1
    };
  },
  rank: function() {
    let rank2;
    return {
      init: () => rank2 = 1,
      next: (w2) => {
        const i = w2.index, data3 = w2.data;
        return i && w2.compare(data3[i - 1], data3[i]) ? rank2 = i + 1 : rank2;
      }
    };
  },
  dense_rank: function() {
    let drank;
    return {
      init: () => drank = 1,
      next: (w2) => {
        const i = w2.index, d = w2.data;
        return i && w2.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function() {
    const rank2 = WindowOps.rank(), next = rank2.next;
    return {
      init: rank2.init,
      next: (w2) => (next(w2) - 1) / (w2.data.length - 1)
    };
  },
  cume_dist: function() {
    let cume;
    return {
      init: () => cume = 0,
      next: (w2) => {
        const d = w2.data, c2 = w2.compare;
        let i = w2.index;
        if (cume < i) {
          while (i + 1 < d.length && !c2(d[i], d[i + 1]))
            ++i;
          cume = i;
        }
        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function(field3, num) {
    num = +num;
    if (!(num > 0))
      error("ntile num must be greater than zero.");
    const cume = WindowOps.cume_dist(), next = cume.next;
    return {
      init: cume.init,
      next: (w2) => Math.ceil(num * next(w2))
    };
  },
  lag: function(field3, offset4) {
    offset4 = +offset4 || 1;
    return {
      next: (w2) => {
        const i = w2.index - offset4;
        return i >= 0 ? field3(w2.data[i]) : null;
      }
    };
  },
  lead: function(field3, offset4) {
    offset4 = +offset4 || 1;
    return {
      next: (w2) => {
        const i = w2.index + offset4, d = w2.data;
        return i < d.length ? field3(d[i]) : null;
      }
    };
  },
  first_value: function(field3) {
    return {
      next: (w2) => field3(w2.data[w2.i0])
    };
  },
  last_value: function(field3) {
    return {
      next: (w2) => field3(w2.data[w2.i1 - 1])
    };
  },
  nth_value: function(field3, nth) {
    nth = +nth;
    if (!(nth > 0))
      error("nth_value nth must be greater than zero.");
    return {
      next: (w2) => {
        const i = w2.i0 + (nth - 1);
        return i < w2.i1 ? field3(w2.data[i]) : null;
      }
    };
  },
  prev_value: function(field3) {
    let prev;
    return {
      init: () => prev = null,
      next: (w2) => {
        const v = field3(w2.data[w2.index]);
        return v != null ? prev = v : prev;
      }
    };
  },
  next_value: function(field3) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: (w2) => {
        const d = w2.data;
        return w2.index <= i ? v : (i = find(field3, d, w2.index)) < 0 ? (i = d.length, v = null) : v = field3(d[i]);
      }
    };
  }
};
function find(field3, data3, index3) {
  for (let n = data3.length; index3 < n; ++index3) {
    const v = field3(data3[index3]);
    if (v != null)
      return index3;
  }
  return -1;
}
var ValidWindowOps = Object.keys(WindowOps);
function WindowState(_) {
  const ops2 = array(_.ops), fields = array(_.fields), params2 = array(_.params), as = array(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map3 = {}, counts = [], measures = [];
  let countOnly = true;
  function visitInputs(f) {
    array(accessorFields(f)).forEach((_2) => inputs[_2] = 1);
  }
  visitInputs(_.sort);
  ops2.forEach((op, i) => {
    const field3 = fields[i], mname = accessorName(field3), name2 = measureName(op, mname, as[i]);
    visitInputs(field3);
    outputs.push(name2);
    if (has(WindowOps, op)) {
      windows.push(WindowOp(op, fields[i], params2[i], name2));
    } else {
      if (field3 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      if (op === "count") {
        counts.push(name2);
        return;
      }
      countOnly = false;
      let m2 = map3[mname];
      if (!m2) {
        m2 = map3[mname] = [];
        m2.field = field3;
        measures.push(m2);
      }
      m2.push(createMeasure(op, name2));
    }
  });
  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }
  this.inputs = Object.keys(inputs);
}
var prototype = WindowState.prototype;
prototype.init = function() {
  this.windows.forEach((_) => _.init());
  if (this.cell)
    this.cell.init();
};
prototype.update = function(w2, t) {
  const cell2 = this.cell, wind = this.windows, data3 = w2.data, m2 = wind && wind.length;
  let j;
  if (cell2) {
    for (j = w2.p0; j < w2.i0; ++j)
      cell2.rem(data3[j]);
    for (j = w2.p1; j < w2.i1; ++j)
      cell2.add(data3[j]);
    cell2.set(t);
  }
  for (j = 0; j < m2; ++j)
    wind[j].update(w2, t);
};
function cell(measures, counts, countOnly) {
  measures = measures.map((m2) => compileMeasures(m2, m2.field));
  const cell2 = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };
  if (!countOnly) {
    var n = measures.length, a2 = cell2.agg = Array(n), i = 0;
    for (; i < n; ++i)
      a2[i] = new measures[i](cell2);
  }
  if (cell2.store) {
    var store = cell2.data = new TupleStore();
  }
  cell2.add = function(t) {
    cell2.num += 1;
    if (countOnly)
      return;
    if (store)
      store.add(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a2[i2].add(a2[i2].get(t), t);
    }
  };
  cell2.rem = function(t) {
    cell2.num -= 1;
    if (countOnly)
      return;
    if (store)
      store.rem(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a2[i2].rem(a2[i2].get(t), t);
    }
  };
  cell2.set = function(t) {
    let i2, n2;
    if (store)
      store.values();
    for (i2 = 0, n2 = counts.length; i2 < n2; ++i2)
      t[counts[i2]] = cell2.num;
    if (!countOnly)
      for (i2 = 0, n2 = a2.length; i2 < n2; ++i2)
        a2[i2].set(t);
  };
  cell2.init = function() {
    cell2.num = 0;
    if (store)
      store.reset();
    for (let i2 = 0; i2 < n; ++i2)
      a2[i2].init();
  };
  return cell2;
}
function Window(params2) {
  Transform.call(this, {}, params2);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  "type": "Window",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidWindowOps.concat(ValidAggregateOps)
  }, {
    "name": "params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "frame",
    "type": "number",
    "null": true,
    "array": true,
    "length": 2,
    "default": [null, 0]
  }, {
    "name": "ignorePeers",
    "type": "boolean",
    "default": false
  }]
};
inherits(Window, Transform, {
  transform(_, pulse2) {
    this.stamp = pulse2.stamp;
    const mod = _.modified(), cmp = stableCompare(_.sort), key2 = groupkey(_.groupby), group2 = (t) => this.group(key2(t));
    let state = this.state;
    if (!state || mod) {
      state = this.state = new WindowState(_);
    }
    if (mod || pulse2.modified(state.inputs)) {
      this.value = {};
      pulse2.visit(pulse2.SOURCE, (t) => group2(t).add(t));
    } else {
      pulse2.visit(pulse2.REM, (t) => group2(t).remove(t));
      pulse2.visit(pulse2.ADD, (t) => group2(t).add(t));
    }
    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp, _);
    }
    this._mlen = 0;
    this._mods = [];
    return pulse2.reflow(mod).modifies(state.outputs);
  },
  group(key2) {
    let group2 = this.value[key2];
    if (!group2) {
      group2 = this.value[key2] = SortedList(tupleid);
      group2.stamp = -1;
    }
    if (group2.stamp < this.stamp) {
      group2.stamp = this.stamp;
      this._mods[this._mlen++] = group2;
    }
    return group2;
  }
});
function processPartition(list, state, cmp, _) {
  const sort2 = _.sort, range4 = sort2 && !_.ignorePeers, frame3 = _.frame || [null, 0], data3 = list.data(cmp), n = data3.length, b2 = range4 ? bisector_default(sort2) : null, w2 = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data3,
    compare: sort2 || constant(-1)
  };
  state.init();
  for (let i = 0; i < n; ++i) {
    setWindow(w2, frame3, i, n);
    if (range4)
      adjustRange(w2, b2);
    state.update(w2, data3[i]);
  }
}
function setWindow(w2, f, i, n) {
  w2.p0 = w2.i0;
  w2.p1 = w2.i1;
  w2.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w2.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w2.index = i;
}
function adjustRange(w2, bisect2) {
  const r0 = w2.i0, r1 = w2.i1 - 1, c2 = w2.compare, d = w2.data, n = d.length - 1;
  if (r0 > 0 && !c2(d[r0], d[r0 - 1]))
    w2.i0 = bisect2.left(d, d[r0]);
  if (r1 < n && !c2(d[r1], d[r1 + 1]))
    w2.i1 = bisect2.right(d, d[r1]);
}

// node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var vega_view_transforms_module_exports = {};
__export(vega_view_transforms_module_exports, {
  bound: () => Bound,
  identifier: () => Identifier,
  mark: () => Mark,
  overlap: () => Overlap,
  render: () => Render,
  viewlayout: () => ViewLayout
});

// node_modules/vega-scenegraph/node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon2 = 1e-6;
var tauEpsilon = tau - epsilon2;
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x5, y5) {
    this._ += "M" + (this._x0 = this._x1 = +x5) + "," + (this._y0 = this._y1 = +y5);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x5, y5) {
    this._ += "L" + (this._x1 = +x5) + "," + (this._y1 = +y5);
  },
  quadraticCurveTo: function(x12, y12, x5, y5) {
    this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x5) + "," + (this._y1 = +y5);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x5, y5) {
    this._ += "C" + +x12 + "," + +y12 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x5) + "," + (this._y1 = +y5);
  },
  arcTo: function(x12, y12, x22, y22, r) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
    var x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else if (!(l01_2 > epsilon2))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
      this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else {
      var x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
    }
  },
  arc: function(x5, y5, r, a0, a1, ccw) {
    x5 = +x5, y5 = +y5, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x5 + dx, y06 = y5 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x06 + "," + y06;
    } else if (Math.abs(this._x1 - x06) > epsilon2 || Math.abs(this._y1 - y06) > epsilon2) {
      this._ += "L" + x06 + "," + y06;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw2 + "," + (x5 - dx) + "," + (y5 - dy) + "A" + r + "," + r + ",0,1," + cw2 + "," + (this._x1 = x06) + "," + (this._y1 = y06);
    } else if (da > epsilon2) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw2 + "," + (this._x1 = x5 + r * Math.cos(a1)) + "," + (this._y1 = y5 + r * Math.sin(a1));
    }
  },
  rect: function(x5, y5, w2, h2) {
    this._ += "M" + (this._x0 = this._x1 = +x5) + "," + (this._y0 = this._y1 = +y5) + "h" + +w2 + "v" + +h2 + "h" + -w2 + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default = path;

// node_modules/vega-scenegraph/node_modules/d3-shape/src/constant.js
function constant_default(x5) {
  return function constant2() {
    return x5;
  };
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max2 = Math.max;
var min2 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon3 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;
function acos(x5) {
  return x5 > 1 ? 0 : x5 < -1 ? pi2 : Math.acos(x5);
}
function asin(x5) {
  return x5 >= 1 ? halfPi : x5 <= -1 ? -halfPi : Math.asin(x5);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x06, y06, x12, y12, x22, y22, x32, y32) {
  var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon3)
    return;
  t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;
  return [x06 + t * x10, y06 + t * y10];
}
function cornerTangents(x06, y06, x12, y12, r1, rc, cw2) {
  var x01 = x06 - x12, y01 = y06 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x06 + ox, y11 = y06 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max2(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context3 = null;
  function arc3() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
    if (!context3)
      context3 = buffer = path_default();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon3))
      context3.moveTo(0, 0);
    else if (da > tau2 - epsilon3) {
      context3.moveTo(r1 * cos(a0), r1 * sin(a0));
      context3.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon3) {
        context3.moveTo(r0 * cos(a1), r0 * sin(a1));
        context3.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon3 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min2(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t05, t14;
      if (rp > epsilon3) {
        var p02 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p02 * 2) > epsilon3)
          p02 *= cw2 ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon3)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon3) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi2 && (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min2(rc, (r0 - lc) / (kc - 1));
          rc1 = min2(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon3))
        context3.moveTo(x01, y01);
      else if (rc1 > epsilon3) {
        t05 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t14 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context3.moveTo(t05.cx + t05.x01, t05.cy + t05.y01);
        if (rc1 < rc)
          context3.arc(t05.cx, t05.cy, rc1, atan2(t05.y01, t05.x01), atan2(t14.y01, t14.x01), !cw2);
        else {
          context3.arc(t05.cx, t05.cy, rc1, atan2(t05.y01, t05.x01), atan2(t05.y11, t05.x11), !cw2);
          context3.arc(0, 0, r1, atan2(t05.cy + t05.y11, t05.cx + t05.x11), atan2(t14.cy + t14.y11, t14.cx + t14.x11), !cw2);
          context3.arc(t14.cx, t14.cy, rc1, atan2(t14.y11, t14.x11), atan2(t14.y01, t14.x01), !cw2);
        }
      } else
        context3.moveTo(x01, y01), context3.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon3) || !(da0 > epsilon3))
        context3.lineTo(x10, y10);
      else if (rc0 > epsilon3) {
        t05 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t14 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context3.lineTo(t05.cx + t05.x01, t05.cy + t05.y01);
        if (rc0 < rc)
          context3.arc(t05.cx, t05.cy, rc0, atan2(t05.y01, t05.x01), atan2(t14.y01, t14.x01), !cw2);
        else {
          context3.arc(t05.cx, t05.cy, rc0, atan2(t05.y01, t05.x01), atan2(t05.y11, t05.x11), !cw2);
          context3.arc(0, 0, r0, atan2(t05.cy + t05.y11, t05.cx + t05.x11), atan2(t14.cy + t14.y11, t14.cx + t14.x11), cw2);
          context3.arc(t14.cx, t14.cy, rc0, atan2(t14.y11, t14.x11), atan2(t14.y01, t14.x01), !cw2);
        }
      } else
        context3.arc(0, 0, r0, a10, a00, cw2);
    }
    context3.closePath();
    if (buffer)
      return context3 = null, buffer + "" || null;
  }
  arc3.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi2 / 2;
    return [cos(a2) * r, sin(a2) * r];
  };
  arc3.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default(+_), arc3) : innerRadius;
  };
  arc3.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default(+_), arc3) : outerRadius;
  };
  arc3.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default(+_), arc3) : cornerRadius;
  };
  arc3.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), arc3) : padRadius;
  };
  arc3.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), arc3) : startAngle;
  };
  arc3.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), arc3) : endAngle;
  };
  arc3.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), arc3) : padAngle;
  };
  arc3.context = function(_) {
    return arguments.length ? (context3 = _ == null ? null : _, arc3) : context3;
  };
  return arc3;
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x5) {
  return typeof x5 === "object" && "length" in x5 ? x5 : Array.from(x5);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linear.js
function Linear(context3) {
  this._context = context3;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x5, y5);
        break;
    }
  }
};
function linear_default(context3) {
  return new Linear(context3);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/line.js
function line_default(x5, y5) {
  var defined = constant_default(true), context3 = null, curve2 = linear_default, output3 = null;
  x5 = typeof x5 === "function" ? x5 : x5 === void 0 ? x : constant_default(x5);
  y5 = typeof y5 === "function" ? y5 : y5 === void 0 ? y : constant_default(y5);
  function line3(data3) {
    var i, n = (data3 = array_default(data3)).length, d, defined0 = false, buffer;
    if (context3 == null)
      output3 = curve2(buffer = path_default());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          output3.lineStart();
        else
          output3.lineEnd();
      }
      if (defined0)
        output3.point(+x5(d, i, data3), +y5(d, i, data3));
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  line3.x = function(_) {
    return arguments.length ? (x5 = typeof _ === "function" ? _ : constant_default(+_), line3) : x5;
  };
  line3.y = function(_) {
    return arguments.length ? (y5 = typeof _ === "function" ? _ : constant_default(+_), line3) : y5;
  };
  line3.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default(!!_), line3) : defined;
  };
  line3.curve = function(_) {
    return arguments.length ? (curve2 = _, context3 != null && (output3 = curve2(context3)), line3) : curve2;
  };
  line3.context = function(_) {
    return arguments.length ? (_ == null ? context3 = output3 = null : output3 = curve2(context3 = _), line3) : context3;
  };
  return line3;
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/area.js
function area_default(x06, y06, y12) {
  var x12 = null, defined = constant_default(true), context3 = null, curve2 = linear_default, output3 = null;
  x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x : constant_default(+x06);
  y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default(0) : constant_default(+y06);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
  function area3(data3) {
    var i, j, k, n = (data3 = array_default(data3)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context3 == null)
      output3 = curve2(buffer = path_default());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output3.areaStart();
          output3.lineStart();
        } else {
          output3.lineEnd();
          output3.lineStart();
          for (k = i - 1; k >= j; --k) {
            output3.point(x0z[k], y0z[k]);
          }
          output3.lineEnd();
          output3.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x06(d, i, data3), y0z[i] = +y06(d, i, data3);
        output3.point(x12 ? +x12(d, i, data3) : x0z[i], y12 ? +y12(d, i, data3) : y0z[i]);
      }
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve2).context(context3);
  }
  area3.x = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default(+_), x12 = null, area3) : x06;
  };
  area3.x0 = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default(+_), area3) : x06;
  };
  area3.x1 = function(_) {
    return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area3) : x12;
  };
  area3.y = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default(+_), y12 = null, area3) : y06;
  };
  area3.y0 = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default(+_), area3) : y06;
  };
  area3.y1 = function(_) {
    return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area3) : y12;
  };
  area3.lineX0 = area3.lineY0 = function() {
    return arealine().x(x06).y(y06);
  };
  area3.lineY1 = function() {
    return arealine().x(x06).y(y12);
  };
  area3.lineX1 = function() {
    return arealine().x(x12).y(y06);
  };
  area3.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default(!!_), area3) : defined;
  };
  area3.curve = function(_) {
    return arguments.length ? (curve2 = _, context3 != null && (output3 = curve2(context3)), area3) : curve2;
  };
  area3.context = function(_) {
    return arguments.length ? (_ == null ? context3 = output3 = null : output3 = curve2(context3 = _), area3) : context3;
  };
  return area3;
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/circle.js
var circle_default = {
  draw: function(context3, size) {
    var r = Math.sqrt(size / pi2);
    context3.moveTo(r, 0);
    context3.arc(0, 0, r, 0, tau2);
  }
};

// node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol.js
function symbol_default(type2, size) {
  var context3 = null;
  type2 = typeof type2 === "function" ? type2 : constant_default(type2 || circle_default);
  size = typeof size === "function" ? size : constant_default(size === void 0 ? 64 : +size);
  function symbol2() {
    var buffer;
    if (!context3)
      context3 = buffer = path_default();
    type2.apply(this, arguments).draw(context3, +size.apply(this, arguments));
    if (buffer)
      return context3 = null, buffer + "" || null;
  }
  symbol2.type = function(_) {
    return arguments.length ? (type2 = typeof _ === "function" ? _ : constant_default(_), symbol2) : type2;
  };
  symbol2.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default(+_), symbol2) : size;
  };
  symbol2.context = function(_) {
    return arguments.length ? (context3 = _ == null ? null : _, symbol2) : context3;
  };
  return symbol2;
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basis.js
function point(that, x5, y5) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x5) / 6, (that._y0 + 4 * that._y1 + y5) / 6);
}
function Basis(context3) {
  this._context = context3;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basis_default(context3) {
  return new Basis(context3);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context3) {
  this._context = context3;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x5, this._y2 = y5;
        break;
      case 1:
        this._point = 2;
        this._x3 = x5, this._y3 = y5;
        break;
      case 2:
        this._point = 3;
        this._x4 = x5, this._y4 = y5;
        this._context.moveTo((this._x0 + 4 * this._x1 + x5) / 6, (this._y0 + 4 * this._y1 + y5) / 6);
        break;
      default:
        point(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basisClosed_default(context3) {
  return new BasisClosed(context3);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context3) {
  this._context = context3;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x5) / 6, y06 = (this._y0 + 4 * this._y1 + y5) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basisOpen_default(context3) {
  return new BasisOpen(context3);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/bundle.js
function Bundle(context3, beta) {
  this._basis = new Basis(context3);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x5 = this._x, y5 = this._y, j = x5.length - 1;
    if (j > 0) {
      var x06 = x5[0], y06 = y5[0], dx = x5[j] - x06, dy = y5[j] - y06, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(this._beta * x5[i] + (1 - this._beta) * (x06 + t * dx), this._beta * y5[i] + (1 - this._beta) * (y06 + t * dy));
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x5, y5) {
    this._x.push(+x5);
    this._y.push(+y5);
  }
};
var bundle_default = function custom(beta) {
  function bundle2(context3) {
    return beta === 1 ? new Basis(context3) : new Bundle(context3, beta);
  }
  bundle2.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle2;
}(0.85);

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x5, y5) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x5), that._y2 + that._k * (that._y1 - y5), that._x2, that._y2);
}
function Cardinal(context3, tension) {
  this._context = context3;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
        this._x1 = x5, this._y1 = y5;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context3) {
    return new Cardinal(context3, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context3, tension) {
  this._context = context3;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x5, this._y3 = y5;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x5, this._y4 = y5);
        break;
      case 2:
        this._point = 3;
        this._x5 = x5, this._y5 = y5;
        break;
      default:
        point2(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context3) {
    return new CardinalClosed(context3, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context3, tension) {
  this._context = context3;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context3) {
    return new CardinalOpen(context3, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x5, y5) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon3) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon3) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x5 * that._l12_2a) / m2;
    y22 = (y22 * b2 + that._y1 * that._l23_2a - y5 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context3, alpha) {
  this._context = context3;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x5, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context3) {
    return alpha ? new CatmullRom(context3, alpha) : new Cardinal(context3, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context3, alpha) {
  this._context = context3;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x5, this._y3 = y5;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x5, this._y4 = y5);
        break;
      case 2:
        this._point = 3;
        this._x5 = x5, this._y5 = y5;
        break;
      default:
        point3(this, x5, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context3) {
    return alpha ? new CatmullRomClosed(context3, alpha) : new CardinalClosed(context3, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context3, alpha) {
  this._context = context3;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x5, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context3) {
    return alpha ? new CatmullRomOpen(context3, alpha) : new CardinalOpen(context3, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context3) {
  this._context = context3;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    if (this._point)
      this._context.lineTo(x5, y5);
    else
      this._point = 1, this._context.moveTo(x5, y5);
  }
};
function linearClosed_default(context3) {
  return new LinearClosed(context3);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/monotone.js
function sign(x5) {
  return x5 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t) / 2 : t;
}
function point4(that, t05, t14) {
  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t05, x12 - dx, y12 - dx * t14, x12, y12);
}
function MonotoneX(context3) {
  this._context = context3;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    var t14 = NaN;
    x5 = +x5, y5 = +y5;
    if (x5 === this._x1 && y5 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t14 = slope3(this, x5, y5)), t14);
        break;
      default:
        point4(this, this._t0, t14 = slope3(this, x5, y5));
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y5;
    this._t0 = t14;
  }
};
function MonotoneY(context3) {
  this._context = new ReflectContext(context3);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x5, y5) {
  MonotoneX.prototype.point.call(this, y5, x5);
};
function ReflectContext(context3) {
  this._context = context3;
}
ReflectContext.prototype = {
  moveTo: function(x5, y5) {
    this._context.moveTo(y5, x5);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x5, y5) {
    this._context.lineTo(y5, x5);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x5, y5) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y5, x5);
  }
};
function monotoneX(context3) {
  return new MonotoneX(context3);
}
function monotoneY(context3) {
  return new MonotoneY(context3);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/natural.js
function Natural(context3) {
  this._context = context3;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x5 = this._x, y5 = this._y, n = x5.length;
    if (n) {
      this._line ? this._context.lineTo(x5[0], y5[0]) : this._context.moveTo(x5[0], y5[0]);
      if (n === 2) {
        this._context.lineTo(x5[1], y5[1]);
      } else {
        var px2 = controlPoints(x5), py2 = controlPoints(y5);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px2[0][i0], py2[0][i0], px2[1][i0], py2[1][i0], x5[i1], y5[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x5, y5) {
    this._x.push(+x5);
    this._y.push(+y5);
  }
};
function controlPoints(x5) {
  var i, n = x5.length - 1, m2, a2 = new Array(n), b2 = new Array(n), r = new Array(n);
  a2[0] = 0, b2[0] = 2, r[0] = x5[0] + 2 * x5[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b2[i] = 4, r[i] = 4 * x5[i] + 2 * x5[i + 1];
  a2[n - 1] = 2, b2[n - 1] = 7, r[n - 1] = 8 * x5[n - 1] + x5[n];
  for (i = 1; i < n; ++i)
    m2 = a2[i] / b2[i - 1], b2[i] -= m2, r[i] -= m2 * r[i - 1];
  a2[n - 1] = r[n - 1] / b2[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b2[i];
  b2[n - 1] = (x5[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b2[i] = 2 * x5[i + 1] - a2[i + 1];
  return [a2, b2];
}
function natural_default(context3) {
  return new Natural(context3);
}

// node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/step.js
function Step(context3, t) {
  this._context = context3;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y5);
          this._context.lineTo(x5, y5);
        } else {
          var x12 = this._x * (1 - this._t) + x5 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y5);
        }
        break;
      }
    }
    this._x = x5, this._y = y5;
  }
};
function step_default(context3) {
  return new Step(context3, 0.5);
}
function stepBefore(context3) {
  return new Step(context3, 0);
}
function stepAfter(context3) {
  return new Step(context3, 1);
}

// node_modules/vega-canvas/src/domCanvas.js
function domCanvas(w2, h2) {
  if (typeof document !== "undefined" && document.createElement) {
    const c2 = document.createElement("canvas");
    if (c2 && c2.getContext) {
      c2.width = w2;
      c2.height = h2;
      return c2;
    }
  }
  return null;
}
var domImage = () => typeof Image !== "undefined" ? Image : null;

// node_modules/vega-scale/node_modules/d3-scale/src/init.js
function initRange(domain2, range4) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain2);
      break;
    default:
      this.range(range4).domain(domain2);
      break;
  }
  return this;
}
function initInterpolator(domain2, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain2 === "function")
        this.interpolator(domain2);
      else
        this.range(domain2);
      break;
    }
    default: {
      this.domain(domain2);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/vega-scale/node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index3 = new Map(), domain2 = [], range4 = [], unknown = implicit;
  function scale6(d) {
    var key2 = d + "", i = index3.get(key2);
    if (!i) {
      if (unknown !== implicit)
        return unknown;
      index3.set(key2, i = domain2.push(d));
    }
    return range4[(i - 1) % range4.length];
  }
  scale6.domain = function(_) {
    if (!arguments.length)
      return domain2.slice();
    domain2 = [], index3 = new Map();
    for (const value3 of _) {
      const key2 = value3 + "";
      if (index3.has(key2))
        continue;
      index3.set(key2, domain2.push(value3));
    }
    return scale6;
  };
  scale6.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), scale6) : range4.slice();
  };
  scale6.unknown = function(_) {
    return arguments.length ? (unknown = _, scale6) : unknown;
  };
  scale6.copy = function() {
    return ordinal(domain2, range4).unknown(unknown);
  };
  initRange.apply(scale6, arguments);
  return scale6;
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/index.js
var src_exports = {};
__export(src_exports, {
  interpolate: () => value_default,
  interpolateArray: () => array_default2,
  interpolateBasis: () => basis_default2,
  interpolateBasisClosed: () => basisClosed_default2,
  interpolateCubehelix: () => cubehelix_default,
  interpolateCubehelixLong: () => cubehelixLong,
  interpolateDate: () => date_default,
  interpolateDiscrete: () => discrete_default,
  interpolateHcl: () => hcl_default,
  interpolateHclLong: () => hclLong,
  interpolateHsl: () => hsl_default,
  interpolateHslLong: () => hslLong,
  interpolateHue: () => hue_default,
  interpolateLab: () => lab2,
  interpolateNumber: () => number_default2,
  interpolateNumberArray: () => numberArray_default,
  interpolateObject: () => object_default,
  interpolateRgb: () => rgb_default,
  interpolateRgbBasis: () => rgbBasis,
  interpolateRgbBasisClosed: () => rgbBasisClosed,
  interpolateRound: () => round_default,
  interpolateString: () => string_default,
  interpolateTransformCss: () => interpolateTransformCss,
  interpolateTransformSvg: () => interpolateTransformSvg,
  interpolateZoom: () => zoom_default,
  piecewise: () => piecewise,
  quantize: () => quantize_default2
});

// node_modules/vega-scale/node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend2(parent, definition3) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition3)
    prototype2[key2] = definition3[key2];
  return prototype2;
}

// node_modules/vega-scale/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format5) {
  var m2, l;
  format5 = (format5 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format5)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format5)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format5)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format5)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format5)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format5)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format5)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format5) ? rgbn(named[format5]) : format5 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b2, a2) {
  if (a2 <= 0)
    r = g = b2 = NaN;
  return new Rgb(r, g, b2, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b2, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b2, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend2(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value3) {
  value3 = Math.max(0, Math.min(255, Math.round(value3) || 0));
  return (value3 < 16 ? "0" : "") + value3.toString(16);
}
function hsla(h2, s, l, a2) {
  if (a2 <= 0)
    h2 = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s = NaN;
  else if (s <= 0)
    h2 = NaN;
  return new Hsl(h2, s, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b2 = o.b / 255, min4 = Math.min(r, g, b2), max4 = Math.max(r, g, b2), h2 = NaN, s = max4 - min4, l = (max4 + min4) / 2;
  if (s) {
    if (r === max4)
      h2 = (g - b2) / s + (g < b2) * 6;
    else if (g === max4)
      h2 = (b2 - r) / s + 2;
    else
      h2 = (r - g) / s + 4;
    s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s, l, o.opacity);
}
function hsl(h2, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend2(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb(h2, m1, m2), hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/vega-scale/node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/vega-scale/node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t03 = 4 / 29;
var t12 = 6 / 29;
var t2 = 3 * t12 * t12;
var t3 = t12 * t12 * t12;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b2 = rgb2lrgb(o.b), y5 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b2) / Yn), x5, z;
  if (r === g && g === b2)
    x5 = z = y5;
  else {
    x5 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b2) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b2) / Zn);
  }
  return new Lab(116 * y5 - 16, 500 * (x5 - y5), 200 * (y5 - z), o.opacity);
}
function lab(l, a2, b2, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b2, opacity == null ? 1 : opacity);
}
function Lab(l, a2, b2, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend2(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y5 = (this.l + 16) / 116, x5 = isNaN(this.a) ? y5 : y5 + this.a / 500, z = isNaN(this.b) ? y5 : y5 - this.b / 200;
    x5 = Xn * lab2xyz(x5);
    y5 = Yn * lab2xyz(y5);
    z = Zn * lab2xyz(z);
    return new Rgb(lrgb2rgb(3.1338561 * x5 - 1.6168667 * y5 - 0.4906146 * z), lrgb2rgb(-0.9787684 * x5 + 1.9161415 * y5 + 0.033454 * z), lrgb2rgb(0.0719453 * x5 - 0.2289914 * y5 + 1.4052427 * z), this.opacity);
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t03;
}
function lab2xyz(t) {
  return t > t12 ? t * t * t : t2 * (t - t03);
}
function lrgb2rgb(x5) {
  return 255 * (x5 <= 31308e-7 ? 12.92 * x5 : 1.055 * Math.pow(x5, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x5) {
  return (x5 /= 255) <= 0.04045 ? x5 / 12.92 : Math.pow((x5 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h2, c2, l, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c2, l, opacity == null ? 1 : opacity);
}
function Hcl(h2, c2, l, opacity) {
  this.h = +h2;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h2 = o.h * radians;
  return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend2(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/vega-scale/node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b2 = o.b / 255, l = (BC_DA * b2 + ED * r - EB * g) / (BC_DA + ED - EB), bl2 = b2 - l, k = (E * (g - l) - C * bl2) / D, s = Math.sqrt(k * k + bl2 * bl2) / (E * l * (1 - l)), h2 = s ? Math.atan2(k, bl2) * degrees - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s, l, o.opacity);
}
function cubehelix(h2, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend2(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
    return new Rgb(255 * (l + a2 * (A * cosh2 + B * sinh2)), 255 * (l + a2 * (C * cosh2 + D * sinh2)), 255 * (l + a2 * (E * cosh2)), this.opacity);
  }
}));

// node_modules/vega-scale/node_modules/d3-interpolate/src/basis.js
function basis(t14, v0, v1, v2, v3) {
  var t23 = t14 * t14, t33 = t23 * t14;
  return ((1 - 3 * t14 + 3 * t23 - t33) * v0 + (4 - 6 * t23 + 3 * t33) * v1 + (1 + 3 * t14 + 3 * t23 - 3 * t33) * v2 + t33 * v3) / 6;
}
function basis_default2(values2) {
  var n = values2.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values2) {
  var n = values2.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x5) => () => x5;

// node_modules/vega-scale/node_modules/d3-interpolate/src/color.js
function linear2(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b2, y5) {
  return a2 = Math.pow(a2, y5), b2 = Math.pow(b2, y5) - a2, y5 = 1 / y5, function(t) {
    return Math.pow(a2 + t * b2, y5);
  };
}
function hue(a2, b2) {
  var d = b2 - a2;
  return d ? linear2(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default2(isNaN(a2) ? b2 : a2);
}
function gamma(y5) {
  return (y5 = +y5) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y5) : constant_default2(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d = b2 - a2;
  return d ? linear2(a2, d) : constant_default2(isNaN(a2) ? b2 : a2);
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y5) {
  var color7 = gamma(y5);
  function rgb5(start, end) {
    var r = color7((start = rgb(start)).r, (end = rgb(end)).r), g = color7(start.g, end.g), b2 = color7(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b2(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb5.gamma = rgbGamma;
  return rgb5;
}(1);
function rgbSpline(spline) {
  return function(colors2) {
    var n = colors2.length, r = new Array(n), g = new Array(n), b2 = new Array(n), i, color7;
    for (i = 0; i < n; ++i) {
      color7 = rgb(colors2[i]);
      r[i] = color7.r || 0;
      g[i] = color7.g || 0;
      b2[i] = color7.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b2 = spline(b2);
    color7.opacity = 1;
    return function(t) {
      color7.r = r(t);
      color7.g = g(t);
      color7.b = b2(t);
      return color7 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/vega-scale/node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b2) {
  if (!b2)
    b2 = [];
  var n = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a2[i] * (1 - t) + b2[i] * t;
    return c2;
  };
}
function isNumberArray(x5) {
  return ArrayBuffer.isView(x5) && !(x5 instanceof DataView);
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/array.js
function array_default2(a2, b2) {
  return (isNumberArray(b2) ? numberArray_default : genericArray)(a2, b2);
}
function genericArray(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x5 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x5[i] = value_default(a2[i], b2[i]);
  for (; i < nb; ++i)
    c2[i] = b2[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x5[i](t);
    return c2;
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/date.js
function date_default(a2, b2) {
  var d = new Date();
  return a2 = +a2, b2 = +b2, function(t) {
    return d.setTime(a2 * (1 - t) + b2 * t), d;
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/number.js
function number_default2(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t) {
    return a2 * (1 - t) + b2 * t;
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/object.js
function object_default(a2, b2) {
  var i = {}, c2 = {}, k;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b2 === null || typeof b2 !== "object")
    b2 = {};
  for (k in b2) {
    if (k in a2) {
      i[k] = value_default(a2[k], b2[k]);
    } else {
      c2[k] = b2[k];
    }
  }
  return function(t) {
    for (k in i)
      c2[k] = i[k](t);
    return c2;
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b2) {
  return function() {
    return b2;
  };
}
function one2(b2) {
  return function(t) {
    return b2(t) + "";
  };
}
function string_default(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default2(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one2(q[0].x) : zero2(b2) : (b2 = q.length, function(t) {
    for (var i2 = 0, o; i2 < b2; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/value.js
function value_default(a2, b2) {
  var t = typeof b2, c2;
  return b2 == null || t === "boolean" ? constant_default2(b2) : (t === "number" ? number_default2 : t === "string" ? (c2 = color(b2)) ? (b2 = c2, rgb_default) : string_default : b2 instanceof color ? rgb_default : b2 instanceof Date ? date_default : isNumberArray(b2) ? numberArray_default : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default : number_default2)(a2, b2);
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/discrete.js
function discrete_default(range4) {
  var n = range4.length;
  return function(t) {
    return range4[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/hue.js
function hue_default(a2, b2) {
  var i = hue(+a2, +b2);
  return function(t) {
    var x5 = i(t);
    return x5 - 360 * Math.floor(x5 / 360);
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/round.js
function round_default(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t) {
    return Math.round(a2 * (1 - t) + b2 * t);
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a2, b2, c2, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b2 * b2))
    a2 /= scaleX, b2 /= scaleX;
  if (skewX = a2 * c2 + b2 * d)
    c2 -= a2 * skewX, d -= b2 * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b2 * c2)
    a2 = -a2, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b2, a2) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value3) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value3 + "");
  return m2.isIdentity ? identity2 : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value3) {
  if (value3 == null)
    return identity2;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value3);
  if (!(value3 = svgNode.transform.baseVal.consolidate()))
    return identity2;
  value3 = value3.matrix;
  return decompose_default(value3.a, value3.b, value3.c, value3.d, value3.e, value3.f);
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse6, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate3(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate2(a2, b2, s, q) {
    if (a2 !== b2) {
      if (a2 - b2 > 180)
        b2 += 360;
      else if (b2 - a2 > 180)
        a2 += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default2(a2, b2) });
    } else if (b2) {
      s.push(pop(s) + "rotate(" + b2 + degParen);
    }
  }
  function skewX(a2, b2, s, q) {
    if (a2 !== b2) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default2(a2, b2) });
    } else if (b2) {
      s.push(pop(s) + "skewX(" + b2 + degParen);
    }
  }
  function scale6(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b2) {
    var s = [], q = [];
    a2 = parse6(a2), b2 = parse6(b2);
    translate3(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s, q);
    rotate2(a2.rotate, b2.rotate, s, q);
    skewX(a2.skewX, b2.skewX, s, q);
    scale6(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s, q);
    a2 = b2 = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/vega-scale/node_modules/d3-interpolate/src/zoom.js
var epsilon22 = 1e-12;
function cosh(x5) {
  return ((x5 = Math.exp(x5)) + 1 / x5) / 2;
}
function sinh(x5) {
  return ((x5 = Math.exp(x5)) - 1 / x5) / 2;
}
function tanh(x5) {
  return ((x5 = Math.exp(2 * x5)) - 1) / (x5 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom2(p02, p1) {
    var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon22) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);

// node_modules/vega-scale/node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h2 = hue2((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h2(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/vega-scale/node_modules/d3-interpolate/src/lab.js
function lab2(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l), a2 = nogamma(start.a, end.a), b2 = nogamma(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a2(t);
    start.b = b2(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h2 = hue2((start = hcl(start)).h, (end = hcl(end)).h), c2 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h2(t);
      start.c = c2(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/vega-scale/node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y5) {
    y5 = +y5;
    function cubehelix3(start, end) {
      var h2 = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h2(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y5));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/vega-scale/node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate2, values2) {
  if (values2 === void 0)
    values2 = interpolate2, interpolate2 = value_default;
  var i = 0, n = values2.length - 1, v = values2[0], I = new Array(n < 0 ? 0 : n);
  while (i < n)
    I[i] = interpolate2(v, v = values2[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}

// node_modules/vega-scale/node_modules/d3-interpolate/src/quantize.js
function quantize_default2(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}

// node_modules/vega-scale/node_modules/d3-scale/src/constant.js
function constants(x5) {
  return function() {
    return x5;
  };
}

// node_modules/vega-scale/node_modules/d3-scale/src/number.js
function number(x5) {
  return +x5;
}

// node_modules/vega-scale/node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x5) {
  return x5;
}
function normalize(a2, b2) {
  return (b2 -= a2 = +a2) ? function(x5) {
    return (x5 - a2) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a2, b2) {
  var t;
  if (a2 > b2)
    t = a2, a2 = b2, b2 = t;
  return function(x5) {
    return Math.max(a2, Math.min(b2, x5));
  };
}
function bimap(domain2, range4, interpolate2) {
  var d0 = domain2[0], d1 = domain2[1], r0 = range4[0], r1 = range4[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x5) {
    return r0(d0(x5));
  };
}
function polymap(domain2, range4, interpolate2) {
  var j = Math.min(domain2.length, range4.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain2[j] < domain2[0]) {
    domain2 = domain2.slice().reverse();
    range4 = range4.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain2[i], domain2[i + 1]);
    r[i] = interpolate2(range4[i], range4[i + 1]);
  }
  return function(x5) {
    var i2 = bisect_default2(domain2, x5, 1, j) - 1;
    return r[i2](d[i2](x5));
  };
}
function copy(source3, target2) {
  return target2.domain(source3.domain()).range(source3.range()).interpolate(source3.interpolate()).clamp(source3.clamp()).unknown(source3.unknown());
}
function transformer() {
  var domain2 = unit, range4 = unit, interpolate2 = value_default, transform4, untransform, unknown, clamp2 = identity3, piecewise2, output3, input;
  function rescale() {
    var n = Math.min(domain2.length, range4.length);
    if (clamp2 !== identity3)
      clamp2 = clamper(domain2[0], domain2[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output3 = input = null;
    return scale6;
  }
  function scale6(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : (output3 || (output3 = piecewise2(domain2.map(transform4), range4, interpolate2)))(transform4(clamp2(x5)));
  }
  scale6.invert = function(y5) {
    return clamp2(untransform((input || (input = piecewise2(range4, domain2.map(transform4), number_default2)))(y5)));
  };
  scale6.domain = function(_) {
    return arguments.length ? (domain2 = Array.from(_, number), rescale()) : domain2.slice();
  };
  scale6.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), rescale()) : range4.slice();
  };
  scale6.rangeRound = function(_) {
    return range4 = Array.from(_), interpolate2 = round_default, rescale();
  };
  scale6.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity3, rescale()) : clamp2 !== identity3;
  };
  scale6.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
  };
  scale6.unknown = function(_) {
    return arguments.length ? (unknown = _, scale6) : unknown;
  };
  return function(t, u) {
    transform4 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity3, identity3);
}

// node_modules/vega-scale/node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop2, count2, specifier) {
  var step = tickStep(start, stop2, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value3 = Math.max(Math.abs(start), Math.abs(stop2));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value3)))
        specifier.precision = precision;
      return formatPrefix(specifier, value3);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop2)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format2(specifier);
}

// node_modules/vega-scale/node_modules/d3-scale/src/linear.js
function linearish(scale6) {
  var domain2 = scale6.domain;
  scale6.ticks = function(count2) {
    var d = domain2();
    return ticks_default(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale6.tickFormat = function(count2, specifier) {
    var d = domain2();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale6.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain2();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop2 = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop2 < start) {
      step = start, start = stop2, stop2 = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop2, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop2;
        return domain2(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop2 = Math.ceil(stop2 / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop2 = Math.floor(stop2 * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale6;
  };
  return scale6;
}
function linear3() {
  var scale6 = continuous();
  scale6.copy = function() {
    return copy(scale6, linear3());
  };
  initRange.apply(scale6, arguments);
  return linearish(scale6);
}

// node_modules/vega-scale/node_modules/d3-scale/src/identity.js
function identity4(domain2) {
  var unknown;
  function scale6(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : x5;
  }
  scale6.invert = scale6;
  scale6.domain = scale6.range = function(_) {
    return arguments.length ? (domain2 = Array.from(_, number), scale6) : domain2.slice();
  };
  scale6.unknown = function(_) {
    return arguments.length ? (unknown = _, scale6) : unknown;
  };
  scale6.copy = function() {
    return identity4(domain2).unknown(unknown);
  };
  domain2 = arguments.length ? Array.from(domain2, number) : [0, 1];
  return linearish(scale6);
}

// node_modules/vega-scale/node_modules/d3-scale/src/nice.js
function nice(domain2, interval3) {
  domain2 = domain2.slice();
  var i0 = 0, i1 = domain2.length - 1, x06 = domain2[i0], x12 = domain2[i1], t;
  if (x12 < x06) {
    t = i0, i0 = i1, i1 = t;
    t = x06, x06 = x12, x12 = t;
  }
  domain2[i0] = interval3.floor(x06);
  domain2[i1] = interval3.ceil(x12);
  return domain2;
}

// node_modules/vega-scale/node_modules/d3-scale/src/log.js
function transformLog(x5) {
  return Math.log(x5);
}
function transformExp(x5) {
  return Math.exp(x5);
}
function transformLogn(x5) {
  return -Math.log(-x5);
}
function transformExpn(x5) {
  return -Math.exp(-x5);
}
function pow10(x5) {
  return isFinite(x5) ? +("1e" + x5) : x5 < 0 ? 0 : x5;
}
function powp(base2) {
  return base2 === 10 ? pow10 : base2 === Math.E ? Math.exp : function(x5) {
    return Math.pow(base2, x5);
  };
}
function logp(base2) {
  return base2 === Math.E ? Math.log : base2 === 10 && Math.log10 || base2 === 2 && Math.log2 || (base2 = Math.log(base2), function(x5) {
    return Math.log(x5) / base2;
  });
}
function reflect(f) {
  return function(x5) {
    return -f(-x5);
  };
}
function loggish(transform4) {
  var scale6 = transform4(transformLog, transformExp), domain2 = scale6.domain, base2 = 10, logs, pows;
  function rescale() {
    logs = logp(base2), pows = powp(base2);
    if (domain2()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform4(transformLogn, transformExpn);
    } else {
      transform4(transformLog, transformExp);
    }
    return scale6;
  }
  scale6.base = function(_) {
    return arguments.length ? (base2 = +_, rescale()) : base2;
  };
  scale6.domain = function(_) {
    return arguments.length ? (domain2(_), rescale()) : domain2();
  };
  scale6.ticks = function(count2) {
    var d = domain2(), u = d[0], v = d[d.length - 1], r;
    if (r = v < u)
      i = u, u = v, v = i;
    var i = logs(u), j = logs(v), p, k, t, n = count2 == null ? 10 : +count2, z = [];
    if (!(base2 % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0)
        for (; i <= j; ++i) {
          for (k = 1, p = pows(i); k < base2; ++k) {
            t = p * k;
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      else
        for (; i <= j; ++i) {
          for (k = base2 - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      if (z.length * 2 < n)
        z = ticks_default(u, v, n);
    } else {
      z = ticks_default(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale6.tickFormat = function(count2, specifier) {
    if (specifier == null)
      specifier = base2 === 10 ? ".0e" : ",";
    if (typeof specifier !== "function")
      specifier = format2(specifier);
    if (count2 === Infinity)
      return specifier;
    if (count2 == null)
      count2 = 10;
    var k = Math.max(1, base2 * count2 / scale6.ticks().length);
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base2 < base2 - 0.5)
        i *= base2;
      return i <= k ? specifier(d) : "";
    };
  };
  scale6.nice = function() {
    return domain2(nice(domain2(), {
      floor: function(x5) {
        return pows(Math.floor(logs(x5)));
      },
      ceil: function(x5) {
        return pows(Math.ceil(logs(x5)));
      }
    }));
  };
  return scale6;
}
function log3() {
  var scale6 = loggish(transformer()).domain([1, 10]);
  scale6.copy = function() {
    return copy(scale6, log3()).base(scale6.base());
  };
  initRange.apply(scale6, arguments);
  return scale6;
}

// node_modules/vega-scale/node_modules/d3-scale/src/symlog.js
function transformSymlog(c2) {
  return function(x5) {
    return Math.sign(x5) * Math.log1p(Math.abs(x5 / c2));
  };
}
function transformSymexp(c2) {
  return function(x5) {
    return Math.sign(x5) * Math.expm1(Math.abs(x5)) * c2;
  };
}
function symlogish(transform4) {
  var c2 = 1, scale6 = transform4(transformSymlog(c2), transformSymexp(c2));
  scale6.constant = function(_) {
    return arguments.length ? transform4(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
  };
  return linearish(scale6);
}
function symlog2() {
  var scale6 = symlogish(transformer());
  scale6.copy = function() {
    return copy(scale6, symlog2()).constant(scale6.constant());
  };
  return initRange.apply(scale6, arguments);
}

// node_modules/vega-scale/node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x5) {
    return x5 < 0 ? -Math.pow(-x5, exponent) : Math.pow(x5, exponent);
  };
}
function transformSqrt(x5) {
  return x5 < 0 ? -Math.sqrt(-x5) : Math.sqrt(x5);
}
function transformSquare(x5) {
  return x5 < 0 ? -x5 * x5 : x5 * x5;
}
function powish(transform4) {
  var scale6 = transform4(identity3, identity3), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform4(identity3, identity3) : exponent === 0.5 ? transform4(transformSqrt, transformSquare) : transform4(transformPow(exponent), transformPow(1 / exponent));
  }
  scale6.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale6);
}
function pow3() {
  var scale6 = powish(transformer());
  scale6.copy = function() {
    return copy(scale6, pow3()).exponent(scale6.exponent());
  };
  initRange.apply(scale6, arguments);
  return scale6;
}
function sqrt2() {
  return pow3.apply(null, arguments).exponent(0.5);
}

// node_modules/vega-scale/node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain2 = [], range4 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range4.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = quantileSorted(domain2, i / n);
    return scale6;
  }
  function scale6(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : range4[bisect_default2(thresholds, x5)];
  }
  scale6.invertExtent = function(y5) {
    var i = range4.indexOf(y5);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain2[0],
      i < thresholds.length ? thresholds[i] : domain2[domain2.length - 1]
    ];
  };
  scale6.domain = function(_) {
    if (!arguments.length)
      return domain2.slice();
    domain2 = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain2.push(d);
    domain2.sort(ascending_default);
    return rescale();
  };
  scale6.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), rescale()) : range4.slice();
  };
  scale6.unknown = function(_) {
    return arguments.length ? (unknown = _, scale6) : unknown;
  };
  scale6.quantiles = function() {
    return thresholds.slice();
  };
  scale6.copy = function() {
    return quantile2().domain(domain2).range(range4).unknown(unknown);
  };
  return initRange.apply(scale6, arguments);
}

// node_modules/vega-scale/node_modules/d3-scale/src/quantize.js
function quantize() {
  var x06 = 0, x12 = 1, n = 1, domain2 = [0.5], range4 = [0, 1], unknown;
  function scale6(x5) {
    return x5 != null && x5 <= x5 ? range4[bisect_default2(domain2, x5, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain2 = new Array(n);
    while (++i < n)
      domain2[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);
    return scale6;
  }
  scale6.domain = function(_) {
    return arguments.length ? ([x06, x12] = _, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];
  };
  scale6.range = function(_) {
    return arguments.length ? (n = (range4 = Array.from(_)).length - 1, rescale()) : range4.slice();
  };
  scale6.invertExtent = function(y5) {
    var i = range4.indexOf(y5);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain2[0]] : i >= n ? [domain2[n - 1], x12] : [domain2[i - 1], domain2[i]];
  };
  scale6.unknown = function(_) {
    return arguments.length ? (unknown = _, scale6) : scale6;
  };
  scale6.thresholds = function() {
    return domain2.slice();
  };
  scale6.copy = function() {
    return quantize().domain([x06, x12]).range(range4).unknown(unknown);
  };
  return initRange.apply(linearish(scale6), arguments);
}

// node_modules/vega-scale/node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain2 = [0.5], range4 = [0, 1], unknown, n = 1;
  function scale6(x5) {
    return x5 != null && x5 <= x5 ? range4[bisect_default2(domain2, x5, 0, n)] : unknown;
  }
  scale6.domain = function(_) {
    return arguments.length ? (domain2 = Array.from(_), n = Math.min(domain2.length, range4.length - 1), scale6) : domain2.slice();
  };
  scale6.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), n = Math.min(domain2.length, range4.length - 1), scale6) : range4.slice();
  };
  scale6.invertExtent = function(y5) {
    var i = range4.indexOf(y5);
    return [domain2[i - 1], domain2[i]];
  };
  scale6.unknown = function(_) {
    return arguments.length ? (unknown = _, scale6) : unknown;
  };
  scale6.copy = function() {
    return threshold().domain(domain2).range(range4).unknown(unknown);
  };
  return initRange.apply(scale6, arguments);
}

// node_modules/vega-scale/node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number2(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function calendar(ticks, tickInterval, year2, month2, week2, day2, hour2, minute2, second2, format5) {
  var scale6 = continuous(), invert2 = scale6.invert, domain2 = scale6.domain;
  var formatMillisecond = format5(".%L"), formatSecond = format5(":%S"), formatMinute = format5("%I:%M"), formatHour = format5("%I %p"), formatDay = format5("%a %d"), formatWeek = format5("%b %d"), formatMonth = format5("%B"), formatYear3 = format5("%Y");
  function tickFormat3(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week2(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  scale6.invert = function(y5) {
    return new Date(invert2(y5));
  };
  scale6.domain = function(_) {
    return arguments.length ? domain2(Array.from(_, number2)) : domain2().map(date);
  };
  scale6.ticks = function(interval3) {
    var d = domain2();
    return ticks(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
  };
  scale6.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat3 : format5(specifier);
  };
  scale6.nice = function(interval3) {
    var d = domain2();
    if (!interval3 || typeof interval3.range !== "function")
      interval3 = tickInterval(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
    return interval3 ? domain2(nice(d, interval3)) : scale6;
  };
  scale6.copy = function() {
    return copy(scale6, calendar(ticks, tickInterval, year2, month2, week2, day2, hour2, minute2, second2, format5));
  };
  return scale6;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/vega-scale/node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default, second_default, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/vega-scale/node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x06 = 0, x12 = 1, t05, t14, k10, transform4, interpolator = identity3, clamp2 = false, unknown;
  function scale6(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : interpolator(k10 === 0 ? 0.5 : (x5 = (transform4(x5) - t05) * k10, clamp2 ? Math.max(0, Math.min(1, x5)) : x5));
  }
  scale6.domain = function(_) {
    return arguments.length ? ([x06, x12] = _, t05 = transform4(x06 = +x06), t14 = transform4(x12 = +x12), k10 = t05 === t14 ? 0 : 1 / (t14 - t05), scale6) : [x06, x12];
  };
  scale6.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale6) : clamp2;
  };
  scale6.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale6) : interpolator;
  };
  function range4(interpolate2) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale6) : [interpolator(0), interpolator(1)];
    };
  }
  scale6.range = range4(value_default);
  scale6.rangeRound = range4(round_default);
  scale6.unknown = function(_) {
    return arguments.length ? (unknown = _, scale6) : unknown;
  };
  return function(t) {
    transform4 = t, t05 = t(x06), t14 = t(x12), k10 = t05 === t14 ? 0 : 1 / (t14 - t05);
    return scale6;
  };
}
function copy2(source3, target2) {
  return target2.domain(source3.domain()).interpolator(source3.interpolator()).clamp(source3.clamp()).unknown(source3.unknown());
}
function sequential() {
  var scale6 = linearish(transformer2()(identity3));
  scale6.copy = function() {
    return copy2(scale6, sequential());
  };
  return initInterpolator.apply(scale6, arguments);
}
function sequentialLog() {
  var scale6 = loggish(transformer2()).domain([1, 10]);
  scale6.copy = function() {
    return copy2(scale6, sequentialLog()).base(scale6.base());
  };
  return initInterpolator.apply(scale6, arguments);
}
function sequentialSymlog() {
  var scale6 = symlogish(transformer2());
  scale6.copy = function() {
    return copy2(scale6, sequentialSymlog()).constant(scale6.constant());
  };
  return initInterpolator.apply(scale6, arguments);
}
function sequentialPow() {
  var scale6 = powish(transformer2());
  scale6.copy = function() {
    return copy2(scale6, sequentialPow()).exponent(scale6.exponent());
  };
  return initInterpolator.apply(scale6, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

// node_modules/vega-scale/node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x06 = 0, x12 = 0.5, x22 = 1, s = 1, t05, t14, t23, k10, k21, interpolator = identity3, transform4, clamp2 = false, unknown;
  function scale6(x5) {
    return isNaN(x5 = +x5) ? unknown : (x5 = 0.5 + ((x5 = +transform4(x5)) - t14) * (s * x5 < s * t14 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x5)) : x5));
  }
  scale6.domain = function(_) {
    return arguments.length ? ([x06, x12, x22] = _, t05 = transform4(x06 = +x06), t14 = transform4(x12 = +x12), t23 = transform4(x22 = +x22), k10 = t05 === t14 ? 0 : 0.5 / (t14 - t05), k21 = t14 === t23 ? 0 : 0.5 / (t23 - t14), s = t14 < t05 ? -1 : 1, scale6) : [x06, x12, x22];
  };
  scale6.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale6) : clamp2;
  };
  scale6.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale6) : interpolator;
  };
  function range4(interpolate2) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale6) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale6.range = range4(value_default);
  scale6.rangeRound = range4(round_default);
  scale6.unknown = function(_) {
    return arguments.length ? (unknown = _, scale6) : unknown;
  };
  return function(t) {
    transform4 = t, t05 = t(x06), t14 = t(x12), t23 = t(x22), k10 = t05 === t14 ? 0 : 0.5 / (t14 - t05), k21 = t14 === t23 ? 0 : 0.5 / (t23 - t14), s = t14 < t05 ? -1 : 1;
    return scale6;
  };
}
function diverging() {
  var scale6 = linearish(transformer3()(identity3));
  scale6.copy = function() {
    return copy2(scale6, diverging());
  };
  return initInterpolator.apply(scale6, arguments);
}
function divergingLog() {
  var scale6 = loggish(transformer3()).domain([0.1, 1, 10]);
  scale6.copy = function() {
    return copy2(scale6, divergingLog()).base(scale6.base());
  };
  return initInterpolator.apply(scale6, arguments);
}
function divergingSymlog() {
  var scale6 = symlogish(transformer3());
  scale6.copy = function() {
    return copy2(scale6, divergingSymlog()).constant(scale6.constant());
  };
  return initInterpolator.apply(scale6, arguments);
}
function divergingPow() {
  var scale6 = powish(transformer3());
  scale6.copy = function() {
    return copy2(scale6, divergingPow()).exponent(scale6.exponent());
  };
  return initInterpolator.apply(scale6, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

// node_modules/vega-scale/build/vega-scale.module.js
function bandSpace(count2, paddingInner, paddingOuter) {
  const space = count2 - paddingInner + paddingOuter * 2;
  return count2 ? space > 0 ? space : 1 : 0;
}
var Identity = "identity";
var Linear2 = "linear";
var Log = "log";
var Pow = "pow";
var Sqrt = "sqrt";
var Symlog = "symlog";
var Time = "time";
var UTC = "utc";
var Sequential = "sequential";
var Diverging = "diverging";
var Quantile2 = "quantile";
var Quantize = "quantize";
var Threshold = "threshold";
var Ordinal = "ordinal";
var Point = "point";
var Band = "band";
var BinOrdinal = "bin-ordinal";
var Continuous = "continuous";
var Discrete = "discrete";
var Discretizing = "discretizing";
var Interpolating = "interpolating";
var Temporal = "temporal";
function invertRange(scale6) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale6.invert(lo), scale6.invert(hi)];
  };
}
function invertRangeExtent(scale6) {
  return function(_) {
    const range4 = scale6.range();
    let lo = _[0], hi = _[1], min4 = -1, max4, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range4.length; i < n; ++i) {
      if (range4[i] >= lo && range4[i] <= hi) {
        if (min4 < 0)
          min4 = i;
        max4 = i;
      }
    }
    if (min4 < 0)
      return void 0;
    lo = scale6.invertExtent(range4[min4]);
    hi = scale6.invertExtent(range4[max4]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band() {
  const scale6 = ordinal().unknown(void 0), domain2 = scale6.domain, ordinalRange = scale6.range;
  let range$1 = [0, 1], step, bandwidth2, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale6.unknown;
  function rescale() {
    const n = domain2().length, reverse2 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse2], space = bandSpace(n, paddingInner, paddingOuter);
    let start = range$1[reverse2 - 0];
    step = (stop2 - start) / (space || 1);
    if (round) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner)) * align;
    bandwidth2 = step * (1 - paddingInner);
    if (round) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values2 = range_default(n).map((i) => start + step * i);
    return ordinalRange(reverse2 ? values2.reverse() : values2);
  }
  scale6.domain = function(_) {
    if (arguments.length) {
      domain2(_);
      return rescale();
    } else {
      return domain2();
    }
  };
  scale6.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale6.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round = true;
    return rescale();
  };
  scale6.bandwidth = function() {
    return bandwidth2;
  };
  scale6.step = function() {
    return step;
  };
  scale6.round = function(_) {
    if (arguments.length) {
      round = !!_;
      return rescale();
    } else {
      return round;
    }
  };
  scale6.padding = function(_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      paddingInner = paddingOuter;
      return rescale();
    } else {
      return paddingInner;
    }
  };
  scale6.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner;
    }
  };
  scale6.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter;
    }
  };
  scale6.align = function(_) {
    if (arguments.length) {
      align = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align;
    }
  };
  scale6.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse2 = range$1[1] < range$1[0], values2 = reverse2 ? ordinalRange().reverse() : ordinalRange(), n = values2.length - 1;
    let lo = +_[0], hi = +_[1], a2, b2, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values2[0] || lo > range$1[1 - reverse2])
      return;
    a2 = Math.max(0, bisectRight(values2, lo) - 1);
    b2 = lo === hi ? a2 : bisectRight(values2, hi) - 1;
    if (lo - values2[a2] > bandwidth2 + 1e-10)
      ++a2;
    if (reverse2) {
      t = a2;
      a2 = n - b2;
      b2 = n - t;
    }
    return a2 > b2 ? void 0 : domain2().slice(a2, b2 + 1);
  };
  scale6.invert = function(_) {
    const value3 = scale6.invertRange([_, _]);
    return value3 ? value3[0] : value3;
  };
  scale6.copy = function() {
    return band().domain(domain2()).range(range$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return rescale();
}
function pointish(scale6) {
  const copy4 = scale6.copy;
  scale6.padding = scale6.paddingOuter;
  delete scale6.paddingInner;
  scale6.copy = function() {
    return pointish(copy4());
  };
  return scale6;
}
function point5() {
  return pointish(band().paddingInner(1));
}
var map2 = Array.prototype.map;
function numbers3(_) {
  return map2.call(_, toNumber);
}
var slice2 = Array.prototype.slice;
function scaleBinOrdinal() {
  let domain2 = [], range4 = [];
  function scale6(x5) {
    return x5 == null || x5 !== x5 ? void 0 : range4[(bisect_default2(domain2, x5) - 1) % range4.length];
  }
  scale6.domain = function(_) {
    if (arguments.length) {
      domain2 = numbers3(_);
      return scale6;
    } else {
      return domain2.slice();
    }
  };
  scale6.range = function(_) {
    if (arguments.length) {
      range4 = slice2.call(_);
      return scale6;
    } else {
      return range4.slice();
    }
  };
  scale6.tickFormat = function(count2, specifier) {
    return tickFormat(domain2[0], peek(domain2), count2 == null ? 10 : count2, specifier);
  };
  scale6.copy = function() {
    return scaleBinOrdinal().domain(scale6.domain()).range(scale6.range());
  };
  return scale6;
}
var scales = {};
function create(type2, constructor, metadata2) {
  const ctr = function scale6() {
    const s = constructor();
    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : void 0;
    }
    s.type = type2;
    return s;
  };
  ctr.metadata = toSet(array(metadata2));
  return ctr;
}
function scale(type2, scale6, metadata2) {
  if (arguments.length > 1) {
    scales[type2] = create(type2, scale6, metadata2);
    return this;
  } else {
    return isValidScaleType(type2) ? scales[type2] : void 0;
  }
}
scale(Identity, identity4);
scale(Linear2, linear3, Continuous);
scale(Log, log3, [Continuous, Log]);
scale(Pow, pow3, Continuous);
scale(Sqrt, sqrt2, Continuous);
scale(Symlog, symlog2, Continuous);
scale(Time, time, [Continuous, Temporal]);
scale(UTC, utcTime, [Continuous, Temporal]);
scale(Sequential, sequential, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Linear2), sequential, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Log), sequentialLog, [Continuous, Interpolating, Log]);
scale("".concat(Sequential, "-").concat(Pow), sequentialPow, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Sqrt), sequentialSqrt, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Symlog), sequentialSymlog, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Linear2), diverging, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Log), divergingLog, [Continuous, Interpolating, Log]);
scale("".concat(Diverging, "-").concat(Pow), divergingPow, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Sqrt), divergingSqrt, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Symlog), divergingSymlog, [Continuous, Interpolating]);
scale(Quantile2, quantile2, [Discretizing, Quantile2]);
scale(Quantize, quantize, Discretizing);
scale(Threshold, threshold, Discretizing);
scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, ordinal, Discrete);
scale(Band, band, Discrete);
scale(Point, point5, Discrete);
function isValidScaleType(type2) {
  return has(scales, type2);
}
function hasType(key2, type2) {
  const s = scales[key2];
  return s && s.metadata[type2];
}
function isContinuous(key2) {
  return hasType(key2, Continuous);
}
function isDiscrete(key2) {
  return hasType(key2, Discrete);
}
function isDiscretizing(key2) {
  return hasType(key2, Discretizing);
}
function isLogarithmic(key2) {
  return hasType(key2, Log);
}
function isTemporal(key2) {
  return hasType(key2, Temporal);
}
function isInterpolating(key2) {
  return hasType(key2, Interpolating);
}
function isQuantile(key2) {
  return hasType(key2, Quantile2);
}
var scaleProps = ["clamp", "base", "constant", "exponent"];
function interpolateRange(interpolator, range4) {
  const start = range4[0], span2 = peek(range4) - start;
  return function(i) {
    return interpolator(start + i * span2);
  };
}
function interpolateColors(colors2, type2, gamma3) {
  return piecewise(interpolate(type2 || "rgb", gamma3), colors2);
}
function quantizeInterpolator(interpolator, count2) {
  const samples = new Array(count2), n = count2 + 1;
  for (let i = 0; i < count2; )
    samples[i] = interpolator(++i / n);
  return samples;
}
function scaleFraction(scale$12, min4, max4) {
  const delta = max4 - min4;
  let i, t, s;
  if (!delta || !Number.isFinite(delta)) {
    return constant(0.5);
  } else {
    i = (t = scale$12.type).indexOf("-");
    t = i < 0 ? t : t.slice(i + 1);
    s = scale(t)().domain([min4, max4]).range([0, 1]);
    scaleProps.forEach((m2) => scale$12[m2] ? s[m2](scale$12[m2]()) : 0);
    return s;
  }
}
function interpolate(type2, gamma3) {
  const interp = src_exports[method(type2)];
  return gamma3 != null && interp && interp.gamma ? interp.gamma(gamma3) : interp;
}
function method(type2) {
  return "interpolate" + type2.toLowerCase().split("-").map((s) => s[0].toUpperCase() + s.slice(1)).join("");
}
var continuous2 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function colors(palette) {
  const n = palette.length / 6 | 0, c2 = new Array(n);
  for (let i = 0; i < n; ) {
    c2[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c2;
}
function apply(_, f) {
  for (const k in _)
    scheme(k, f(_[k]));
}
var schemes = {};
apply(discrete, colors);
apply(continuous2, (_) => interpolateColors(colors(_)));
function scheme(name2, scheme2) {
  name2 = name2 && name2.toLowerCase();
  if (arguments.length > 1) {
    schemes[name2] = scheme2;
    return this;
  } else {
    return schemes[name2];
  }
}
var SymbolLegend = "symbol";
var DiscreteLegend = "discrete";
var GradientLegend = "gradient";
var defaultFormatter = (value3) => isArray(value3) ? value3.map((v) => String(v)) : String(value3);
var ascending2 = (a2, b2) => a2[1] - b2[1];
var descending = (a2, b2) => b2[1] - a2[1];
function tickCount(scale6, count2, minStep) {
  let step;
  if (isNumber(count2)) {
    if (scale6.bins) {
      count2 = Math.max(count2, scale6.bins.length);
    }
    if (minStep != null) {
      count2 = Math.min(count2, Math.floor(span(scale6.domain()) / minStep || 1));
    }
  }
  if (isObject(count2)) {
    step = count2.step;
    count2 = count2.interval;
  }
  if (isString(count2)) {
    count2 = scale6.type === Time ? timeInterval(count2) : scale6.type == UTC ? utcInterval(count2) : error("Only time and utc scales accept interval strings.");
    if (step)
      count2 = count2.every(step);
  }
  return count2;
}
function validTicks(scale6, ticks, count2) {
  let range4 = scale6.range(), lo = range4[0], hi = peek(range4), cmp = ascending2;
  if (lo > hi) {
    range4 = hi;
    hi = lo;
    lo = range4;
    cmp = descending;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks = ticks.map((v) => [v, scale6(v)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count2 > 0 && ticks.length > 1) {
    const endpoints = [ticks[0], peek(ticks)];
    while (ticks.length > count2 && ticks.length >= 3) {
      ticks = ticks.filter((_, i) => !(i % 2));
    }
    if (ticks.length < 3) {
      ticks = endpoints;
    }
  }
  return ticks;
}
function tickValues(scale6, count2) {
  return scale6.bins ? validTicks(scale6, scale6.bins) : scale6.ticks ? scale6.ticks(count2) : scale6.domain();
}
function tickFormat2(locale4, scale6, count2, specifier, formatType, noSkip) {
  const type2 = scale6.type;
  let format5 = defaultFormatter;
  if (type2 === Time || formatType === Time) {
    format5 = locale4.timeFormat(specifier);
  } else if (type2 === UTC || formatType === UTC) {
    format5 = locale4.utcFormat(specifier);
  } else if (isLogarithmic(type2)) {
    const varfmt = locale4.formatFloat(specifier);
    if (noSkip || scale6.bins) {
      format5 = varfmt;
    } else {
      const test2 = tickLog(scale6, count2, false);
      format5 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale6.tickFormat) {
    const d = scale6.domain();
    format5 = locale4.formatSpan(d[0], d[d.length - 1], count2, specifier);
  } else if (specifier) {
    format5 = locale4.format(specifier);
  }
  return format5;
}
function tickLog(scale6, count2, values2) {
  const ticks = tickValues(scale6, count2), base2 = scale6.base(), logb = Math.log(base2), k = Math.max(1, base2 * count2 / ticks.length);
  const test2 = (d) => {
    let i = d / Math.pow(base2, Math.round(Math.log(d) / logb));
    if (i * base2 < base2 - 0.5)
      i *= base2;
    return i <= k;
  };
  return values2 ? ticks.filter(test2) : test2;
}
var symbols2 = {
  [Quantile2]: "quantiles",
  [Quantize]: "thresholds",
  [Threshold]: "domain"
};
var formats2 = {
  [Quantile2]: "quantiles",
  [Quantize]: "domain"
};
function labelValues(scale6, count2) {
  return scale6.bins ? binValues(scale6.bins) : scale6.type === Log ? tickLog(scale6, count2, true) : symbols2[scale6.type] ? thresholdValues(scale6[symbols2[scale6.type]]()) : tickValues(scale6, count2);
}
function thresholdFormat(locale4, scale6, specifier) {
  const _ = scale6[formats2[scale6.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale4.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues(thresholds) {
  const values2 = [-Infinity].concat(thresholds);
  values2.max = Infinity;
  return values2;
}
function binValues(bins) {
  const values2 = bins.slice(0, -1);
  values2.max = peek(bins);
  return values2;
}
var isDiscreteRange = (scale6) => symbols2[scale6.type] || scale6.bins;
function labelFormat(locale4, scale6, count2, type2, specifier, formatType, noSkip) {
  const format5 = formats2[scale6.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale4, scale6, specifier) : tickFormat2(locale4, scale6, count2, specifier, formatType, noSkip);
  return type2 === SymbolLegend && isDiscreteRange(scale6) ? formatRange(format5) : type2 === DiscreteLegend ? formatDiscrete(format5) : formatPoint(format5);
}
var formatRange = (format5) => (value3, index3, array4) => {
  const limit = get2(array4[index3 + 1], get2(array4.max, Infinity)), lo = formatValue(value3, format5), hi = formatValue(limit, format5);
  return lo && hi ? lo + " \u2013 " + hi : hi ? "< " + hi : "\u2265 " + lo;
};
var get2 = (value3, dflt) => value3 != null ? value3 : dflt;
var formatDiscrete = (format5) => (value3, index3) => index3 ? format5(value3) : null;
var formatPoint = (format5) => (value3) => format5(value3);
var formatValue = (value3, format5) => Number.isFinite(value3) ? format5(value3) : null;
function labelFraction(scale6) {
  const domain2 = scale6.domain(), count2 = domain2.length - 1;
  let lo = +domain2[0], hi = +peek(domain2), span2 = hi - lo;
  if (scale6.type === Threshold) {
    const adjust = count2 ? span2 / count2 : 0.1;
    lo -= adjust;
    hi += adjust;
    span2 = hi - lo;
  }
  return (value3) => (value3 - lo) / span2;
}
function format3(locale4, scale6, specifier, formatType) {
  const type2 = formatType || scale6.type;
  if (isString(specifier) && isTemporal(type2)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type2 === Time ? locale4.timeFormat("%A, %d %B %Y, %X") : !specifier && type2 === UTC ? locale4.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(locale4, scale6, 5, null, specifier, formatType, true);
}
function domainCaption(locale4, scale6, opt) {
  opt = opt || {};
  const max4 = Math.max(3, opt.maxlen || 7), fmt = format3(locale4, scale6, opt.format, opt.formatType);
  if (isDiscretizing(scale6.type)) {
    const v = labelValues(scale6).slice(1).map(fmt), n = v.length;
    return "".concat(n, " boundar").concat(n === 1 ? "y" : "ies", ": ").concat(v.join(", "));
  } else if (isDiscrete(scale6.type)) {
    const d = scale6.domain(), n = d.length, v = n > max4 ? d.slice(0, max4 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return "".concat(n, " value").concat(n === 1 ? "" : "s", ": ").concat(v);
  } else {
    const d = scale6.domain();
    return "values from ".concat(fmt(d[0]), " to ").concat(fmt(peek(d)));
  }
}

// node_modules/vega-scenegraph/build/vega-scenegraph.module.js
var gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
var patternPrefix = "p_";
function isGradient(value3) {
  return value3 && value3.gradient;
}
function gradientRef(g, defs, base2) {
  const type2 = g.gradient;
  let id2 = g.id, prefix = type2 === "radial" ? patternPrefix : "";
  if (!id2) {
    id2 = g.id = "gradient_" + gradient_id++;
    if (type2 === "radial") {
      g.x1 = get3(g.x1, 0.5);
      g.y1 = get3(g.y1, 0.5);
      g.r1 = get3(g.r1, 0);
      g.x2 = get3(g.x2, 0.5);
      g.y2 = get3(g.y2, 0.5);
      g.r2 = get3(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get3(g.x1, 0);
      g.y1 = get3(g.y1, 0);
      g.x2 = get3(g.x2, 1);
      g.y2 = get3(g.y2, 0);
    }
  }
  defs[id2] = g;
  return "url(" + (base2 || "") + "#" + prefix + id2 + ")";
}
function get3(val, def2) {
  return val != null ? val : def2;
}
function Gradient(p02, p1) {
  var stops = [], gradient3;
  return gradient3 = {
    gradient: "linear",
    x1: p02 ? p02[0] : 0,
    y1: p02 ? p02[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops,
    stop: function(offset4, color7) {
      stops.push({
        offset: offset4,
        color: color7
      });
      return gradient3;
    }
  };
}
var lookup = {
  "basis": {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  "bundle": {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: natural_default
  },
  "step": {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves(type2, orientation, tension) {
  var entry2 = has(lookup, type2) && lookup[type2], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var cmdlen = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
function pathParse(pathstr) {
  const result = [];
  let curr, chunks, parsed, param2, cmd, len, i, j, n, m2;
  const path3 = pathstr.slice().replace(regexp[0], "###$1").split(regexp[1]).slice(1);
  for (i = 0, n = path3.length; i < n; ++i) {
    curr = path3[i];
    chunks = curr.slice(1).trim().replace(regexp[2], "$1###$2").replace(regexp[3], "$1###$2").split(regexp[4]);
    cmd = curr.charAt(0);
    parsed = [cmd];
    for (j = 0, m2 = chunks.length; j < m2; ++j) {
      if ((param2 = +chunks[j]) === param2) {
        parsed.push(param2);
      }
    }
    len = cmdlen[cmd.toLowerCase()];
    if (parsed.length - 1 > len) {
      const m3 = parsed.length;
      j = 1;
      result.push([cmd].concat(parsed.slice(j, j += len)));
      cmd = cmd === "M" ? "L" : cmd === "m" ? "l" : cmd;
      for (; j < m3; j += len) {
        result.push([cmd].concat(parsed.slice(j, j + len)));
      }
    } else {
      result.push(parsed);
    }
  }
  return result;
}
var DegToRad = Math.PI / 180;
var Epsilon = 1e-14;
var HalfPi = Math.PI / 2;
var Tau = Math.PI * 2;
var HalfSqrt3 = Math.sqrt(3) / 2;
var segmentCache = {};
var bezierCache = {};
var join = [].join;
function segments(x5, y5, rx, ry, large, sweep, rotateX, ox, oy) {
  const key2 = join.call(arguments);
  if (segmentCache[key2]) {
    return segmentCache[key2];
  }
  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px2 = cos_th * (ox - x5) * 0.5 + sin_th * (oy - y5) * 0.5;
  const py2 = cos_th * (oy - y5) * 0.5 - sin_th * (ox - x5) * 0.5;
  let pl = px2 * px2 / (rx * rx) + py2 * py2 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x06 = a00 * ox + a01 * oy;
  const y06 = a10 * ox + a11 * oy;
  const x12 = a00 * x5 + a01 * y5;
  const y12 = a10 * x5 + a11 * y5;
  const d = (x12 - x06) * (x12 - x06) + (y12 - y06) * (y12 - y06);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x06 + x12) - sfactor * (y12 - y06);
  const yc = 0.5 * (y06 + y12) + sfactor * (x12 - x06);
  const th0 = Math.atan2(y06 - yc, x06 - xc);
  const th1 = Math.atan2(y12 - yc, x12 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache[key2] = result;
}
function bezier(params2) {
  const key2 = join.call(params2);
  if (bezierCache[key2]) {
    return bezierCache[key2];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x12 = cx + cos_th0 - t * sin_th0;
  const y12 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache[key2] = [a00 * x12 + a01 * y12, a10 * x12 + a11 * y12, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
var temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$1(current, sX, sY) {
  const c2 = temp[0] = current[0];
  if (c2 === "a" || c2 === "A") {
    temp[1] = sX * current[1];
    temp[2] = sY * current[2];
    temp[3] = current[3];
    temp[4] = current[4];
    temp[5] = current[5];
    temp[6] = sX * current[6];
    temp[7] = sY * current[7];
  } else if (c2 === "h" || c2 === "H") {
    temp[1] = sX * current[1];
  } else if (c2 === "v" || c2 === "V") {
    temp[1] = sY * current[1];
  } else {
    for (var i = 1, n = current.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
    }
  }
  return temp;
}
function pathRender(context3, path3, l, t, sX, sY) {
  var current, previous = null, x5 = 0, y5 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context3.beginPath)
    context3.beginPath();
  for (var i = 0, len = path3.length; i < len; ++i) {
    current = path3[i];
    if (sX !== 1 || sY !== 1) {
      current = scale$1(current, sX, sY);
    }
    switch (current[0]) {
      case "l":
        x5 += current[1];
        y5 += current[2];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "L":
        x5 = current[1];
        y5 = current[2];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "h":
        x5 += current[1];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "H":
        x5 = current[1];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "v":
        y5 += current[1];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "V":
        y5 = current[1];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "m":
        x5 += current[1];
        y5 += current[2];
        context3.moveTo(x5 + l, y5 + t);
        break;
      case "M":
        x5 = current[1];
        y5 = current[2];
        context3.moveTo(x5 + l, y5 + t);
        break;
      case "c":
        tempX = x5 + current[5];
        tempY = y5 + current[6];
        controlX = x5 + current[3];
        controlY = y5 + current[4];
        context3.bezierCurveTo(x5 + current[1] + l, y5 + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        break;
      case "C":
        x5 = current[5];
        y5 = current[6];
        controlX = current[3];
        controlY = current[4];
        context3.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x5 + l, y5 + t);
        break;
      case "s":
        tempX = x5 + current[3];
        tempY = y5 + current[4];
        controlX = 2 * x5 - controlX;
        controlY = 2 * y5 - controlY;
        context3.bezierCurveTo(controlX + l, controlY + t, x5 + current[1] + l, y5 + current[2] + t, tempX + l, tempY + t);
        controlX = x5 + current[1];
        controlY = y5 + current[2];
        x5 = tempX;
        y5 = tempY;
        break;
      case "S":
        tempX = current[3];
        tempY = current[4];
        controlX = 2 * x5 - controlX;
        controlY = 2 * y5 - controlY;
        context3.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        controlX = current[1];
        controlY = current[2];
        break;
      case "q":
        tempX = x5 + current[3];
        tempY = y5 + current[4];
        controlX = x5 + current[1];
        controlY = y5 + current[2];
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        break;
      case "Q":
        tempX = current[3];
        tempY = current[4];
        context3.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        controlX = current[1];
        controlY = current[2];
        break;
      case "t":
        tempX = x5 + current[1];
        tempY = y5 + current[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x5;
          controlY = y5;
        } else if (previous[0] === "t") {
          controlX = 2 * x5 - tempControlX;
          controlY = 2 * y5 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x5 - controlX;
          controlY = 2 * y5 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        controlX = x5 + current[1];
        controlY = y5 + current[2];
        break;
      case "T":
        tempX = current[1];
        tempY = current[2];
        controlX = 2 * x5 - controlX;
        controlY = 2 * y5 - controlY;
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        break;
      case "a":
        drawArc(context3, x5 + l, y5 + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x5 + l, current[7] + y5 + t]);
        x5 += current[6];
        y5 += current[7];
        break;
      case "A":
        drawArc(context3, x5 + l, y5 + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
        x5 = current[6];
        y5 = current[7];
        break;
      case "z":
      case "Z":
        context3.closePath();
        break;
    }
    previous = current;
  }
}
function drawArc(context3, x5, y5, coords) {
  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x5, y5);
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context3.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan30 = 0.5773502691896257;
var builtins = {
  "circle": {
    draw: function(context3, size) {
      const r = Math.sqrt(size) / 2;
      context3.moveTo(r, 0);
      context3.arc(0, 0, r, 0, Tau);
    }
  },
  "cross": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, s = r / 2.5;
      context3.moveTo(-r, -s);
      context3.lineTo(-r, s);
      context3.lineTo(-s, s);
      context3.lineTo(-s, r);
      context3.lineTo(s, r);
      context3.lineTo(s, s);
      context3.lineTo(r, s);
      context3.lineTo(r, -s);
      context3.lineTo(s, -s);
      context3.lineTo(s, -r);
      context3.lineTo(-s, -r);
      context3.lineTo(-s, -s);
      context3.closePath();
    }
  },
  "diamond": {
    draw: function(context3, size) {
      const r = Math.sqrt(size) / 2;
      context3.moveTo(-r, 0);
      context3.lineTo(0, -r);
      context3.lineTo(r, 0);
      context3.lineTo(0, r);
      context3.closePath();
    }
  },
  "square": {
    draw: function(context3, size) {
      var w2 = Math.sqrt(size), x5 = -w2 / 2;
      context3.rect(x5, x5, w2, w2);
    }
  },
  "arrow": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, s = r / 7, t = r / 2.5, v = r / 8;
      context3.moveTo(-s, r);
      context3.lineTo(s, r);
      context3.lineTo(s, -v);
      context3.lineTo(t, -v);
      context3.lineTo(0, -r);
      context3.lineTo(-t, -v);
      context3.lineTo(-s, -v);
      context3.closePath();
    }
  },
  "wedge": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r, o = h2 - r * Tan30, b2 = r / 4;
      context3.moveTo(0, -h2 - o);
      context3.lineTo(-b2, h2 - o);
      context3.lineTo(b2, h2 - o);
      context3.closePath();
    }
  },
  "triangle": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r, o = h2 - r * Tan30;
      context3.moveTo(0, -h2 - o);
      context3.lineTo(-r, h2 - o);
      context3.lineTo(r, h2 - o);
      context3.closePath();
    }
  },
  "triangle-up": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r;
      context3.moveTo(0, -h2);
      context3.lineTo(-r, h2);
      context3.lineTo(r, h2);
      context3.closePath();
    }
  },
  "triangle-down": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r;
      context3.moveTo(0, h2);
      context3.lineTo(-r, -h2);
      context3.lineTo(r, -h2);
      context3.closePath();
    }
  },
  "triangle-right": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r;
      context3.moveTo(h2, 0);
      context3.lineTo(-h2, -r);
      context3.lineTo(-h2, r);
      context3.closePath();
    }
  },
  "triangle-left": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r;
      context3.moveTo(-h2, 0);
      context3.lineTo(h2, -r);
      context3.lineTo(h2, r);
      context3.closePath();
    }
  },
  "stroke": {
    draw: function(context3, size) {
      const r = Math.sqrt(size) / 2;
      context3.moveTo(-r, 0);
      context3.lineTo(r, 0);
    }
  }
};
function symbols3(_) {
  return has(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom8 = {};
function customSymbol(path3) {
  if (!has(custom8, path3)) {
    const parsed = pathParse(path3);
    custom8[path3] = {
      draw: function(context3, size) {
        pathRender(context3, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom8[path3];
}
var C2 = 0.448084975506;
function rectangleX(d) {
  return d.x;
}
function rectangleY(d) {
  return d.y;
}
function rectangleWidth(d) {
  return d.width;
}
function rectangleHeight(d) {
  return d.height;
}
function number3(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp(value3, min4, max4) {
  return Math.max(min4, Math.min(value3, max4));
}
function vg_rect() {
  var x5 = rectangleX, y5 = rectangleY, width2 = rectangleWidth, height2 = rectangleHeight, crTL = number3(0), crTR = crTL, crBL = crTL, crBR = crTL, context3 = null;
  function rectangle2(_, x06, y06) {
    var buffer, x12 = x06 != null ? x06 : +x5.call(this, _), y12 = y06 != null ? y06 : +y5.call(this, _), w2 = +width2.call(this, _), h2 = +height2.call(this, _), s = Math.min(w2, h2) / 2, tl2 = clamp(+crTL.call(this, _), 0, s), tr2 = clamp(+crTR.call(this, _), 0, s), bl2 = clamp(+crBL.call(this, _), 0, s), br2 = clamp(+crBR.call(this, _), 0, s);
    if (!context3)
      context3 = buffer = path_default();
    if (tl2 <= 0 && tr2 <= 0 && bl2 <= 0 && br2 <= 0) {
      context3.rect(x12, y12, w2, h2);
    } else {
      var x22 = x12 + w2, y22 = y12 + h2;
      context3.moveTo(x12 + tl2, y12);
      context3.lineTo(x22 - tr2, y12);
      context3.bezierCurveTo(x22 - C2 * tr2, y12, x22, y12 + C2 * tr2, x22, y12 + tr2);
      context3.lineTo(x22, y22 - br2);
      context3.bezierCurveTo(x22, y22 - C2 * br2, x22 - C2 * br2, y22, x22 - br2, y22);
      context3.lineTo(x12 + bl2, y22);
      context3.bezierCurveTo(x12 + C2 * bl2, y22, x12, y22 - C2 * bl2, x12, y22 - bl2);
      context3.lineTo(x12, y12 + tl2);
      context3.bezierCurveTo(x12, y12 + C2 * tl2, x12 + C2 * tl2, y12, x12 + tl2, y12);
      context3.closePath();
    }
    if (buffer) {
      context3 = null;
      return buffer + "" || null;
    }
  }
  rectangle2.x = function(_) {
    if (arguments.length) {
      x5 = number3(_);
      return rectangle2;
    } else {
      return x5;
    }
  };
  rectangle2.y = function(_) {
    if (arguments.length) {
      y5 = number3(_);
      return rectangle2;
    } else {
      return y5;
    }
  };
  rectangle2.width = function(_) {
    if (arguments.length) {
      width2 = number3(_);
      return rectangle2;
    } else {
      return width2;
    }
  };
  rectangle2.height = function(_) {
    if (arguments.length) {
      height2 = number3(_);
      return rectangle2;
    } else {
      return height2;
    }
  };
  rectangle2.cornerRadius = function(tl2, tr2, br2, bl2) {
    if (arguments.length) {
      crTL = number3(tl2);
      crTR = tr2 != null ? number3(tr2) : crTL;
      crBR = br2 != null ? number3(br2) : crTL;
      crBL = bl2 != null ? number3(bl2) : crTR;
      return rectangle2;
    } else {
      return crTL;
    }
  };
  rectangle2.context = function(_) {
    if (arguments.length) {
      context3 = _ == null ? null : _;
      return rectangle2;
    } else {
      return context3;
    }
  };
  return rectangle2;
}
function vg_trail() {
  var x5, y5, size, defined, context3 = null, ready, x12, y12, r1;
  function point7(x22, y22, w2) {
    const r2 = w2 / 2;
    if (ready) {
      var ux = y12 - y22, uy = x22 - x12;
      if (ux || uy) {
        var ud = Math.sqrt(ux * ux + uy * uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context3.moveTo(x12 - rx, y12 - ry);
        context3.lineTo(x22 - ux * r2, y22 - uy * r2);
        context3.arc(x22, y22, r2, t - Math.PI, t);
        context3.lineTo(x12 + rx, y12 + ry);
        context3.arc(x12, y12, r1, t, t + Math.PI);
      } else {
        context3.arc(x22, y22, r2, 0, Tau);
      }
      context3.closePath();
    } else {
      ready = 1;
    }
    x12 = x22;
    y12 = y22;
    r1 = r2;
  }
  function trail2(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context3 == null)
      context3 = buffer = path_default();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point7(+x5(d, i, data3), +y5(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context3 = null;
      return buffer + "" || null;
    }
  }
  trail2.x = function(_) {
    if (arguments.length) {
      x5 = _;
      return trail2;
    } else {
      return x5;
    }
  };
  trail2.y = function(_) {
    if (arguments.length) {
      y5 = _;
      return trail2;
    } else {
      return y5;
    }
  };
  trail2.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail2;
    } else {
      return size;
    }
  };
  trail2.defined = function(_) {
    if (arguments.length) {
      defined = _;
      return trail2;
    } else {
      return defined;
    }
  };
  trail2.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context3 = null;
      } else {
        context3 = _;
      }
      return trail2;
    } else {
      return context3;
    }
  };
  return trail2;
}
function value$1(a2, b2) {
  return a2 != null ? a2 : b2;
}
var x2 = (item) => item.x || 0;
var y2 = (item) => item.y || 0;
var w = (item) => item.width || 0;
var h = (item) => item.height || 0;
var xw = (item) => (item.x || 0) + (item.width || 0);
var yh = (item) => (item.y || 0) + (item.height || 0);
var sa = (item) => item.startAngle || 0;
var ea = (item) => item.endAngle || 0;
var pa = (item) => item.padAngle || 0;
var ir = (item) => item.innerRadius || 0;
var or = (item) => item.outerRadius || 0;
var cr = (item) => item.cornerRadius || 0;
var tl = (item) => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr = (item) => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br = (item) => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl = (item) => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz = (item) => value$1(item.size, 64);
var ts = (item) => item.size || 1;
var def = (item) => !(item.defined === false);
var type = (item) => symbols3(item.shape || "circle");
var arcShape = arc_default().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr);
var areavShape = area_default().x(x2).y1(y2).y0(yh).defined(def);
var areahShape = area_default().y(y2).x1(x2).x0(xw).defined(def);
var lineShape = line_default().x(x2).y(y2).defined(def);
var rectShape = vg_rect().x(x2).y(y2).width(w).height(h).cornerRadius(tl, tr, br, bl);
var symbolShape = symbol_default().type(type).size(sz);
var trailShape = vg_trail().x(x2).y(y2).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context3, item) {
  return arcShape.context(context3)(item);
}
function area$1(context3, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context3)(items);
}
function line$1(context3, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context3)(items);
}
function rectangle(context3, item, x5, y5) {
  return rectShape.context(context3)(item, x5, y5);
}
function shape$1(context3, item) {
  return (item.mark.shape || item.shape).context(context3)(item);
}
function symbol$1(context3, item) {
  return symbolShape.context(context3)(item);
}
function trail$1(context3, items) {
  return trailShape.context(context3)(items);
}
var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip$1(renderer, item, size) {
  var clip3 = item.clip, defs = renderer._defs, id2 = item.clip_id || (item.clip_id = "clip" + clip_id++), c2 = defs.clipping[id2] || (defs.clipping[id2] = {
    id: id2
  });
  if (isFunction(clip3)) {
    c2.path = clip3(null);
  } else if (hasCornerRadius(size)) {
    c2.path = rectangle(null, size, 0, 0);
  } else {
    c2.width = size.width || 0;
    c2.height = size.height || 0;
  }
  return "url(#" + id2 + ")";
}
function Bounds(b2) {
  this.clear();
  if (b2)
    this.union(b2);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b2) {
    return this.x1 === b2.x1 && this.y1 === b2.y1 && this.x2 === b2.x2 && this.y2 === b2.y2;
  },
  set(x12, y12, x22, y22) {
    if (x22 < x12) {
      this.x2 = x12;
      this.x1 = x22;
    } else {
      this.x1 = x12;
      this.x2 = x22;
    }
    if (y22 < y12) {
      this.y2 = y12;
      this.y1 = y22;
    } else {
      this.y1 = y12;
      this.y2 = y22;
    }
    return this;
  },
  add(x5, y5) {
    if (x5 < this.x1)
      this.x1 = x5;
    if (y5 < this.y1)
      this.y1 = y5;
    if (x5 > this.x2)
      this.x2 = x5;
    if (y5 > this.y2)
      this.y2 = y5;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle2, x5, y5) {
    const p = this.rotatedPoints(angle2, x5, y5);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle2, x5, y5) {
    var {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22
    } = this, cos4 = Math.cos(angle2), sin4 = Math.sin(angle2), cx = x5 - x5 * cos4 + y5 * sin4, cy = y5 - x5 * sin4 - y5 * cos4;
    return [cos4 * x12 - sin4 * y12 + cx, sin4 * x12 + cos4 * y12 + cy, cos4 * x12 - sin4 * y22 + cx, sin4 * x12 + cos4 * y22 + cy, cos4 * x22 - sin4 * y12 + cx, sin4 * x22 + cos4 * y12 + cy, cos4 * x22 - sin4 * y22 + cx, sin4 * x22 + cos4 * y22 + cy];
  },
  union(b2) {
    if (b2.x1 < this.x1)
      this.x1 = b2.x1;
    if (b2.y1 < this.y1)
      this.y1 = b2.y1;
    if (b2.x2 > this.x2)
      this.x2 = b2.x2;
    if (b2.y2 > this.y2)
      this.y2 = b2.y2;
    return this;
  },
  intersect(b2) {
    if (b2.x1 > this.x1)
      this.x1 = b2.x1;
    if (b2.y1 > this.y1)
      this.y1 = b2.y1;
    if (b2.x2 < this.x2)
      this.x2 = b2.x2;
    if (b2.y2 < this.y2)
      this.y2 = b2.y2;
    return this;
  },
  encloses(b2) {
    return b2 && this.x1 <= b2.x1 && this.x2 >= b2.x2 && this.y1 <= b2.y1 && this.y2 >= b2.y2;
  },
  alignsWith(b2) {
    return b2 && (this.x1 == b2.x1 || this.x2 == b2.x2 || this.y1 == b2.y1 || this.y2 == b2.y2);
  },
  intersects(b2) {
    return b2 && !(this.x2 < b2.x1 || this.x1 > b2.x2 || this.y2 < b2.y1 || this.y1 > b2.y2);
  },
  contains(x5, y5) {
    return !(x5 < this.x1 || x5 > this.x2 || y5 < this.y1 || y5 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds();
}
function GroupItem(mark) {
  Item.call(this, mark);
  this.items = this.items || [];
}
inherits(GroupItem, Item);
function ResourceLoader(customLoader) {
  this._pending = 0;
  this._loader = customLoader || loader();
}
function increment(loader2) {
  loader2._pending += 1;
}
function decrement(loader2) {
  loader2._pending -= 1;
}
ResourceLoader.prototype = {
  pending() {
    return this._pending;
  },
  sanitizeURL(uri) {
    const loader2 = this;
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement(loader2);
      return opt;
    }).catch(() => {
      decrement(loader2);
      return null;
    });
  },
  loadImage(uri) {
    const loader2 = this, Image2 = domImage();
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2)
        throw {
          url
        };
      const img = new Image2();
      const cors = has(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null)
        img.crossOrigin = cors;
      img.onload = () => decrement(loader2);
      img.onerror = () => decrement(loader2);
      img.src = url;
      return img;
    }).catch((e) => {
      decrement(loader2);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e && e.url || ""
      };
    });
  },
  ready() {
    const loader2 = this;
    return new Promise((accept) => {
      function poll(value3) {
        if (!loader2.pending())
          accept(value3);
        else
          setTimeout(() => {
            poll(true);
          }, 10);
      }
      poll(false);
    });
  }
};
function boundStroke(bounds2, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds2.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }
  return bounds2;
}
function miterAdjustment(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold = Tau - 1e-8;
var bounds;
var lx;
var ly;
var rot;
var ma;
var mb;
var mc;
var md;
var add3 = (x5, y5) => bounds.add(x5, y5);
var addL = (x5, y5) => add3(lx = x5, ly = y5);
var addX = (x5) => add3(x5, bounds.y1);
var addY = (y5) => add3(bounds.x1, y5);
var px = (x5, y5) => ma * x5 + mc * y5;
var py = (x5, y5) => mb * x5 + md * y5;
var addp = (x5, y5) => add3(px(x5, y5), py(x5, y5));
var addpL = (x5, y5) => addL(px(x5, y5), py(x5, y5));
function boundContext(_, deg) {
  bounds = _;
  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }
  return context$1;
}
var context$1 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL,
  lineTo: addpL,
  rect(x5, y5, w2, h2) {
    if (rot) {
      addp(x5 + w2, y5);
      addp(x5 + w2, y5 + h2);
      addp(x5, y5 + h2);
      addpL(x5, y5);
    } else {
      add3(x5 + w2, y5 + h2);
      addL(x5, y5);
    }
  },
  quadraticCurveTo(x12, y12, x22, y22) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x22, y22), py2 = py(x22, y22);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },
  bezierCurveTo(x12, y12, x22, y22, x32, y32) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x22, y22), py2 = py(x22, y22), px3 = px(x32, y32), py3 = py(x32, y32);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },
  arc(cx, cy, r, sa2, ea2, ccw) {
    sa2 += rot;
    ea2 += rot;
    lx = r * Math.cos(ea2) + cx;
    ly = r * Math.sin(ea2) + cy;
    if (Math.abs(ea2 - sa2) > circleThreshold) {
      add3(cx - r, cy - r);
      add3(cx + r, cy + r);
    } else {
      const update3 = (a2) => add3(r * Math.cos(a2) + cx, r * Math.sin(a2) + cy);
      let s, i;
      update3(sa2);
      update3(ea2);
      if (ea2 !== sa2) {
        sa2 = sa2 % Tau;
        if (sa2 < 0)
          sa2 += Tau;
        ea2 = ea2 % Tau;
        if (ea2 < 0)
          ea2 += Tau;
        if (ea2 < sa2) {
          ccw = !ccw;
          s = sa2;
          sa2 = ea2;
          ea2 = s;
        }
        if (ccw) {
          ea2 -= Tau;
          s = sa2 - sa2 % HalfPi;
          for (i = 0; i < 4 && s > ea2; ++i, s -= HalfPi)
            update3(s);
        } else {
          s = sa2 - sa2 % HalfPi + HalfPi;
          for (i = 0; i < 4 && s < ea2; ++i, s = s + HalfPi)
            update3(s);
        }
      }
    }
  }
};
function quadExtrema(x06, x12, x22, cb) {
  const t = (x06 - x12) / (x06 + x22 - 2 * x12);
  if (0 < t && t < 1)
    cb(x06 + (x12 - x06) * t);
}
function cubicExtrema(x06, x12, x22, x32, cb) {
  const a2 = x32 - x06 + 3 * x12 - 3 * x22, b2 = x06 + x22 - 2 * x12, c2 = x06 - x12;
  let t05 = 0, t14 = 0, r;
  if (Math.abs(a2) > Epsilon) {
    r = b2 * b2 + c2 * a2;
    if (r >= 0) {
      r = Math.sqrt(r);
      t05 = (-b2 + r) / a2;
      t14 = (-b2 - r) / a2;
    }
  } else {
    t05 = 0.5 * c2 / b2;
  }
  if (0 < t05 && t05 < 1)
    cb(cubic(t05, x06, x12, x22, x32));
  if (0 < t14 && t14 < 1)
    cb(cubic(t14, x06, x12, x22, x32));
}
function cubic(t, x06, x12, x22, x32) {
  const s = 1 - t, s2 = s * s, t23 = t * t;
  return s2 * s * x06 + 3 * s2 * t * x12 + 3 * s * t23 * x22 + t23 * t * x32;
}
var context = (context = domCanvas(1, 1)) ? context.getContext("2d") : null;
var b = new Bounds();
function intersectPath(draw3) {
  return function(item, brush) {
    if (!context)
      return true;
    draw3(context, item);
    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22
    } = b;
    for (let y5 = y12; y5 <= y22; ++y5) {
      for (let x5 = x12; x5 <= x22; ++x5) {
        if (context.isPointInPath(x5, y5)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x5 = item.x || 0, y5 = item.y || 0, w2 = item.width || 0, h2 = item.height || 0;
  return box.intersects(b.set(x5, y5, x5 + w2, y5 + h2));
}
function intersectRule(item, box) {
  const x5 = item.x || 0, y5 = item.y || 0, x22 = item.x2 != null ? item.x2 : x5, y22 = item.y2 != null ? item.y2 : y5;
  return intersectBoxLine(box, x5, y5, x22, y22);
}
function intersectBoxLine(box, x5, y5, u, v) {
  const {
    x1: x12,
    y1: y12,
    x2: x22,
    y2: y22
  } = box, dx = u - x5, dy = v - y5;
  let t05 = 0, t14 = 1, p, q, r, e;
  for (e = 0; e < 4; ++e) {
    if (e === 0) {
      p = -dx;
      q = -(x12 - x5);
    }
    if (e === 1) {
      p = dx;
      q = x22 - x5;
    }
    if (e === 2) {
      p = -dy;
      q = -(y12 - y5);
    }
    if (e === 3) {
      p = dy;
      q = y22 - y5;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r = q / p;
    if (p < 0) {
      if (r > t14)
        return false;
      else if (r > t05)
        t05 = r;
    } else if (p > 0) {
      if (r < t05)
        return false;
      else if (r < t14)
        t14 = r;
    }
  }
  return true;
}
function blend(context3, item) {
  context3.globalCompositeOperation = item.blend || "source-over";
}
function value(value3, dflt) {
  return value3 == null ? dflt : value3;
}
function addStops(gradient3, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient3.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient3;
}
function gradient(context3, spec, bounds2) {
  const w2 = bounds2.width(), h2 = bounds2.height();
  let gradient3;
  if (spec.gradient === "radial") {
    gradient3 = context3.createRadialGradient(bounds2.x1 + value(spec.x1, 0.5) * w2, bounds2.y1 + value(spec.y1, 0.5) * h2, Math.max(w2, h2) * value(spec.r1, 0), bounds2.x1 + value(spec.x2, 0.5) * w2, bounds2.y1 + value(spec.y2, 0.5) * h2, Math.max(w2, h2) * value(spec.r2, 0.5));
  } else {
    const x12 = value(spec.x1, 0), y12 = value(spec.y1, 0), x22 = value(spec.x2, 1), y22 = value(spec.y2, 0);
    if (x12 === x22 || y12 === y22 || w2 === h2) {
      gradient3 = context3.createLinearGradient(bounds2.x1 + x12 * w2, bounds2.y1 + y12 * h2, bounds2.x1 + x22 * w2, bounds2.y1 + y22 * h2);
    } else {
      const image2 = domCanvas(Math.ceil(w2), Math.ceil(h2)), ictx = image2.getContext("2d");
      ictx.scale(w2, h2);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x12, y12, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w2, h2);
      return context3.createPattern(image2, "no-repeat");
    }
  }
  return addStops(gradient3, spec.stops);
}
function color2(context3, item, value3) {
  return isGradient(value3) ? gradient(context3, value3, item.bounds) : value3;
}
function fill(context3, item, opacity) {
  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity > 0) {
    context3.globalAlpha = opacity;
    context3.fillStyle = color2(context3, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty2 = [];
function stroke(context3, item, opacity) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity > 0) {
    context3.globalAlpha = opacity;
    context3.strokeStyle = color2(context3, item, item.stroke);
    context3.lineWidth = lw;
    context3.lineCap = item.strokeCap || "butt";
    context3.lineJoin = item.strokeJoin || "miter";
    context3.miterLimit = item.strokeMiterLimit || 10;
    if (context3.setLineDash) {
      context3.setLineDash(item.strokeDash || Empty2);
      context3.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare2(a2, b2) {
  return a2.zindex - b2.zindex || a2.index - b2.index;
}
function zorder(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare2);
}
function visit(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length)
    return;
  const zitems = zorder(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex)
        visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items, hit2, i;
  if (!items || !items.length)
    return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length)
    items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit2 = visitor(items[i]))
      return hit2;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit2 = visitor(items[i]))
          return hit2;
      }
    }
  }
  return null;
}
function drawAll(path3) {
  return function(context3, scene, bounds2) {
    visit(scene, (item) => {
      if (!bounds2 || bounds2.intersects(item.bounds)) {
        drawPath(path3, context3, item, item);
      }
    });
  };
}
function drawOne(path3) {
  return function(context3, scene, bounds2) {
    if (scene.items.length && (!bounds2 || bounds2.intersects(scene.bounds))) {
      drawPath(path3, context3, scene.items[0], scene.items);
    }
  };
}
function drawPath(path3, context3, item, items) {
  var opacity = item.opacity == null ? 1 : item.opacity;
  if (opacity === 0)
    return;
  if (path3(context3, items))
    return;
  blend(context3, item);
  if (item.fill && fill(context3, item, opacity)) {
    context3.fill();
  }
  if (item.stroke && stroke(context3, item, opacity)) {
    context3.stroke();
  }
}
function pick$1(test2) {
  test2 = test2 || truthy;
  return function(context3, scene, x5, y5, gx, gy) {
    x5 *= context3.pixelRatio;
    y5 *= context3.pixelRatio;
    return pickVisit(scene, (item) => {
      const b2 = item.bounds;
      if (b2 && !b2.contains(gx, gy) || !b2)
        return;
      if (test2(context3, item, x5, y5, gx, gy))
        return item;
    });
  };
}
function hitPath(path3, filled) {
  return function(context3, o, x5, y5) {
    var item = Array.isArray(o) ? o[0] : o, fill2 = filled == null ? item.fill : filled, stroke2 = item.stroke && context3.isPointInStroke, lw, lc;
    if (stroke2) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context3.lineWidth = lw != null ? lw : 1;
      context3.lineCap = lc != null ? lc : "butt";
    }
    return path3(context3, o) ? false : fill2 && context3.isPointInPath(x5, y5) || stroke2 && context3.isPointInStroke(x5, y5);
  };
}
function pickPath(path3) {
  return pick$1(hitPath(path3));
}
function translate(x5, y5) {
  return "translate(" + x5 + "," + y5 + ")";
}
function rotate(a2) {
  return "rotate(" + a2 + ")";
}
function scale2(scaleX, scaleY) {
  return "scale(" + scaleX + "," + scaleY + ")";
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "");
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale2(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath(type2, shape2, isect) {
  function attr2(emit2, item) {
    emit2("transform", rotateItem(item));
    emit2("d", shape2(null, item));
  }
  function bound2(bounds2, item) {
    shape2(boundContext(bounds2, item.angle), item);
    return boundStroke(bounds2, item).translate(item.x || 0, item.y || 0);
  }
  function draw3(context3, item) {
    var x5 = item.x || 0, y5 = item.y || 0, a2 = item.angle || 0;
    context3.translate(x5, y5);
    if (a2)
      context3.rotate(a2 *= DegToRad);
    context3.beginPath();
    shape2(context3, item);
    if (a2)
      context3.rotate(-a2);
    context3.translate(-x5, -y5);
  }
  return {
    type: type2,
    tag: "path",
    nested: false,
    attr: attr2,
    bound: bound2,
    draw: drawAll(draw3),
    pick: pickPath(draw3),
    isect: isect || intersectPath(draw3)
  };
}
var arc = markItemPath("arc", arc$1);
function pickArea(a2, p) {
  var v = a2[0].orient === "horizontal" ? p[1] : p[0], z = a2[0].orient === "horizontal" ? "y" : "x", i = a2.length, min4 = Infinity, hit2, d;
  while (--i >= 0) {
    if (a2[i].defined === false)
      continue;
    d = Math.abs(a2[i][z] - v);
    if (d < min4) {
      min4 = d;
      hit2 = a2[i];
    }
  }
  return hit2;
}
function pickLine(a2, p) {
  var t = Math.pow(a2[0].strokeWidth || 1, 2), i = a2.length, dx, dy, dd;
  while (--i >= 0) {
    if (a2[i].defined === false)
      continue;
    dx = a2[i].x - p[0];
    dy = a2[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a2[i];
  }
  return null;
}
function pickTrail(a2, p) {
  var i = a2.length, dx, dy, dd;
  while (--i >= 0) {
    if (a2[i].defined === false)
      continue;
    dx = a2[i].x - p[0];
    dy = a2[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a2[i].size || 1;
    if (dd < dx * dx)
      return a2[i];
  }
  return null;
}
function markMultiItemPath(type2, shape2, tip) {
  function attr2(emit2, item) {
    var items = item.mark.items;
    if (items.length)
      emit2("d", shape2(null, items));
  }
  function bound2(bounds2, mark) {
    var items = mark.items;
    if (items.length === 0) {
      return bounds2;
    } else {
      shape2(boundContext(bounds2), items);
      return boundStroke(bounds2, items[0]);
    }
  }
  function draw3(context3, items) {
    context3.beginPath();
    shape2(context3, items);
  }
  const hit2 = hitPath(draw3);
  function pick2(context3, scene, x5, y5, gx, gy) {
    var items = scene.items, b2 = scene.bounds;
    if (!items || !items.length || b2 && !b2.contains(gx, gy)) {
      return null;
    }
    x5 *= context3.pixelRatio;
    y5 *= context3.pixelRatio;
    return hit2(context3, items, x5, y5) ? items[0] : null;
  }
  return {
    type: type2,
    tag: "path",
    nested: true,
    attr: attr2,
    bound: bound2,
    draw: drawOne(draw3),
    pick: pick2,
    isect: intersectPoint,
    tip
  };
}
var area = markMultiItemPath("area", area$1, pickArea);
function clip(context3, scene) {
  var clip3 = scene.clip;
  context3.save();
  if (isFunction(clip3)) {
    context3.beginPath();
    clip3(context3);
    context3.clip();
  } else {
    clipGroup(context3, scene.group);
  }
}
function clipGroup(context3, group2) {
  context3.beginPath();
  hasCornerRadius(group2) ? rectangle(context3, group2, 0, 0) : context3.rect(0, 0, group2.width || 0, group2.height || 0);
  context3.clip();
}
function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$5(emit2, item) {
  emit2("transform", translateItem(item));
}
function emitRectangle(emit2, item) {
  const off = offset$1(item);
  emit2("d", rectangle(null, item, off, off));
}
function background(emit2, item) {
  emit2("class", "background");
  emit2("aria-hidden", true);
  emitRectangle(emit2, item);
}
function foreground(emit2, item) {
  emit2("class", "foreground");
  emit2("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle(emit2, item);
  } else {
    emit2("d", "");
  }
}
function content(emit2, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit2("clip-path", url);
}
function bound$5(bounds2, group2) {
  if (!group2.clip && group2.items) {
    const items = group2.items, m2 = items.length;
    for (let j = 0; j < m2; ++j) {
      bounds2.union(items[j].bounds);
    }
  }
  if ((group2.clip || group2.width || group2.height) && !group2.noBound) {
    bounds2.add(0, 0).add(group2.width || 0, group2.height || 0);
  }
  boundStroke(bounds2, group2);
  return bounds2.translate(group2.x || 0, group2.y || 0);
}
function rectanglePath(context3, group2, x5, y5) {
  const off = offset$1(group2);
  context3.beginPath();
  rectangle(context3, group2, (x5 || 0) + off, (y5 || 0) + off);
}
var hitBackground = hitPath(rectanglePath);
var hitForeground = hitPath(rectanglePath, false);
var hitCorner = hitPath(rectanglePath, true);
function draw$4(context3, scene, bounds2) {
  visit(scene, (group2) => {
    const gx = group2.x || 0, gy = group2.y || 0, fore = group2.strokeForeground, opacity = group2.opacity == null ? 1 : group2.opacity;
    if ((group2.stroke || group2.fill) && opacity) {
      rectanglePath(context3, group2, gx, gy);
      blend(context3, group2);
      if (group2.fill && fill(context3, group2, opacity)) {
        context3.fill();
      }
      if (group2.stroke && !fore && stroke(context3, group2, opacity)) {
        context3.stroke();
      }
    }
    context3.save();
    context3.translate(gx, gy);
    if (group2.clip)
      clipGroup(context3, group2);
    if (bounds2)
      bounds2.translate(-gx, -gy);
    visit(group2, (item) => {
      this.draw(context3, item, bounds2);
    });
    if (bounds2)
      bounds2.translate(gx, gy);
    context3.restore();
    if (fore && group2.stroke && opacity) {
      rectanglePath(context3, group2, gx, gy);
      blend(context3, group2);
      if (stroke(context3, group2, opacity)) {
        context3.stroke();
      }
    }
  });
}
function pick(context3, scene, x5, y5, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x5 * context3.pixelRatio, cy = y5 * context3.pixelRatio;
  return pickVisit(scene, (group2) => {
    let hit2, dx, dy;
    const b2 = group2.bounds;
    if (b2 && !b2.contains(gx, gy))
      return;
    dx = group2.x || 0;
    dy = group2.y || 0;
    const dw = dx + (group2.width || 0), dh = dy + (group2.height || 0), c2 = group2.clip;
    if (c2 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context3.save();
    context3.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c2 && hasCornerRadius(group2) && !hitCorner(context3, group2, cx, cy)) {
      context3.restore();
      return null;
    }
    const fore = group2.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group2.stroke && hitForeground(context3, group2, cx, cy)) {
      context3.restore();
      return group2;
    }
    hit2 = pickVisit(group2, (mark) => pickMark(mark, dx, dy) ? this.pick(mark, x5, y5, dx, dy) : null);
    if (!hit2 && ix && (group2.fill || !fore && group2.stroke) && hitBackground(context3, group2, cx, cy)) {
      hit2 = group2;
    }
    context3.restore();
    return hit2 || null;
  });
}
function pickMark(mark, x5, y5) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x5, y5);
}
var group = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick,
  isect: intersectRect,
  content,
  background,
  foreground
};
var metadata = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage(item, renderer) {
  var image2 = item.image;
  if (!image2 || item.url && item.url !== image2.url) {
    image2 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image3) => {
      item.image = image3;
      item.image.url = item.url;
    });
  }
  return image2;
}
function imageWidth(item, image2) {
  return item.width != null ? item.width : !image2 || !image2.width ? 0 : item.aspect !== false && item.height ? item.height * image2.width / image2.height : image2.width;
}
function imageHeight(item, image2) {
  return item.height != null ? item.height : !image2 || !image2.height ? 0 : item.aspect !== false && item.width ? item.width * image2.height / image2.width : image2.height;
}
function imageXOffset(align, w2) {
  return align === "center" ? w2 / 2 : align === "right" ? w2 : 0;
}
function imageYOffset(baseline2, h2) {
  return baseline2 === "middle" ? h2 / 2 : baseline2 === "bottom" ? h2 : 0;
}
function attr$4(emit2, item, renderer) {
  const img = getImage(item, renderer), w2 = imageWidth(item, img), h2 = imageHeight(item, img), x5 = (item.x || 0) - imageXOffset(item.align, w2), y5 = (item.y || 0) - imageYOffset(item.baseline, h2), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit2("href", i, metadata["xmlns:xlink"], "xlink:href");
  emit2("transform", translate(x5, y5));
  emit2("width", w2);
  emit2("height", h2);
  emit2("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$4(bounds2, item) {
  const img = item.image, w2 = imageWidth(item, img), h2 = imageHeight(item, img), x5 = (item.x || 0) - imageXOffset(item.align, w2), y5 = (item.y || 0) - imageYOffset(item.baseline, h2);
  return bounds2.set(x5, y5, x5 + w2, y5 + h2);
}
function draw$3(context3, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds))
      return;
    const img = getImage(item, this);
    let w2 = imageWidth(item, img);
    let h2 = imageHeight(item, img);
    if (w2 === 0 || h2 === 0)
      return;
    let x5 = (item.x || 0) - imageXOffset(item.align, w2), y5 = (item.y || 0) - imageYOffset(item.baseline, h2), opacity, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w2 / ar0;
          y5 += (h2 - t) / 2;
          h2 = t;
        } else {
          t = h2 * ar0;
          x5 += (w2 - t) / 2;
          w2 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend(context3, item);
      context3.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;
      context3.imageSmoothingEnabled = item.smooth !== false;
      context3.drawImage(img, x5, y5, w2, h2);
    }
  });
}
var image = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: truthy,
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};
var line = markMultiItemPath("line", line$1, pickLine);
function attr$3(emit2, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit2("vector-effect", "non-scaling-stroke");
  }
  emit2("transform", transformItem(item));
  emit2("d", item.path);
}
function path$1(context3, item) {
  var path3 = item.path;
  if (path3 == null)
    return true;
  var x5 = item.x || 0, y5 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a2 = (item.angle || 0) * DegToRad, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path3) {
    (item.pathCache = cache2 = pathParse(path3)).path = path3;
  }
  if (a2 && context3.rotate && context3.translate) {
    context3.translate(x5, y5);
    context3.rotate(a2);
    pathRender(context3, cache2, 0, 0, sx, sy);
    context3.rotate(-a2);
    context3.translate(-x5, -y5);
  } else {
    pathRender(context3, cache2, x5, y5, sx, sy);
  }
}
function bound$3(bounds2, item) {
  return path$1(boundContext(bounds2, item.angle), item) ? bounds2.set(0, 0, 0, 0) : boundStroke(bounds2, item, true);
}
var path$2 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};
function attr$2(emit2, item) {
  emit2("d", rectangle(null, item));
}
function bound$2(bounds2, item) {
  var x5, y5;
  return boundStroke(bounds2.set(x5 = item.x || 0, y5 = item.y || 0, x5 + item.width || 0, y5 + item.height || 0), item);
}
function draw$2(context3, item) {
  context3.beginPath();
  rectangle(context3, item);
}
var rect = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};
function attr$1(emit2, item) {
  emit2("transform", translateItem(item));
  emit2("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit2("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$1(bounds2, item) {
  var x12, y12;
  return boundStroke(bounds2.set(x12 = item.x || 0, y12 = item.y || 0, item.x2 != null ? item.x2 : x12, item.y2 != null ? item.y2 : y12), item);
}
function path2(context3, item, opacity) {
  var x12, y12, x22, y22;
  if (item.stroke && stroke(context3, item, opacity)) {
    x12 = item.x || 0;
    y12 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x12;
    y22 = item.y2 != null ? item.y2 : y12;
    context3.beginPath();
    context3.moveTo(x12, y12);
    context3.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$1(context3, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds))
      return;
    var opacity = item.opacity == null ? 1 : item.opacity;
    if (opacity && path2(context3, item, opacity)) {
      blend(context3, item);
      context3.stroke();
    }
  });
}
function hit$1(context3, item, x5, y5) {
  if (!context3.isPointInStroke)
    return false;
  return path2(context3, item, 1) && context3.isPointInStroke(x5, y5);
}
var rule = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};
var shape = markItemPath("shape", shape$1);
var symbol = markItemPath("symbol", symbol$1, intersectPoint);
var widthCache = lruCache();
var textMetrics = {
  height: fontSize,
  measureWidth,
  estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);
function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
}
function estimateWidth(item, text2) {
  return _estimateWidth(textValue(item, text2), fontSize(item));
}
function _estimateWidth(text2, currentFontHeight) {
  return ~~(0.8 * text2.length * currentFontHeight);
}
function measureWidth(item, text2) {
  return fontSize(item) <= 0 || !(text2 = textValue(item, text2)) ? 0 : _measureWidth(text2, font(item));
}
function _measureWidth(text2, currentFont) {
  const key2 = `(${currentFont}) ${text2}`;
  let width2 = widthCache.get(key2);
  if (width2 === void 0) {
    context.font = currentFont;
    width2 = context.measureText(text2).width;
    widthCache.set(key2, width2);
  }
  return width2;
}
function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}
function lineArray(_) {
  return isArray(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines(item) {
  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl2 = textLines(item);
  return (isArray(tl2) ? tl2.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line3) {
  const text2 = line3 == null ? "" : (line3 + "").trim();
  return item.limit > 0 && text2.length ? truncate2(item, text2) : text2;
}
function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    const currentFont = font(item);
    return (text2) => _measureWidth(text2, currentFont);
  } else {
    const currentFontHeight = fontSize(item);
    return (text2) => _estimateWidth(text2, currentFontHeight);
  }
}
function truncate2(item, text2) {
  var limit = +item.limit, width2 = widthGetter(item);
  if (width2(text2) < limit)
    return text2;
  var ellipsis = item.ellipsis || "\u2026", rtl = item.dir === "rtl", lo = 0, hi = text2.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text2.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text2.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text2.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text2.slice(0, lo) + ellipsis;
  }
}
function fontFamily(item, quote) {
  var font2 = item.font;
  return (quote && font2 ? String(font2).replace(/"/g, "'") : font2) || "sans-serif";
}
function font(item, quote) {
  return "" + (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize(item) + "px " + fontFamily(item, quote);
}
function offset2(item) {
  var baseline2 = item.baseline, h2 = fontSize(item);
  return Math.round(baseline2 === "top" ? 0.79 * h2 : baseline2 === "middle" ? 0.3 * h2 : baseline2 === "bottom" ? -0.21 * h2 : baseline2 === "line-top" ? 0.29 * h2 + 0.5 * lineHeight(item) : baseline2 === "line-bottom" ? 0.29 * h2 - 0.5 * lineHeight(item) : 0);
}
var textAlign = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
var tempBounds = new Bounds();
function anchorPoint(item) {
  var x5 = item.x || 0, y5 = item.y || 0, r = item.radius || 0, t;
  if (r) {
    t = (item.theta || 0) - HalfPi;
    x5 += r * Math.cos(t);
    y5 += r * Math.sin(t);
  }
  tempBounds.x1 = x5;
  tempBounds.y1 = y5;
  return tempBounds;
}
function attr(emit2, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset2(item), p = anchorPoint(item), x5 = p.x1, y5 = p.y1, a2 = item.angle || 0, t;
  emit2("text-anchor", textAlign[item.align] || "start");
  if (a2) {
    t = translate(x5, y5) + " " + rotate(a2);
    if (dx || dy)
      t += " " + translate(dx, dy);
  } else {
    t = translate(x5 + dx, y5 + dy);
  }
  emit2("transform", t);
}
function bound(bounds2, item, mode) {
  var h2 = textMetrics.height(item), a2 = item.align, p = anchorPoint(item), x5 = p.x1, y5 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset2(item) - Math.round(0.8 * h2), tl2 = textLines(item), w2;
  if (isArray(tl2)) {
    h2 += lineHeight(item) * (tl2.length - 1);
    w2 = tl2.reduce((w3, t) => Math.max(w3, textMetrics.width(item, t)), 0);
  } else {
    w2 = textMetrics.width(item, tl2);
  }
  if (a2 === "center") {
    dx -= w2 / 2;
  } else if (a2 === "right") {
    dx -= w2;
  } else
    ;
  bounds2.set(dx += x5, dy += y5, dx + w2, dy + h2);
  if (item.angle && !mode) {
    bounds2.rotate(item.angle * DegToRad, x5, y5);
  } else if (mode === 2) {
    return bounds2.rotatedPoints(item.angle * DegToRad, x5, y5);
  }
  return bounds2;
}
function draw(context3, scene, bounds2) {
  visit(scene, (item) => {
    var opacity = item.opacity == null ? 1 : item.opacity, p, x5, y5, i, lh, tl2, str;
    if (bounds2 && !bounds2.intersects(item.bounds) || opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context3.font = font(item);
    context3.textAlign = item.align || "left";
    p = anchorPoint(item);
    x5 = p.x1, y5 = p.y1;
    if (item.angle) {
      context3.save();
      context3.translate(x5, y5);
      context3.rotate(item.angle * DegToRad);
      x5 = y5 = 0;
    }
    x5 += item.dx || 0;
    y5 += (item.dy || 0) + offset2(item);
    tl2 = textLines(item);
    blend(context3, item);
    if (isArray(tl2)) {
      lh = lineHeight(item);
      for (i = 0; i < tl2.length; ++i) {
        str = textValue(item, tl2[i]);
        if (item.fill && fill(context3, item, opacity)) {
          context3.fillText(str, x5, y5);
        }
        if (item.stroke && stroke(context3, item, opacity)) {
          context3.strokeText(str, x5, y5);
        }
        y5 += lh;
      }
    } else {
      str = textValue(item, tl2);
      if (item.fill && fill(context3, item, opacity)) {
        context3.fillText(str, x5, y5);
      }
      if (item.stroke && stroke(context3, item, opacity)) {
        context3.strokeText(str, x5, y5);
      }
    }
    if (item.angle)
      context3.restore();
  });
}
function hit(context3, item, x5, y5, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint(item), ax = p.x1, ay = p.y1, b2 = bound(tempBounds, item, 1), a2 = -item.angle * DegToRad, cos4 = Math.cos(a2), sin4 = Math.sin(a2), px2 = cos4 * gx - sin4 * gy + (ax - cos4 * ax + sin4 * ay), py2 = sin4 * gx + cos4 * gy + (ay - sin4 * ax - cos4 * ay);
  return b2.contains(px2, py2);
}
function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}
var text = {
  type: "text",
  tag: "text",
  nested: false,
  attr,
  bound,
  draw,
  pick: pick$1(hit),
  isect: intersectText
};
var trail = markMultiItemPath("trail", trail$1, pickTrail);
var Marks = {
  arc,
  area,
  group,
  image,
  line,
  path: path$2,
  rect,
  rule,
  shape,
  symbol,
  text,
  trail
};
function boundItem(item, func, opt) {
  var type2 = Marks[item.mark.marktype], bound2 = func || type2.bound;
  if (type2.nested)
    item = item.mark;
  return bound2(item.bounds || (item.bounds = new Bounds()), item, opt);
}
var DUMMY = {
  mark: null
};
function boundMark(mark, bounds2, opt) {
  var type2 = Marks[mark.marktype], bound2 = type2.bound, items = mark.items, hasItems = items && items.length, i, n, item, b2;
  if (type2.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      DUMMY.mark = mark;
      item = DUMMY;
    }
    b2 = boundItem(item, bound2, opt);
    bounds2 = bounds2 && bounds2.union(b2) || b2;
    return bounds2;
  }
  bounds2 = bounds2 || mark.bounds && mark.bounds.clear() || new Bounds();
  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds2.union(boundItem(items[i], bound2, opt));
    }
  }
  return mark.bounds = bounds2;
}
var keys = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  "strokeDash",
  "strokeDashOffset",
  "strokeForeground",
  "strokeOffset",
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  "cornerRadius",
  "padAngle",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  "url",
  "aspect",
  "smooth",
  "path",
  "scaleX",
  "scaleY",
  "x2",
  "y2",
  "size",
  "shape",
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json2) {
  const scene = typeof json2 === "string" ? JSON.parse(json2) : json2;
  return initialize(scene);
}
function initialize(scene) {
  var type2 = scene.marktype, items = scene.items, parent, i, n;
  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type2 ? "mark" : "group";
      items[i][parent] = scene;
      if (items[i].zindex)
        items[i][parent].zdirty = true;
      if ((type2 || parent) === "group")
        initialize(items[i]);
    }
  }
  if (type2)
    boundMark(scene);
  return scene;
}
function Scenegraph(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON(scene);
  } else {
    this.root = createMark({
      marktype: "group",
      name: "root",
      role: "frame"
    });
    this.root.items = [new GroupItem(this.root)];
  }
}
Scenegraph.prototype = {
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  },
  mark(markdef, group2, index3) {
    group2 = group2 || this.root.items[0];
    const mark = createMark(markdef, group2);
    group2.items[index3] = mark;
    if (mark.zindex)
      mark.group.zdirty = true;
    return mark;
  }
};
function createMark(def2, group2) {
  const mark = {
    bounds: new Bounds(),
    clip: !!def2.clip,
    group: group2,
    interactive: def2.interactive === false ? false : true,
    items: [],
    marktype: def2.marktype,
    name: def2.name || void 0,
    role: def2.role || void 0,
    zindex: def2.zindex || 0
  };
  if (def2.aria != null) {
    mark.aria = def2.aria;
  }
  if (def2.description) {
    mark.description = def2.description;
  }
  return mark;
}
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild(el, index3, tag, ns) {
  var a2 = el.childNodes[index3], b2;
  if (!a2 || a2.tagName.toLowerCase() !== tag.toLowerCase()) {
    b2 = a2 || null;
    a2 = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a2, b2);
  }
  return a2;
}
function domClear(el, index3) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index3)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point6(event2, el) {
  const rect2 = el.getBoundingClientRect();
  return [event2.clientX - rect2.left - (el.clientLeft || 0), event2.clientY - rect2.top - (el.clientTop || 0)];
}
function resolveItem(item, event2, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks[mark.marktype]).tip) {
    p = point6(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
function Handler(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || loader();
  this._tooltip = customTooltip || defaultTooltip;
}
function defaultTooltip(handler, event2, item, value3) {
  handler.element().setAttribute("title", value3 || "");
}
Handler.prototype = {
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  },
  element() {
    return this._el;
  },
  canvas() {
    return this._el && this._el.firstChild;
  },
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  },
  scene(scene) {
    if (!arguments.length)
      return this._scene;
    this._scene = scene;
    return this;
  },
  on() {
  },
  off() {
  },
  _handlerIndex(h2, type2, handler) {
    for (let i = h2 ? h2.length : 0; --i >= 0; ) {
      if (h2[i].type === type2 && (!handler || h2[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  },
  handlers(type2) {
    const h2 = this._handlers, a2 = [];
    if (type2) {
      a2.push(...h2[this.eventName(type2)]);
    } else {
      for (const k in h2) {
        a2.push(...h2[k]);
      }
    }
    return a2;
  },
  eventName(name2) {
    const i = name2.indexOf(".");
    return i < 0 ? name2 : name2.slice(0, i);
  },
  handleHref(event2, item, href2) {
    this._loader.sanitize(href2, {
      context: "href"
    }).then((opt) => {
      const e = new MouseEvent(event2.type, event2), a2 = domCreate(null, "a");
      for (const name2 in opt)
        a2.setAttribute(name2, opt[name2]);
      a2.dispatchEvent(e);
    }).catch(() => {
    });
  },
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event2, this.canvas(), this._origin);
      const value3 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value3);
    }
  },
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el)
      return;
    const rect2 = el.getBoundingClientRect(), origin = this._origin, bounds2 = item.bounds, width2 = bounds2.width(), height2 = bounds2.height();
    let x5 = bounds2.x1 + origin[0] + rect2.left, y5 = bounds2.y1 + origin[1] + rect2.top;
    while (item.mark && (item = item.mark.group)) {
      x5 += item.x || 0;
      y5 += item.y || 0;
    }
    return {
      x: x5,
      y: y5,
      width: width2,
      height: height2,
      left: x5,
      top: y5,
      right: x5 + width2,
      bottom: y5 + height2
    };
  }
};
function Renderer(loader2) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader(loader2);
}
Renderer.prototype = {
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  },
  element() {
    return this._el;
  },
  canvas() {
    return this._el && this._el.firstChild;
  },
  background(bgcolor) {
    if (arguments.length === 0)
      return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  },
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  },
  dirty() {
  },
  render(scene) {
    const r = this;
    r._call = function() {
      r._render(scene);
    };
    r._call();
    r._call = null;
    return r;
  },
  _render() {
  },
  renderAsync(scene) {
    const r = this.render(scene);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  },
  _load(method2, uri) {
    var r = this, p = r._loader[method2](uri);
    if (!r._ready) {
      const call = r._call;
      r._ready = r._loader.ready().then((redraw) => {
        if (redraw)
          call();
        r._ready = null;
      });
    }
    return p;
  },
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  },
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent = "keydown";
var KeyPressEvent = "keypress";
var KeyUpEvent = "keyup";
var DragEnterEvent = "dragenter";
var DragLeaveEvent = "dragleave";
var DragOverEvent = "dragover";
var MouseDownEvent = "mousedown";
var MouseUpEvent = "mouseup";
var MouseMoveEvent = "mousemove";
var MouseOutEvent = "mouseout";
var MouseOverEvent = "mouseover";
var ClickEvent = "click";
var DoubleClickEvent = "dblclick";
var WheelEvent = "wheel";
var MouseWheelEvent = "mousewheel";
var TouchStartEvent = "touchstart";
var TouchMoveEvent = "touchmove";
var TouchEndEvent = "touchend";
var Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
var TooltipShowEvent = MouseMoveEvent;
var TooltipHideEvent = MouseOutEvent;
var HrefEvent = ClickEvent;
function CanvasHandler(loader2, tooltip) {
  Handler.call(this, loader2, tooltip);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}
var eventBundle = (type2) => type2 === TouchStartEvent || type2 === TouchMoveEvent || type2 === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type2];
function eventListenerCheck(handler, type2) {
  eventBundle(type2).forEach((_) => addEventListener(handler, _));
}
function addEventListener(handler, type2) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type2]) {
    handler._events[type2] = 1;
    canvas.addEventListener(type2, handler[type2] ? (evt) => handler[type2](evt) : (evt) => handler.fire(type2, evt));
  }
}
function move(moveEvent, overEvent, outEvent) {
  return function(evt) {
    const a2 = this._active, p = this.pickEvent(evt);
    if (p === a2) {
      this.fire(moveEvent, evt);
    } else {
      if (!a2 || !a2.exit) {
        this.fire(outEvent, evt);
      }
      this._active = p;
      this.fire(overEvent, evt);
      this.fire(moveEvent, evt);
    }
  };
}
function inactive(type2) {
  return function(evt) {
    this.fire(type2, evt);
    this._active = null;
  };
}
inherits(CanvasHandler, Handler, {
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, "canvas");
    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach((type2) => eventListenerCheck(this, type2));
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._canvas.getContext("2d");
  },
  events: Events,
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  },
  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
  mouseout: inactive(MouseOutEvent),
  dragleave: inactive(DragLeaveEvent),
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  },
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  },
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent, evt, true);
  },
  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  },
  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  },
  fire(type2, evt, touch2) {
    const a2 = touch2 ? this._touch : this._active, h2 = this._handlers[type2];
    evt.vegaType = type2;
    if (type2 === HrefEvent && a2 && a2.href) {
      this.handleHref(evt, a2, a2.href);
    } else if (type2 === TooltipShowEvent || type2 === TooltipHideEvent) {
      this.handleTooltip(evt, a2, type2 !== TooltipHideEvent);
    }
    if (h2) {
      for (let i = 0, len = h2.length; i < len; ++i) {
        h2[i].handler.call(this._obj, evt, a2);
      }
    }
  },
  on(type2, handler) {
    const name2 = this.eventName(type2), h2 = this._handlers, i = this._handlerIndex(h2[name2], type2, handler);
    if (i < 0) {
      eventListenerCheck(this, type2);
      (h2[name2] || (h2[name2] = [])).push({
        type: type2,
        handler
      });
    }
    return this;
  },
  off(type2, handler) {
    const name2 = this.eventName(type2), h2 = this._handlers[name2], i = this._handlerIndex(h2, type2, handler);
    if (i >= 0) {
      h2.splice(i, 1);
    }
    return this;
  },
  pickEvent(evt) {
    const p = point6(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  },
  pick(scene, x5, y5, gx, gy) {
    const g = this.context(), mark = Marks[scene.marktype];
    return mark.pick.call(this, g, scene, x5, y5, gx, gy);
  }
});
function devicePixelRatio() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
var pixelRatio = devicePixelRatio();
function resize(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context3 = canvas.getContext("2d"), ratio = inDOM ? pixelRatio : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key2 in opt) {
    context3[key2] = opt[key2];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context3.pixelRatio = ratio;
  context3.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
function CanvasRenderer(loader2) {
  Renderer.call(this, loader2);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds();
  this._tempb = new Bounds();
}
var base$1 = Renderer.prototype;
var viewBounds = (origin, width2, height2) => new Bounds().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds(g, b2, origin) {
  b2.expand(1).round();
  if (g.pixelRatio % 1) {
    b2.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b2.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b2.x1, b2.y1, b2.width(), b2.height());
  g.clip();
  return b2;
}
inherits(CanvasRenderer, Renderer, {
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return base$1.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  resize(width2, height2, origin, scaleFactor) {
    base$1.resize.call(this, width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx)
        error("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  },
  dirty(item) {
    const b2 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b2.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b2);
  },
  _render(scene) {
    const g = this.context(), o = this._origin, w2 = this._width, h2 = this._height, db = this._dirty, vb = viewBounds(o, w2, h2);
    g.save();
    const b2 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w2, h2);
    this.draw(g, scene, b2);
    g.restore();
    db.clear();
    return this;
  },
  draw(ctx, scene, bounds2) {
    const mark = Marks[scene.marktype];
    if (scene.clip)
      clip(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds2);
    if (scene.clip)
      ctx.restore();
  },
  clear(x5, y5, w2, h2) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x5, y5, w2, h2);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x5, y5, w2, h2);
    }
  }
});
function SVGHandler(loader2, tooltip) {
  Handler.call(this, loader2, tooltip);
  const h2 = this;
  h2._hrefHandler = listener(h2, (evt, item) => {
    if (item && item.href)
      h2.handleHref(evt, item, item.href);
  });
  h2._tooltipHandler = listener(h2, (evt, item) => {
    h2.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
  });
}
var listener = (context3, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context3._obj, evt, item);
};
inherits(SVGHandler, Handler, {
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    this._svg = svg = el && domFind(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },
  canvas() {
    return this._svg;
  },
  on(type2, handler) {
    const name2 = this.eventName(type2), h2 = this._handlers, i = this._handlerIndex(h2[name2], type2, handler);
    if (i < 0) {
      const x5 = {
        type: type2,
        handler,
        listener: listener(this, handler)
      };
      (h2[name2] || (h2[name2] = [])).push(x5);
      if (this._svg) {
        this._svg.addEventListener(name2, x5.listener);
      }
    }
    return this;
  },
  off(type2, handler) {
    const name2 = this.eventName(type2), h2 = this._handlers[name2], i = this._handlerIndex(h2, type2, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name2, h2[i].listener);
      }
      h2.splice(i, 1);
    }
    return this;
  }
});
var ARIA_HIDDEN = "aria-hidden";
var ARIA_LABEL = "aria-label";
var ARIA_ROLE = "role";
var ARIA_ROLEDESCRIPTION = "aria-roledescription";
var GRAPHICS_OBJECT = "graphics-object";
var GRAPHICS_SYMBOL = "graphics-symbol";
var bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || void 0
});
var AriaIgnore = toSet(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides = {
  "axis": {
    desc: "axis",
    caption: axisCaption
  },
  "legend": {
    desc: "legend",
    caption: legendCaption
  },
  "title-text": {
    desc: "title",
    caption: (item) => `Title text '${titleCaption(item)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => `Subtitle text '${titleCaption(item)}'`
  }
};
var AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit2, item) {
  const hide = item.aria === false;
  emit2(ARIA_HIDDEN, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit2(AriaEncode[prop], void 0);
    }
  } else {
    const type2 = item.mark.marktype;
    emit2(ARIA_LABEL, item.description);
    emit2(ARIA_ROLE, item.ariaRole || (type2 === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit2(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type2} mark`);
  }
}
function ariaMarkAttributes(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
}
function ariaMark(mark) {
  const type2 = mark.marktype;
  const recurse2 = type2 === "group" || type2 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle(recurse2 ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type2} mark container`, mark.description);
}
function ariaGuide(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption(item) {
  return array(item.text).join(" ");
}
function axisCaption(item) {
  const datum2 = item.datum, orient2 = item.orient, title = datum2.title ? extractTitle(item) : null, ctx = item.context, scale6 = ctx.scales[datum2.scale].value, locale4 = ctx.dataflow.locale(), type2 = scale6.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title ? ` titled '${title}'` : "") + ` for a ${isDiscrete(type2) ? "discrete" : type2} scale with ${domainCaption(locale4, scale6, item)}`;
}
function legendCaption(item) {
  const datum2 = item.datum, title = datum2.title ? extractTitle(item) : null, type2 = `${datum2.type || ""} legend`.trim(), scales2 = datum2.scales, props = Object.keys(scales2), ctx = item.context, scale6 = ctx.scales[scales2[props[0]]].value, locale4 = ctx.dataflow.locale();
  return capitalize(type2) + (title ? ` titled '${title}'` : "") + ` for ${channelCaption(props)} with ${domainCaption(locale4, scale6, item)}`;
}
function extractTitle(item) {
  try {
    return array(peek(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek(props);
}
function capitalize(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}
var innerText = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText = (val) => innerText(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup() {
  let buf = "", outer = "", inner = "";
  const stack = [], clear = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear();
    }
    stack.push(tag);
  }, attr2 = (name2, value3) => {
    if (value3 != null)
      outer += ` ${name2}="${attrText(value3)}"`;
    return m2;
  }, m2 = {
    open(tag, ...attrs) {
      push(tag);
      outer = "<" + tag;
      for (const set5 of attrs) {
        for (const key2 in set5)
          attr2(key2, set5[key2]);
      }
      return m2;
    },
    close() {
      const tag = stack.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear();
      return m2;
    },
    attr: attr2,
    text: (t) => (inner += innerText(t), m2),
    toString: () => buf
  };
  return m2;
}
var serializeXML = (node) => _serialize(markup(), node) + "";
function _serialize(m2, node) {
  m2.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m2.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children3 = node.childNodes, n = children3.length;
    for (let i = 0; i < n; i++) {
      const child = children3[i];
      child.nodeType === 3 ? m2.text(child.nodeValue) : _serialize(m2, child);
    }
  }
  return m2.close();
}
var styles = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity",
  blend: "mix-blend-mode"
};
var rootAttributes = {
  "fill": "none",
  "stroke-miterlimit": 10
};
var RootIndex = 0;
var xmlns = "http://www.w3.org/2000/xmlns/";
var svgns = metadata.xmlns;
function SVGRenderer(loader2) {
  Renderer.call(this, loader2);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
var base = Renderer.prototype;
inherits(SVGRenderer, Renderer, {
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild(el, 0, "svg", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata["version"]);
      this._svg.setAttribute("class", "marks");
      domClear(el, 1);
      this._root = domChild(this._svg, RootIndex, "g", svgns);
      setAttributes(this._root, rootAttributes);
      domClear(this._svg, RootIndex + 1);
    }
    this.background(this._bgcolor);
    return base.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return base.background.apply(this, arguments);
  },
  resize(width2, height2, origin, scaleFactor) {
    base.resize.call(this, width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute("transform", `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  },
  canvas() {
    return this._svg;
  },
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg)
      return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild(svg, RootIndex, "rect", svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text2 = serializeXML(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text2;
  },
  _render(scene) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll)
        this._clearDefs();
      this.mark(this._root, scene);
      domClear(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  },
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  },
  isDirty(item) {
    return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;
  },
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID)
      return true;
    const id2 = ++this._dirtyID;
    let item, mark, type2, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;
      if (mark.marktype !== type2) {
        type2 = mark.marktype;
        mdef = Marks[type2];
      }
      if (mark.zdirty && mark.dirty !== id2) {
        this._dirtyAll = false;
        dirtyParents(item, id2);
        mark.items.forEach((i2) => {
          i2.dirty = id2;
        });
      }
      if (mark.zdirty)
        continue;
      if (item.exit) {
        if (mdef.nested && mark.items.length) {
          o = mark.items[0];
          if (o._svg)
            this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o)
            o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id2)
        continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents(item, id2);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id2;
    }
    return !this._dirtyAll;
  },
  mark(el, scene, prev) {
    if (!this.isDirty(scene))
      return scene._svg;
    const svg = this._svg, mdef = Marks[scene.marktype], events3 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    let sibling = null, i = 0;
    const parent = bind(scene, el, prev, "g", svg);
    parent.setAttribute("class", cssClass(scene));
    const aria = ariaMarkAttributes(scene);
    for (const key2 in aria)
      setAttribute(parent, key2, aria[key2]);
    if (!isGroup) {
      setAttribute(parent, "pointer-events", events3);
    }
    setAttribute(parent, "clip-path", scene.clip ? clip$1(this, scene, scene.group) : null);
    const process = (item) => {
      const dirty = this.isDirty(item), node = bind(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup)
          recurse(this, node, item);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length)
        process(scene.items[0]);
    } else {
      visit(scene, process);
    }
    domClear(parent, i);
    return parent;
  },
  _update(mdef, el, item) {
    element = el;
    values = el.__values__;
    ariaItemAttributes(emit, item);
    mdef.attr(emit, item, this);
    const extra = mark_extras[mdef.type];
    if (extra)
      extra.call(this, mdef, el, item);
    if (element)
      this.style(element, item);
  },
  style(el, item) {
    if (item == null)
      return;
    for (const prop in styles) {
      let value3 = prop === "font" ? fontFamily(item) : item[prop];
      if (value3 === values[prop])
        continue;
      const name2 = styles[prop];
      if (value3 == null) {
        el.removeAttribute(name2);
      } else {
        if (isGradient(value3)) {
          value3 = gradientRef(value3, this._defs.gradient, href());
        }
        el.setAttribute(name2, value3 + "");
      }
      values[prop] = value3;
    }
  },
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index3 = 0;
    for (const id2 in defs.gradient) {
      if (!el)
        defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index3 = updateGradient(el, defs.gradient[id2], index3);
    }
    for (const id2 in defs.clipping) {
      if (!el)
        defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index3 = updateClipping(el, defs.clipping[id2], index3);
    }
    if (el) {
      index3 === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index3);
    }
  },
  _clearDefs() {
    const def2 = this._defs;
    def2.gradient = {};
    def2.clipping = {};
  }
});
function dirtyParents(item, id2) {
  for (; item && item.dirty !== id2; item = item.mark.group) {
    item.dirty = id2;
    if (item.mark && item.mark.dirty !== id2) {
      item.mark.dirty = id2;
    } else
      return;
  }
}
function updateGradient(el, grad, index3) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild(el, index3++, "pattern", svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild(pt, 0, "rect", svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index3++, "radialGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index3++, "linearGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild(el, i, "stop", svgns);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear(el, i);
  return index3;
}
function updateClipping(el, clip3, index3) {
  let mask;
  el = domChild(el, index3, "clipPath", svgns);
  el.setAttribute("id", clip3.id);
  if (clip3.path) {
    mask = domChild(el, 0, "path", svgns);
    mask.setAttribute("d", clip3.path);
  } else {
    mask = domChild(el, 0, "rect", svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip3.width,
      height: clip3.height
    });
  }
  domClear(el, 1);
  return index3 + 1;
}
function recurse(renderer, el, group2) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit(group2, (item) => {
    prev = renderer.mark(el, item, prev);
    ++idx;
  });
  domClear(el, 1 + idx);
}
function bind(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate(doc, "path", svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, "g", svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, "path", svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element = null;
var values = null;
var mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__;
    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value3 = item.mark.interactive === false ? "none" : null;
    if (value3 !== values.events) {
      setAttribute(fg, "pointer-events", value3);
      setAttribute(bg, "pointer-events", value3);
      values.events = value3;
    }
    if (item.strokeForeground && item.stroke) {
      const fill2 = item.fill;
      setAttribute(fg, "display", null);
      this.style(bg, item);
      setAttribute(bg, "stroke", null);
      if (fill2)
        item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill2)
        item.fill = fill2;
      element = null;
    } else {
      setAttribute(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, "image-rendering", "optimizeSpeed");
      setStyle(el, "image-rendering", "pixelated");
    } else {
      setStyle(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl2 = textLines(item);
    let key2, value3, doc, lh;
    if (isArray(tl2)) {
      value3 = tl2.map((_) => textValue(item, _));
      key2 = value3.join("\n");
      if (key2 !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value3.forEach((t, i) => {
          const ts2 = domCreate(doc, "tspan", svgns);
          ts2.__data__ = item;
          ts2.textContent = t;
          if (i) {
            ts2.setAttribute("x", 0);
            ts2.setAttribute("dy", lh);
          }
          el.appendChild(ts2);
        });
        values.text = key2;
      }
    } else {
      value3 = textValue(item, tl2);
      if (value3 !== values.text) {
        el.textContent = value3;
        values.text = value3;
      }
    }
    setAttribute(el, "font-family", fontFamily(item));
    setAttribute(el, "font-size", fontSize(item) + "px");
    setAttribute(el, "font-style", item.fontStyle);
    setAttribute(el, "font-variant", item.fontVariant);
    setAttribute(el, "font-weight", item.fontWeight);
  }
};
function emit(name2, value3, ns) {
  if (value3 === values[name2])
    return;
  if (ns) {
    setAttributeNS(element, name2, value3, ns);
  } else {
    setAttribute(element, name2, value3);
  }
  values[name2] = value3;
}
function setStyle(el, name2, value3) {
  if (value3 !== values[name2]) {
    if (value3 == null) {
      el.style.removeProperty(name2);
    } else {
      el.style.setProperty(name2, value3 + "");
    }
    values[name2] = value3;
  }
}
function setAttributes(el, attrs) {
  for (const key2 in attrs) {
    setAttribute(el, key2, attrs[key2]);
  }
}
function setAttribute(el, name2, value3) {
  if (value3 != null) {
    el.setAttribute(name2, value3);
  } else {
    el.removeAttribute(name2);
  }
}
function setAttributeNS(el, name2, value3, ns) {
  if (value3 != null) {
    el.setAttributeNS(ns, name2, value3);
  } else {
    el.removeAttributeNS(ns, name2);
  }
}
function href() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
function SVGStringRenderer(loader2) {
  Renderer.call(this, loader2);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
inherits(SVGStringRenderer, Renderer, {
  svg() {
    return this._text;
  },
  _render(scene) {
    const m2 = markup();
    m2.open("svg", extend({}, metadata, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m2.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m2.open("g", rootAttributes, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m2, scene);
    m2.close();
    this.defs(m2);
    this._text = m2.close() + "";
    return this;
  },
  mark(m2, scene) {
    const mdef = Marks[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes, mdef.attr];
    m2.open("g", {
      "class": cssClass(scene),
      "clip-path": scene.clip ? clip$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process = (item) => {
      const href2 = this.href(item);
      if (href2)
        m2.open("a", href2);
      m2.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl2 = textLines(item);
        if (isArray(tl2)) {
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };
          for (let i = 0; i < tl2.length; ++i) {
            m2.open("tspan", i ? attrs : null).text(textValue(item, tl2[i])).close();
          }
        } else {
          m2.text(textValue(item, tl2));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill2 = item.fill, stroke2 = item.stroke;
        if (fore && stroke2) {
          item.stroke = null;
        }
        m2.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m2.open("g", this.attr(scene, item, mdef.content));
        visit(item, (scene2) => this.mark(m2, scene2));
        m2.close();
        if (fore && stroke2) {
          if (fill2)
            item.fill = null;
          item.stroke = stroke2;
          m2.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill2)
            item.fill = fill2;
        } else {
          m2.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m2.close();
      if (href2)
        m2.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length)
        process(scene.items[0]);
    } else {
      visit(scene, process);
    }
    return m2.close();
  },
  href(item) {
    const href2 = item.href;
    let attr2;
    if (href2) {
      if (attr2 = this._hrefs && this._hrefs[href2]) {
        return attr2;
      } else {
        this.sanitizeURL(href2).then((attr3) => {
          attr3["xlink:href"] = attr3.href;
          attr3.href = null;
          (this._hrefs || (this._hrefs = {}))[href2] = attr3;
        });
      }
    }
    return null;
  },
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit2 = (name2, value3, ns, prefixed) => {
      object2[prefixed || name2] = value3;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit2, item, this));
    } else {
      attrs(emit2, item, this);
    }
    if (tag) {
      style(object2, item, scene, tag, this._defs);
    }
    return object2;
  },
  defs(m2) {
    const gradient3 = this._defs.gradient, clipping = this._defs.clipping, count2 = Object.keys(gradient3).length + Object.keys(clipping).length;
    if (count2 === 0)
      return;
    m2.open("defs");
    for (const id2 in gradient3) {
      const def2 = gradient3[id2], stops = def2.stops;
      if (def2.gradient === "radial") {
        m2.open("pattern", {
          id: patternPrefix + id2,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m2.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id2 + ")"
        }).close();
        m2.close();
        m2.open("radialGradient", {
          id: id2,
          fx: def2.x1,
          fy: def2.y1,
          fr: def2.r1,
          cx: def2.x2,
          cy: def2.y2,
          r: def2.r2
        });
      } else {
        m2.open("linearGradient", {
          id: id2,
          x1: def2.x1,
          x2: def2.x2,
          y1: def2.y1,
          y2: def2.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m2.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m2.close();
    }
    for (const id2 in clipping) {
      const def2 = clipping[id2];
      m2.open("clipPath", {
        id: id2
      });
      if (def2.path) {
        m2.open("path", {
          d: def2.path
        }).close();
      } else {
        m2.open("rect", {
          x: 0,
          y: 0,
          width: def2.width,
          height: def2.height
        }).close();
      }
      m2.close();
    }
    m2.close();
  }
});
function style(s, item, scene, tag, defs) {
  if (item == null)
    return s;
  if (tag === "bgrect" && scene.interactive === false) {
    s["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s["pointer-events"] = "none";
    }
    s.display = "none";
    if (item.fill !== null)
      return s;
  }
  if (tag === "image" && item.smooth === false) {
    s.style = "image-rendering: optimizeSpeed; image-rendering: pixelated;";
  }
  if (tag === "text") {
    s["font-family"] = fontFamily(item);
    s["font-size"] = fontSize(item) + "px";
    s["font-style"] = item.fontStyle;
    s["font-variant"] = item.fontVariant;
    s["font-weight"] = item.fontWeight;
  }
  for (const prop in styles) {
    let value3 = item[prop];
    const name2 = styles[prop];
    if (value3 === "transparent" && (name2 === "fill" || name2 === "stroke"))
      ;
    else if (value3 != null) {
      if (isGradient(value3)) {
        value3 = gradientRef(value3, defs.gradient, "");
      }
      s[name2] = value3;
    }
  }
  return s;
}
var Canvas = "canvas";
var PNG = "png";
var SVG = "svg";
var None2 = "none";
var RenderType = {
  Canvas,
  PNG,
  SVG,
  None: None2
};
var modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[None2] = {};
function renderModule(name2, _) {
  name2 = String(name2 || "").toLowerCase();
  if (arguments.length > 1) {
    modules[name2] = _;
    return this;
  } else {
    return modules[name2];
  }
}
function intersect2(scene, bounds2, filter3) {
  const hits = [], box = new Bounds().union(bounds2), type2 = scene.marktype;
  return type2 ? intersectMark(scene, box, filter3, hits) : type2 === "group" ? intersectGroup(scene, box, filter3, hits) : error("Intersect scene must be mark node or group item.");
}
function intersectMark(mark, box, filter3, hits) {
  if (visitMark(mark, box, filter3)) {
    const items = mark.items, type2 = mark.marktype, n = items.length;
    let i = 0;
    if (type2 === "group") {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter3, hits);
      }
    } else {
      for (const test2 = Marks[type2].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test2))
          hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark(mark, box, filter3) {
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === "group" || mark.interactive !== false && (!filter3 || filter3(mark)));
}
function intersectGroup(group2, box, filter3, hits) {
  if (filter3 && filter3(group2.mark) && intersectItem(group2, box, Marks.group.isect)) {
    hits.push(group2);
  }
  const marks = group2.items, n = marks && marks.length;
  if (n) {
    const x5 = group2.x || 0, y5 = group2.y || 0;
    box.translate(-x5, -y5);
    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter3, hits);
    }
    box.translate(x5, y5);
  }
  return hits;
}
function intersectItem(item, box, test2) {
  const bounds2 = item.bounds;
  return box.encloses(bounds2) || box.intersects(bounds2) && test2(item, box);
}
var clipBounds = new Bounds();
function boundClip(mark) {
  const clip3 = mark.clip;
  if (isFunction(clip3)) {
    clip3(boundContext(clipBounds.clear()));
  } else if (clip3) {
    clipBounds.set(0, 0, mark.group.width, mark.group.height);
  } else
    return;
  mark.bounds.intersect(clipBounds);
}
var TOLERANCE = 1e-9;
function sceneEqual(a2, b2, key2) {
  return a2 === b2 ? true : key2 === "path" ? pathEqual(a2, b2) : a2 instanceof Date && b2 instanceof Date ? +a2 === +b2 : isNumber(a2) && isNumber(b2) ? Math.abs(a2 - b2) <= TOLERANCE : !a2 || !b2 || !isObject(a2) && !isObject(b2) ? a2 == b2 : objectEqual(a2, b2);
}
function pathEqual(a2, b2) {
  return sceneEqual(pathParse(a2), pathParse(b2));
}
function objectEqual(a2, b2) {
  var ka = Object.keys(a2), kb = Object.keys(b2), key2, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key2 = ka[i];
    if (!sceneEqual(a2[key2], b2[key2], key2))
      return false;
  }
  return typeof a2 === typeof b2;
}
function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}

// node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var Top = "top";
var Left = "left";
var Right = "right";
var Bottom = "bottom";
var TopLeft = "top-left";
var TopRight = "top-right";
var BottomLeft = "bottom-left";
var BottomRight = "bottom-right";
var Start = "start";
var Middle = "middle";
var End = "end";
var X = "x";
var Y = "y";
var Group = "group";
var AxisRole = "axis";
var TitleRole = "title";
var FrameRole = "frame";
var ScopeRole = "scope";
var LegendRole = "legend";
var RowHeader = "row-header";
var RowFooter = "row-footer";
var RowTitle = "row-title";
var ColHeader = "column-header";
var ColFooter = "column-footer";
var ColTitle = "column-title";
var Padding = "padding";
var Symbols = "symbol";
var Fit = "fit";
var FitX = "fit-x";
var FitY = "fit-y";
var Pad = "pad";
var None3 = "none";
var All = "all";
var Each = "each";
var Flush = "flush";
var Column = "column";
var Row = "row";
function Bound(params2) {
  Transform.call(this, null, params2);
}
inherits(Bound, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow, mark = _.mark, type2 = mark.marktype, entry2 = Marks[type2], bound2 = entry2.bound;
    let markBounds = mark.bounds, rebound;
    if (entry2.nested) {
      if (mark.items.length)
        view.dirty(mark.items[0]);
      markBounds = boundItem2(mark, bound2);
      mark.items.forEach((item) => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type2 === Group || _.modified()) {
      pulse2.visit(pulse2.MOD, (item) => view.dirty(item));
      markBounds.clear();
      mark.items.forEach((item) => markBounds.union(boundItem2(item, bound2)));
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse2.reflow();
      }
    } else {
      rebound = pulse2.changed(pulse2.REM);
      pulse2.visit(pulse2.ADD, (item) => {
        markBounds.union(boundItem2(item, bound2));
      });
      pulse2.visit(pulse2.MOD, (item) => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem2(item, bound2));
      });
      if (rebound) {
        markBounds.clear();
        mark.items.forEach((item) => markBounds.union(item.bounds));
      }
    }
    boundClip(mark);
    return pulse2.modifies("bounds");
  }
});
function boundItem2(item, bound2, opt) {
  return bound2(item.bounds.clear(), item, opt);
}
var COUNTER_NAME = ":vega_identifier:";
function Identifier(params2) {
  Transform.call(this, 0, params2);
}
Identifier.Definition = {
  "type": "Identifier",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "as",
    "type": "string",
    "required": true
  }]
};
inherits(Identifier, Transform, {
  transform(_, pulse2) {
    const counter = getCounter(pulse2.dataflow), as = _.as;
    let id2 = counter.value;
    pulse2.visit(pulse2.ADD, (t) => t[as] = t[as] || ++id2);
    counter.set(this.value = id2);
    return pulse2;
  }
});
function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}
function Mark(params2) {
  Transform.call(this, null, params2);
}
inherits(Mark, Transform, {
  transform(_, pulse2) {
    let mark = this.value;
    if (!mark) {
      mark = pulse2.dataflow.scenegraph().mark(_.markdef, lookup2(_), _.index);
      mark.group.context = _.context;
      if (!_.context.group)
        _.context.group = mark.group;
      mark.source = this.source;
      mark.clip = _.clip;
      mark.interactive = _.interactive;
      this.value = mark;
    }
    const Init = mark.marktype === Group ? GroupItem : Item;
    pulse2.visit(pulse2.ADD, (item) => Init.call(item, mark));
    if (_.modified("clip") || _.modified("interactive")) {
      mark.clip = _.clip;
      mark.interactive = !!_.interactive;
      mark.zdirty = true;
      pulse2.reflow();
    }
    mark.items = pulse2.source;
    return pulse2;
  }
});
function lookup2(_) {
  const g = _.groups, p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}
function Overlap(params2) {
  Transform.call(this, null, params2);
}
var methods = {
  parity: (items) => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a2;
    return items.filter((b2, i) => !i || !intersect3(a2.bounds, b2.bounds, sep) ? (a2 = b2, 1) : b2.opacity = 0);
  }
};
var intersect3 = (a2, b2, sep) => sep > Math.max(b2.x1 - a2.x2, a2.x1 - b2.x2, b2.y1 - a2.y2, a2.y1 - b2.y2);
var hasOverlap = (items, pad4) => {
  for (var i = 1, n = items.length, a2 = items[0].bounds, b2; i < n; a2 = b2, ++i) {
    if (intersect3(a2, b2 = items[i].bounds, pad4))
      return true;
  }
};
var hasBounds = (item) => {
  const b2 = item.bounds;
  return b2.width() > 1 && b2.height() > 1;
};
var boundTest = (scale6, orient2, tolerance) => {
  var range4 = scale6.range(), b2 = new Bounds();
  if (orient2 === Top || orient2 === Bottom) {
    b2.set(range4[0], -Infinity, range4[1], Infinity);
  } else {
    b2.set(-Infinity, range4[0], Infinity, range4[1]);
  }
  b2.expand(tolerance || 1);
  return (item) => b2.encloses(item.bounds);
};
var reset = (source3) => {
  source3.forEach((item) => item.opacity = 1);
  return source3;
};
var reflow = (pulse2, _) => pulse2.reflow(_.modified()).modifies("opacity");
inherits(Overlap, Transform, {
  transform(_, pulse2) {
    const reduce = methods[_.method] || methods.parity, sep = _.separation || 0;
    let source3 = pulse2.materialize(pulse2.SOURCE).source, items, test2;
    if (!source3 || !source3.length)
      return;
    if (!_.method) {
      if (_.modified("method")) {
        reset(source3);
        pulse2 = reflow(pulse2, _);
      }
      return pulse2;
    }
    source3 = source3.filter(hasBounds);
    if (!source3.length)
      return;
    if (_.sort) {
      source3 = source3.slice().sort(_.sort);
    }
    items = reset(source3);
    pulse2 = reflow(pulse2, _);
    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));
      if (items.length < 3 && !peek(source3).opacity) {
        if (items.length > 1)
          peek(items).opacity = 0;
        peek(source3).opacity = 1;
      }
    }
    if (_.boundScale && _.boundTolerance >= 0) {
      test2 = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source3.forEach((item) => {
        if (!test2(item))
          item.opacity = 0;
      });
    }
    const bounds2 = items[0].mark.bounds.clear();
    source3.forEach((item) => {
      if (item.opacity)
        bounds2.union(item.bounds);
    });
    return pulse2;
  }
});
function Render(params2) {
  Transform.call(this, null, params2);
}
inherits(Render, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    pulse2.visit(pulse2.ALL, (item) => view.dirty(item));
    if (pulse2.fields && pulse2.fields["zindex"]) {
      const item = pulse2.source && pulse2.source[0];
      if (item)
        item.mark.zdirty = true;
    }
  }
});
var tempBounds2 = new Bounds();
function set2(item, property2, value3) {
  return item[property2] === value3 ? 0 : (item[property2] = value3, 1);
}
function isYAxis(mark) {
  var orient2 = mark.items[0].orient;
  return orient2 === Left || orient2 === Right;
}
function axisIndices(datum2) {
  let index3 = +datum2.grid;
  return [
    datum2.ticks ? index3++ : -1,
    datum2.labels ? index3++ : -1,
    index3 + +datum2.domain
  ];
}
function axisLayout(view, axis, width2, height2) {
  var item = axis.items[0], datum2 = item.datum, delta = item.translate != null ? item.translate : 0.5, orient2 = item.orient, indices = axisIndices(datum2), range4 = item.range, offset4 = item.offset, position2 = item.position, minExtent = item.minExtent, maxExtent = item.maxExtent, title = datum2.title && item.items[indices[2]].items[0], titlePadding = item.titlePadding, bounds2 = item.bounds, dl = title && multiLineOffset(title), x5 = 0, y5 = 0, i, s;
  tempBounds2.clear().union(bounds2);
  bounds2.clear();
  if ((i = indices[0]) > -1)
    bounds2.union(item.items[i].bounds);
  if ((i = indices[1]) > -1)
    bounds2.union(item.items[i].bounds);
  switch (orient2) {
    case Top:
      x5 = position2 || 0;
      y5 = -offset4;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.y1));
      bounds2.add(0, -s).add(range4, 0);
      if (title)
        axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds2);
      break;
    case Left:
      x5 = -offset4;
      y5 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.x1));
      bounds2.add(-s, 0).add(0, range4);
      if (title)
        axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds2);
      break;
    case Right:
      x5 = width2 + offset4;
      y5 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.x2));
      bounds2.add(0, 0).add(s, range4);
      if (title)
        axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds2);
      break;
    case Bottom:
      x5 = position2 || 0;
      y5 = height2 + offset4;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.y2));
      bounds2.add(0, 0).add(range4, s);
      if (title)
        axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds2);
      break;
    default:
      x5 = item.x;
      y5 = item.y;
  }
  boundStroke(bounds2.translate(x5, y5), item);
  if (set2(item, "x", x5 + delta) | set2(item, "y", y5 + delta)) {
    item.bounds = tempBounds2;
    view.dirty(item);
    item.bounds = bounds2;
    view.dirty(item);
  }
  return item.mark.bounds.clear().union(bounds2);
}
function axisTitleLayout(view, title, offset4, pad4, dl, isYAxis2, sign3, bounds2) {
  const b2 = title.bounds;
  if (title.auto) {
    const v = sign3 * (offset4 + dl + pad4);
    let dx = 0, dy = 0;
    view.dirty(title);
    isYAxis2 ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);
    title.mark.bounds.clear().union(b2.translate(-dx, -dy));
    view.dirty(title);
  }
  bounds2.union(b2);
}
var min3 = (a2, b2) => Math.floor(Math.min(a2, b2));
var max3 = (a2, b2) => Math.ceil(Math.max(a2, b2));
function gridLayoutGroups(group2) {
  var groups = group2.items, n = groups.length, i = 0, mark, items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i) {
    mark = groups[i];
    items = mark.items;
    if (mark.marktype === Group) {
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;
        case RowHeader:
          views.rowheaders.push(...items);
          break;
        case RowFooter:
          views.rowfooters.push(...items);
          break;
        case ColHeader:
          views.colheaders.push(...items);
          break;
        case ColFooter:
          views.colfooters.push(...items);
          break;
        case RowTitle:
          views.rowtitle = items[0];
          break;
        case ColTitle:
          views.coltitle = items[0];
          break;
        default:
          views.marks.push(...items);
      }
    }
  }
  return views;
}
function bboxFlush(item) {
  return new Bounds().set(0, 0, item.width || 0, item.height || 0);
}
function bboxFull(item) {
  const b2 = item.bounds.clone();
  return b2.empty() ? b2.set(0, 0, 0, 0) : b2.translate(-(item.x || 0), -(item.y || 0));
}
function get4(opt, key2, d) {
  const v = isObject(opt) ? opt[key2] : opt;
  return v != null ? v : d !== void 0 ? d : 0;
}
function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}
function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty, bbox = opt.bounds === Flush ? bboxFlush : bboxFull, bounds2 = tempBounds2.set(0, 0, 0, 0), alignCol = get4(opt.align, Column), alignRow = get4(opt.align, Row), padCol = get4(opt.padding, Column), padRow = get4(opt.padding, Row), ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), n = groups.length, xOffset = Array(n), xExtent = Array(ncols), xMax = 0, yOffset = Array(n), yExtent = Array(nrows), yMax = 0, dx = Array(n), dy = Array(n), boxes = Array(n), m2, i, c2, r, b2, g, px2, py2, x5, y5, offset4;
  for (i = 0; i < ncols; ++i)
    xExtent[i] = 0;
  for (i = 0; i < nrows; ++i)
    yExtent[i] = 0;
  for (i = 0; i < n; ++i) {
    g = groups[i];
    b2 = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c2 = i % ncols;
    r = ~~(i / ncols);
    xMax = Math.max(xMax, px2 = Math.ceil(b2.x2));
    yMax = Math.max(yMax, py2 = Math.ceil(b2.y2));
    xExtent[c2] = Math.max(xExtent[c2], px2);
    yExtent[r] = Math.max(yExtent[r], py2);
    xOffset[i] = padCol + offsetValue(b2.x1);
    yOffset[i] = padRow + offsetValue(b2.y1);
    if (dirty)
      view.dirty(groups[i]);
  }
  for (i = 0; i < n; ++i) {
    if (i % ncols === 0)
      xOffset[i] = 0;
    if (i < ncols)
      yOffset[i] = 0;
  }
  if (alignCol === Each) {
    for (c2 = 1; c2 < ncols; ++c2) {
      for (offset4 = 0, i = c2; i < n; i += ncols) {
        if (offset4 < xOffset[i])
          offset4 = xOffset[i];
      }
      for (i = c2; i < n; i += ncols) {
        xOffset[i] = offset4 + xExtent[c2 - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset4 = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset4 < xOffset[i])
        offset4 = xOffset[i];
    }
    for (i = 0; i < n; ++i) {
      if (i % ncols)
        xOffset[i] = offset4 + xMax;
    }
  } else {
    for (alignCol = false, c2 = 1; c2 < ncols; ++c2) {
      for (i = c2; i < n; i += ncols) {
        xOffset[i] += xExtent[c2 - 1];
      }
    }
  }
  if (alignRow === Each) {
    for (r = 1; r < nrows; ++r) {
      for (offset4 = 0, i = r * ncols, m2 = i + ncols; i < m2; ++i) {
        if (offset4 < yOffset[i])
          offset4 = yOffset[i];
      }
      for (i = r * ncols; i < m2; ++i) {
        yOffset[i] = offset4 + yExtent[r - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset4 = 0, i = ncols; i < n; ++i) {
      if (offset4 < yOffset[i])
        offset4 = yOffset[i];
    }
    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset4 + yMax;
    }
  } else {
    for (alignRow = false, r = 1; r < nrows; ++r) {
      for (i = r * ncols, m2 = i + ncols; i < m2; ++i) {
        yOffset[i] += yExtent[r - 1];
      }
    }
  }
  for (x5 = 0, i = 0; i < n; ++i) {
    x5 = xOffset[i] + (i % ncols ? x5 : 0);
    dx[i] += x5 - groups[i].x;
  }
  for (c2 = 0; c2 < ncols; ++c2) {
    for (y5 = 0, i = c2; i < n; i += ncols) {
      y5 += yOffset[i];
      dy[i] += y5 - groups[i].y;
    }
  }
  if (alignCol && get4(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignCol === All ? xMax : xExtent[i % ncols];
      x5 = b2 - boxes[i].x2 - groups[i].x - dx[i];
      if (x5 > 0)
        dx[i] += x5 / 2;
    }
  }
  if (alignRow && get4(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y5 = b2 - boxes[i].y2 - groups[i].y - dy[i];
      if (y5 > 0)
        dy[i] += y5 / 2;
    }
  }
  for (i = 0; i < n; ++i) {
    bounds2.union(boxes[i].translate(dx[i], dy[i]));
  }
  x5 = get4(opt.anchor, X);
  y5 = get4(opt.anchor, Y);
  switch (get4(opt.anchor, Column)) {
    case End:
      x5 -= bounds2.width();
      break;
    case Middle:
      x5 -= bounds2.width() / 2;
  }
  switch (get4(opt.anchor, Row)) {
    case End:
      y5 -= bounds2.height();
      break;
    case Middle:
      y5 -= bounds2.height() / 2;
  }
  x5 = Math.round(x5);
  y5 = Math.round(y5);
  bounds2.clear();
  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }
  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x5;
    g.y += dy[i] += y5;
    bounds2.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty)
      view.dirty(g);
  }
  return bounds2;
}
function trellisLayout(view, group2, opt) {
  var views = gridLayoutGroups(group2), groups = views.marks, bbox = opt.bounds === Flush ? boundFlush : boundFull, off = opt.offset, ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), cells = nrows * ncols, x5, y5, x22, y22, anchor, band2, offset4;
  const bounds2 = gridLayout(view, groups, opt);
  if (bounds2.empty())
    bounds2.set(0, 0, 0, 0);
  if (views.rowheaders) {
    band2 = get4(opt.headerBand, Row, null);
    x5 = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get4(off, "rowHeader"), min3, 0, bbox, "x1", 0, ncols, 1, band2);
  }
  if (views.colheaders) {
    band2 = get4(opt.headerBand, Column, null);
    y5 = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get4(off, "columnHeader"), min3, 1, bbox, "y1", 0, 1, ncols, band2);
  }
  if (views.rowfooters) {
    band2 = get4(opt.footerBand, Row, null);
    x22 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get4(off, "rowFooter"), max3, 0, bbox, "x2", ncols - 1, ncols, 1, band2);
  }
  if (views.colfooters) {
    band2 = get4(opt.footerBand, Column, null);
    y22 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get4(off, "columnFooter"), max3, 1, bbox, "y2", cells - ncols, 1, ncols, band2);
  }
  if (views.rowtitle) {
    anchor = get4(opt.titleAnchor, Row);
    offset4 = get4(off, "rowTitle");
    offset4 = anchor === End ? x22 + offset4 : x5 - offset4;
    band2 = get4(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset4, 0, bounds2, band2);
  }
  if (views.coltitle) {
    anchor = get4(opt.titleAnchor, Column);
    offset4 = get4(off, "columnTitle");
    offset4 = anchor === End ? y22 + offset4 : y5 - offset4;
    band2 = get4(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset4, 1, bounds2, band2);
  }
}
function boundFlush(item, field3) {
  return field3 === "x1" ? item.x || 0 : field3 === "y1" ? item.y || 0 : field3 === "x2" ? (item.x || 0) + (item.width || 0) : field3 === "y2" ? (item.y || 0) + (item.height || 0) : void 0;
}
function boundFull(item, field3) {
  return item.bounds[field3];
}
function layoutHeaders(view, headers, groups, ncols, limit, offset4, agg, isX2, bound2, bf, start, stride, back, band2) {
  var n = groups.length, init2 = 0, edge = 0, i, j, k, m2, b2, h2, g, x5, y5;
  if (!n)
    return init2;
  for (i = start; i < n; i += stride) {
    if (groups[i])
      init2 = agg(init2, bound2(groups[i], bf));
  }
  if (!headers.length)
    return init2;
  if (headers.length > limit) {
    view.warn("Grid headers exceed limit: " + limit);
    headers = headers.slice(0, limit);
  }
  init2 += offset4;
  for (j = 0, m2 = headers.length; j < m2; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  }
  for (i = start, j = 0, m2 = headers.length; j < m2; ++j, i += stride) {
    h2 = headers[j];
    b2 = h2.mark.bounds;
    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back)
      ;
    if (isX2) {
      x5 = band2 == null ? g.x : Math.round(g.bounds.x1 + band2 * g.bounds.width());
      y5 = init2;
    } else {
      x5 = init2;
      y5 = band2 == null ? g.y : Math.round(g.bounds.y1 + band2 * g.bounds.height());
    }
    b2.union(h2.bounds.translate(x5 - (h2.x || 0), y5 - (h2.y || 0)));
    h2.x = x5;
    h2.y = y5;
    view.dirty(h2);
    edge = agg(edge, b2[bf]);
  }
  return edge;
}
function layoutTitle(view, g, offset4, isX2, bounds2, band2) {
  if (!g)
    return;
  view.dirty(g);
  var x5 = offset4, y5 = offset4;
  isX2 ? x5 = Math.round(bounds2.x1 + band2 * bounds2.width()) : y5 = Math.round(bounds2.y1 + band2 * bounds2.height());
  g.bounds.translate(x5 - (g.x || 0), y5 - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x5;
  g.y = y5;
  view.dirty(g);
}
function lookup$1(config, orient2) {
  const opt = config[orient2] || {};
  return (key2, d) => opt[key2] != null ? opt[key2] : config[key2] != null ? config[key2] : d;
}
function offsets(legends, value3) {
  let max4 = -Infinity;
  legends.forEach((item) => {
    if (item.offset != null)
      max4 = Math.max(max4, item.offset);
  });
  return max4 > -Infinity ? max4 : value3;
}
function legendParams(g, orient2, config, xb, yb, w2, h2) {
  const _ = lookup$1(config, orient2), offset4 = offsets(g, _("offset", 0)), anchor = _("anchor", Start), mult2 = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;
  const p = {
    align: Each,
    bounds: _("bounds", Flush),
    columns: _("direction") === "vertical" ? 1 : g.length,
    padding: _("margin", 8),
    center: _("center"),
    nodirty: true
  };
  switch (orient2) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset4,
        column: End,
        y: mult2 * (h2 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset4,
        y: mult2 * (h2 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset4,
        row: End,
        x: mult2 * (w2 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset4,
        x: mult2 * (w2 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case TopLeft:
      p.anchor = {
        x: offset4,
        y: offset4
      };
      break;
    case TopRight:
      p.anchor = {
        x: w2 - offset4,
        y: offset4,
        column: End
      };
      break;
    case BottomLeft:
      p.anchor = {
        x: offset4,
        y: h2 - offset4,
        row: End
      };
      break;
    case BottomRight:
      p.anchor = {
        x: w2 - offset4,
        y: h2 - offset4,
        column: End,
        row: End
      };
      break;
  }
  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0], datum2 = item.datum, orient2 = item.orient, bounds2 = item.bounds, x5 = item.x, y5 = item.y, w2, h2;
  item._bounds ? item._bounds.clear().union(bounds2) : item._bounds = bounds2.clone();
  bounds2.clear();
  legendGroupLayout(view, item, item.items[0].items[0]);
  bounds2 = legendBounds(item, bounds2);
  w2 = 2 * item.padding;
  h2 = 2 * item.padding;
  if (!bounds2.empty()) {
    w2 = Math.ceil(bounds2.width() + w2);
    h2 = Math.ceil(bounds2.height() + h2);
  }
  if (datum2.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }
  if (orient2 !== None3) {
    item.x = x5 = 0;
    item.y = y5 = 0;
  }
  item.width = w2;
  item.height = h2;
  boundStroke(bounds2.set(x5, y5, x5 + w2, y5 + h2), item);
  item.mark.bounds.clear().union(bounds2);
  return item;
}
function legendBounds(item, b2) {
  item.items.forEach((_) => b2.union(_.bounds));
  b2.x1 = item.padding;
  b2.y1 = item.padding;
  return b2;
}
function legendGroupLayout(view, item, entry2) {
  var pad4 = item.padding, ex = pad4 - entry2.x, ey = pad4 - entry2.y;
  if (!item.datum.title) {
    if (ex || ey)
      translate2(view, entry2, ex, ey);
  } else {
    var title = item.items[1].items[0], anchor = title.anchor, tpad = item.titlePadding || 0, tx = pad4 - title.x, ty = pad4 - title.y;
    switch (title.orient) {
      case Left:
        ex += Math.ceil(title.bounds.width()) + tpad;
        break;
      case Right:
      case Bottom:
        break;
      default:
        ey += title.bounds.height() + tpad;
    }
    if (ex || ey)
      translate2(view, entry2, ex, ey);
    switch (title.orient) {
      case Left:
        ty += legendTitleOffset(item, entry2, title, anchor, 1, 1);
        break;
      case Right:
        tx += legendTitleOffset(item, entry2, title, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry2, title, anchor, 1, 1);
        break;
      case Bottom:
        tx += legendTitleOffset(item, entry2, title, anchor, 0, 0);
        ty += legendTitleOffset(item, entry2, title, End, -1, 0, 1) + tpad;
        break;
      default:
        tx += legendTitleOffset(item, entry2, title, anchor, 0, 0);
    }
    if (tx || ty)
      translate2(view, title, tx, ty);
    if ((tx = Math.round(title.bounds.x1 - pad4)) < 0) {
      translate2(view, entry2, -tx, 0);
      translate2(view, title, -tx, 0);
    }
  }
}
function legendTitleOffset(item, entry2, title, anchor, y5, lr, noBar) {
  const grad = item.datum.type !== "symbol", vgrad = title.datum.vgrad, e = grad && (lr || !vgrad) && !noBar ? entry2.items[0] : entry2, s = e.bounds[y5 ? "y2" : "x2"] - item.padding, u = vgrad && lr ? s : 0, v = vgrad && lr ? 0 : s, o = y5 <= 0 ? 0 : multiLineOffset(title);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));
}
function translate2(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}
function legendEntryLayout(entries) {
  const widths = entries.reduce((w2, g) => {
    w2[g.column] = Math.max(g.bounds.x2 - g.x, w2[g.column] || 0);
    return w2;
  }, {});
  entries.forEach((g) => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}
function titleLayout(view, mark, width2, height2, viewBounds2) {
  var group2 = mark.items[0], frame3 = group2.frame, orient2 = group2.orient, anchor = group2.anchor, offset4 = group2.offset, padding2 = group2.padding, title = group2.items[0].items[0], subtitle = group2.items[1] && group2.items[1].items[0], end = orient2 === Left || orient2 === Right ? height2 : width2, start = 0, x5 = 0, y5 = 0, sx = 0, sy = 0, pos;
  if (frame3 !== Group) {
    orient2 === Left ? (start = viewBounds2.y2, end = viewBounds2.y1) : orient2 === Right ? (start = viewBounds2.y1, end = viewBounds2.y2) : (start = viewBounds2.x1, end = viewBounds2.x2);
  } else if (orient2 === Left) {
    start = height2, end = 0;
  }
  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;
  if (subtitle && subtitle.text) {
    switch (orient2) {
      case Top:
      case Bottom:
        sy = title.bounds.height() + padding2;
        break;
      case Left:
        sx = title.bounds.width() + padding2;
        break;
      case Right:
        sx = -title.bounds.width() - padding2;
        break;
    }
    tempBounds2.clear().union(subtitle.bounds);
    tempBounds2.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
    if (set2(subtitle, "x", sx) | set2(subtitle, "y", sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds2);
      subtitle.mark.bounds.clear().union(tempBounds2);
      view.dirty(subtitle);
    }
    tempBounds2.clear().union(subtitle.bounds);
  } else {
    tempBounds2.clear();
  }
  tempBounds2.union(title.bounds);
  switch (orient2) {
    case Top:
      x5 = pos;
      y5 = viewBounds2.y1 - tempBounds2.height() - offset4;
      break;
    case Left:
      x5 = viewBounds2.x1 - tempBounds2.width() - offset4;
      y5 = pos;
      break;
    case Right:
      x5 = viewBounds2.x2 + tempBounds2.width() + offset4;
      y5 = pos;
      break;
    case Bottom:
      x5 = pos;
      y5 = viewBounds2.y2 + offset4;
      break;
    default:
      x5 = group2.x;
      y5 = group2.y;
  }
  if (set2(group2, "x", x5) | set2(group2, "y", y5)) {
    tempBounds2.translate(x5, y5);
    view.dirty(group2);
    group2.bounds.clear().union(tempBounds2);
    mark.bounds.clear().union(tempBounds2);
    view.dirty(group2);
  }
  return group2.bounds;
}
function ViewLayout(params2) {
  Transform.call(this, null, params2);
}
inherits(ViewLayout, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    _.mark.items.forEach((group2) => {
      if (_.layout)
        trellisLayout(view, group2, _.layout);
      layoutGroup(view, group2, _);
    });
    return shouldReflow(_.mark.group) ? pulse2.reflow() : pulse2;
  }
});
function shouldReflow(group2) {
  return group2 && group2.mark.role !== "legend-entry";
}
function layoutGroup(view, group2, _) {
  var items = group2.items, width2 = Math.max(0, group2.width || 0), height2 = Math.max(0, group2.height || 0), viewBounds2 = new Bounds().set(0, 0, width2, height2), xBounds = viewBounds2.clone(), yBounds = viewBounds2.clone(), legends = [], title, mark, orient2, b2, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    mark = items[i];
    switch (mark.role) {
      case AxisRole:
        b2 = isYAxis(mark) ? xBounds : yBounds;
        b2.union(axisLayout(view, mark, width2, height2));
        break;
      case TitleRole:
        title = mark;
        break;
      case LegendRole:
        legends.push(legendLayout(view, mark));
        break;
      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark.bounds);
        yBounds.union(mark.bounds);
        break;
      default:
        viewBounds2.union(mark.bounds);
    }
  }
  if (legends.length) {
    const l = {};
    legends.forEach((item) => {
      orient2 = item.orient || Right;
      if (orient2 !== None3)
        (l[orient2] || (l[orient2] = [])).push(item);
    });
    for (const orient3 in l) {
      const g = l[orient3];
      gridLayout(view, g, legendParams(g, orient3, _.legends, xBounds, yBounds, width2, height2));
    }
    legends.forEach((item) => {
      const b3 = item.bounds;
      if (!b3.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item);
        item.bounds = b3;
        view.dirty(item);
      }
      if (_.autosize && _.autosize.type === Fit) {
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds2.add(b3.x1, 0).add(b3.x2, 0);
            break;
          case Top:
          case Bottom:
            viewBounds2.add(0, b3.y1).add(0, b3.y2);
        }
      } else {
        viewBounds2.union(b3);
      }
    });
  }
  viewBounds2.union(xBounds).union(yBounds);
  if (title) {
    viewBounds2.union(titleLayout(view, title, width2, height2, viewBounds2));
  }
  if (group2.clip) {
    viewBounds2.set(0, 0, group2.width || 0, group2.height || 0);
  }
  viewSizeLayout(view, group2, viewBounds2, _);
}
function viewSizeLayout(view, group2, viewBounds2, _) {
  const auto = _.autosize || {}, type2 = auto.type;
  if (view._autosize < 1 || !type2)
    return;
  let viewWidth2 = view._width, viewHeight2 = view._height, width2 = Math.max(0, group2.width || 0), left = Math.max(0, Math.ceil(-viewBounds2.x1)), height2 = Math.max(0, group2.height || 0), top = Math.max(0, Math.ceil(-viewBounds2.y1));
  const right = Math.max(0, Math.ceil(viewBounds2.x2 - width2)), bottom = Math.max(0, Math.ceil(viewBounds2.y2 - height2));
  if (auto.contains === Padding) {
    const padding2 = view.padding();
    viewWidth2 -= padding2.left + padding2.right;
    viewHeight2 -= padding2.top + padding2.bottom;
  }
  if (type2 === None3) {
    left = 0;
    top = 0;
    width2 = viewWidth2;
    height2 = viewHeight2;
  } else if (type2 === Fit) {
    width2 = Math.max(0, viewWidth2 - left - right);
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type2 === FitX) {
    width2 = Math.max(0, viewWidth2 - left - right);
    viewHeight2 = height2 + top + bottom;
  } else if (type2 === FitY) {
    viewWidth2 = width2 + left + right;
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type2 === Pad) {
    viewWidth2 = width2 + left + right;
    viewHeight2 = height2 + top + bottom;
  }
  view._resizeView(viewWidth2, viewHeight2, width2, height2, [left, top], auto.resize);
}

// node_modules/vega-encode/build/vega-encode.module.js
var vega_encode_module_exports = {};
__export(vega_encode_module_exports, {
  axisticks: () => AxisTicks,
  datajoin: () => DataJoin,
  encode: () => Encode,
  legendentries: () => LegendEntries,
  linkpath: () => LinkPath,
  pie: () => Pie,
  scale: () => Scale,
  sortitems: () => SortItems,
  stack: () => Stack
});

// node_modules/vega-encode/node_modules/d3-color/src/define.js
function define_default2(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend3(parent, definition3) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition3)
    prototype2[key2] = definition3[key2];
  return prototype2;
}

// node_modules/vega-encode/node_modules/d3-color/src/color.js
function Color2() {
}
var darker2 = 0.7;
var brighter2 = 1 / darker2;
var reI2 = "\\s*([+-]?\\d+)\\s*";
var reN2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex2 = /^#([0-9a-f]{3,8})$/;
var reRgbInteger2 = new RegExp("^rgb\\(" + [reI2, reI2, reI2] + "\\)$");
var reRgbPercent2 = new RegExp("^rgb\\(" + [reP2, reP2, reP2] + "\\)$");
var reRgbaInteger2 = new RegExp("^rgba\\(" + [reI2, reI2, reI2, reN2] + "\\)$");
var reRgbaPercent2 = new RegExp("^rgba\\(" + [reP2, reP2, reP2, reN2] + "\\)$");
var reHslPercent2 = new RegExp("^hsl\\(" + [reN2, reP2, reP2] + "\\)$");
var reHslaPercent2 = new RegExp("^hsla\\(" + [reN2, reP2, reP2, reN2] + "\\)$");
var named2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default2(Color2, color3, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex2,
  formatHex: color_formatHex2,
  formatHsl: color_formatHsl2,
  formatRgb: color_formatRgb2,
  toString: color_formatRgb2
});
function color_formatHex2() {
  return this.rgb().formatHex();
}
function color_formatHsl2() {
  return hslConvert2(this).formatHsl();
}
function color_formatRgb2() {
  return this.rgb().formatRgb();
}
function color3(format5) {
  var m2, l;
  format5 = (format5 + "").trim().toLowerCase();
  return (m2 = reHex2.exec(format5)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn2(m2) : l === 3 ? new Rgb2(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba2(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba2(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger2.exec(format5)) ? new Rgb2(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent2.exec(format5)) ? new Rgb2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger2.exec(format5)) ? rgba2(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent2.exec(format5)) ? rgba2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent2.exec(format5)) ? hsla2(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent2.exec(format5)) ? hsla2(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named2.hasOwnProperty(format5) ? rgbn2(named2[format5]) : format5 === "transparent" ? new Rgb2(NaN, NaN, NaN, 0) : null;
}
function rgbn2(n) {
  return new Rgb2(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba2(r, g, b2, a2) {
  if (a2 <= 0)
    r = g = b2 = NaN;
  return new Rgb2(r, g, b2, a2);
}
function rgbConvert2(o) {
  if (!(o instanceof Color2))
    o = color3(o);
  if (!o)
    return new Rgb2();
  o = o.rgb();
  return new Rgb2(o.r, o.g, o.b, o.opacity);
}
function rgb2(r, g, b2, opacity) {
  return arguments.length === 1 ? rgbConvert2(r) : new Rgb2(r, g, b2, opacity == null ? 1 : opacity);
}
function Rgb2(r, g, b2, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default2(Rgb2, rgb2, extend3(Color2, {
  brighter: function(k) {
    k = k == null ? brighter2 : Math.pow(brighter2, k);
    return new Rgb2(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker2 : Math.pow(darker2, k);
    return new Rgb2(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex2,
  formatHex: rgb_formatHex2,
  formatRgb: rgb_formatRgb2,
  toString: rgb_formatRgb2
}));
function rgb_formatHex2() {
  return "#" + hex2(this.r) + hex2(this.g) + hex2(this.b);
}
function rgb_formatRgb2() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex2(value3) {
  value3 = Math.max(0, Math.min(255, Math.round(value3) || 0));
  return (value3 < 16 ? "0" : "") + value3.toString(16);
}
function hsla2(h2, s, l, a2) {
  if (a2 <= 0)
    h2 = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s = NaN;
  else if (s <= 0)
    h2 = NaN;
  return new Hsl2(h2, s, l, a2);
}
function hslConvert2(o) {
  if (o instanceof Hsl2)
    return new Hsl2(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color2))
    o = color3(o);
  if (!o)
    return new Hsl2();
  if (o instanceof Hsl2)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b2 = o.b / 255, min4 = Math.min(r, g, b2), max4 = Math.max(r, g, b2), h2 = NaN, s = max4 - min4, l = (max4 + min4) / 2;
  if (s) {
    if (r === max4)
      h2 = (g - b2) / s + (g < b2) * 6;
    else if (g === max4)
      h2 = (b2 - r) / s + 2;
    else
      h2 = (r - g) / s + 4;
    s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl2(h2, s, l, o.opacity);
}
function hsl3(h2, s, l, opacity) {
  return arguments.length === 1 ? hslConvert2(h2) : new Hsl2(h2, s, l, opacity == null ? 1 : opacity);
}
function Hsl2(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default2(Hsl2, hsl3, extend3(Color2, {
  brighter: function(k) {
    k = k == null ? brighter2 : Math.pow(brighter2, k);
    return new Hsl2(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker2 : Math.pow(darker2, k);
    return new Hsl2(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb2(hsl2rgb2(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb2(h2, m1, m2), hsl2rgb2(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb2(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/basis.js
function basis2(t14, v0, v1, v2, v3) {
  var t23 = t14 * t14, t33 = t23 * t14;
  return ((1 - 3 * t14 + 3 * t23 - t33) * v0 + (4 - 6 * t23 + 3 * t33) * v1 + (1 + 3 * t14 + 3 * t23 - 3 * t33) * v2 + t33 * v3) / 6;
}
function basis_default3(values2) {
  var n = values2.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return basis2((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default3(values2) {
  var n = values2.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis2((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x5) => () => x5;

// node_modules/vega-encode/node_modules/d3-interpolate/src/color.js
function linear4(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential2(a2, b2, y5) {
  return a2 = Math.pow(a2, y5), b2 = Math.pow(b2, y5) - a2, y5 = 1 / y5, function(t) {
    return Math.pow(a2 + t * b2, y5);
  };
}
function gamma2(y5) {
  return (y5 = +y5) === 1 ? nogamma2 : function(a2, b2) {
    return b2 - a2 ? exponential2(a2, b2, y5) : constant_default3(isNaN(a2) ? b2 : a2);
  };
}
function nogamma2(a2, b2) {
  var d = b2 - a2;
  return d ? linear4(a2, d) : constant_default3(isNaN(a2) ? b2 : a2);
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/rgb.js
var rgb_default2 = function rgbGamma2(y5) {
  var color7 = gamma2(y5);
  function rgb5(start, end) {
    var r = color7((start = rgb2(start)).r, (end = rgb2(end)).r), g = color7(start.g, end.g), b2 = color7(start.b, end.b), opacity = nogamma2(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b2(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb5.gamma = rgbGamma2;
  return rgb5;
}(1);
function rgbSpline2(spline) {
  return function(colors2) {
    var n = colors2.length, r = new Array(n), g = new Array(n), b2 = new Array(n), i, color7;
    for (i = 0; i < n; ++i) {
      color7 = rgb2(colors2[i]);
      r[i] = color7.r || 0;
      g[i] = color7.g || 0;
      b2[i] = color7.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b2 = spline(b2);
    color7.opacity = 1;
    return function(t) {
      color7.r = r(t);
      color7.g = g(t);
      color7.b = b2(t);
      return color7 + "";
    };
  };
}
var rgbBasis2 = rgbSpline2(basis_default3);
var rgbBasisClosed2 = rgbSpline2(basisClosed_default3);

// node_modules/vega-encode/node_modules/d3-interpolate/src/numberArray.js
function numberArray_default2(a2, b2) {
  if (!b2)
    b2 = [];
  var n = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a2[i] * (1 - t) + b2[i] * t;
    return c2;
  };
}
function isNumberArray2(x5) {
  return ArrayBuffer.isView(x5) && !(x5 instanceof DataView);
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/array.js
function genericArray2(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x5 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x5[i] = value_default2(a2[i], b2[i]);
  for (; i < nb; ++i)
    c2[i] = b2[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x5[i](t);
    return c2;
  };
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/date.js
function date_default2(a2, b2) {
  var d = new Date();
  return a2 = +a2, b2 = +b2, function(t) {
    return d.setTime(a2 * (1 - t) + b2 * t), d;
  };
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/number.js
function number_default3(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t) {
    return a2 * (1 - t) + b2 * t;
  };
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/object.js
function object_default2(a2, b2) {
  var i = {}, c2 = {}, k;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b2 === null || typeof b2 !== "object")
    b2 = {};
  for (k in b2) {
    if (k in a2) {
      i[k] = value_default2(a2[k], b2[k]);
    } else {
      c2[k] = b2[k];
    }
  }
  return function(t) {
    for (k in i)
      c2[k] = i[k](t);
    return c2;
  };
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/string.js
var reA2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB2 = new RegExp(reA2.source, "g");
function zero3(b2) {
  return function() {
    return b2;
  };
}
function one3(b2) {
  return function(t) {
    return b2(t) + "";
  };
}
function string_default2(a2, b2) {
  var bi = reA2.lastIndex = reB2.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA2.exec(a2)) && (bm = reB2.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default3(am, bm) });
    }
    bi = reB2.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one3(q[0].x) : zero3(b2) : (b2 = q.length, function(t) {
    for (var i2 = 0, o; i2 < b2; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/value.js
function value_default2(a2, b2) {
  var t = typeof b2, c2;
  return b2 == null || t === "boolean" ? constant_default3(b2) : (t === "number" ? number_default3 : t === "string" ? (c2 = color3(b2)) ? (b2 = c2, rgb_default2) : string_default2 : b2 instanceof color3 ? rgb_default2 : b2 instanceof Date ? date_default2 : isNumberArray2(b2) ? numberArray_default2 : Array.isArray(b2) ? genericArray2 : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default2 : number_default3)(a2, b2);
}

// node_modules/vega-encode/node_modules/d3-interpolate/src/round.js
function round_default2(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t) {
    return Math.round(a2 * (1 - t) + b2 * t);
  };
}

// node_modules/vega-encode/build/vega-encode.module.js
function AxisTicks(params2) {
  Transform.call(this, null, params2);
}
inherits(AxisTicks, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale4 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), ticks = this.value, scale6 = _.scale, tally = _.count == null ? _.values ? _.values.length : 10 : _.count, count2 = tickCount(scale6, tally, _.minstep), format5 = _.format || tickFormat2(locale4, scale6, count2, _.formatSpecifier, _.formatType, !!_.values), values2 = _.values ? validTicks(scale6, _.values, count2) : tickValues(scale6, count2);
    if (ticks)
      out.rem = ticks;
    ticks = values2.map((value3, i) => ingest$1({
      index: i / (values2.length - 1 || 1),
      value: value3,
      label: format5(value3)
    }));
    if (_.extra && ticks.length) {
      ticks.push(ingest$1({
        index: -1,
        extra: {
          value: ticks[0].value
        },
        label: ""
      }));
    }
    out.source = ticks;
    out.add = ticks;
    this.value = ticks;
    return out;
  }
});
function DataJoin(params2) {
  Transform.call(this, null, params2);
}
function defaultItemCreate() {
  return ingest$1({});
}
function newMap(key2) {
  const map3 = fastmap().test((t) => t.exit);
  map3.lookup = (t) => map3.get(key2(t));
  return map3;
}
inherits(DataJoin, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), item = _.item || defaultItemCreate, key2 = _.key || tupleid, map3 = this.value;
    if (isArray(out.encode)) {
      out.encode = null;
    }
    if (map3 && (_.modified("key") || pulse2.modified(key2))) {
      error("DataJoin does not support modified key function or fields.");
    }
    if (!map3) {
      pulse2 = pulse2.addAll();
      this.value = map3 = newMap(key2);
    }
    pulse2.visit(pulse2.ADD, (t) => {
      const k = key2(t);
      let x5 = map3.get(k);
      if (x5) {
        if (x5.exit) {
          map3.empty--;
          out.add.push(x5);
        } else {
          out.mod.push(x5);
        }
      } else {
        x5 = item(t);
        map3.set(k, x5);
        out.add.push(x5);
      }
      x5.datum = t;
      x5.exit = false;
    });
    pulse2.visit(pulse2.MOD, (t) => {
      const k = key2(t), x5 = map3.get(k);
      if (x5) {
        x5.datum = t;
        out.mod.push(x5);
      }
    });
    pulse2.visit(pulse2.REM, (t) => {
      const k = key2(t), x5 = map3.get(k);
      if (t === x5.datum && !x5.exit) {
        out.rem.push(x5);
        x5.exit = true;
        ++map3.empty;
      }
    });
    if (pulse2.changed(pulse2.ADD_MOD))
      out.modifies("datum");
    if (pulse2.clean() || _.clean && map3.empty > df.cleanThreshold) {
      df.runAfter(map3.clean);
    }
    return out;
  }
});
function Encode(params2) {
  Transform.call(this, null, params2);
}
inherits(Encode, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ADD_REM), fmod = _.mod || false, encoders = _.encoders, encode2 = pulse2.encode;
    if (isArray(encode2)) {
      if (out.changed() || encode2.every((e) => encoders[e])) {
        encode2 = encode2[0];
        out.encode = null;
      } else {
        return pulse2.StopPropagation;
      }
    }
    var reenter = encode2 === "enter", update3 = encoders.update || falsy, enter = encoders.enter || falsy, exit = encoders.exit || falsy, set5 = (encode2 && !reenter ? encoders[encode2] : update3) || falsy;
    if (pulse2.changed(pulse2.ADD)) {
      pulse2.visit(pulse2.ADD, (t) => {
        enter(t, _);
        update3(t, _);
      });
      out.modifies(enter.output);
      out.modifies(update3.output);
      if (set5 !== falsy && set5 !== update3) {
        pulse2.visit(pulse2.ADD, (t) => {
          set5(t, _);
        });
        out.modifies(set5.output);
      }
    }
    if (pulse2.changed(pulse2.REM) && exit !== falsy) {
      pulse2.visit(pulse2.REM, (t) => {
        exit(t, _);
      });
      out.modifies(exit.output);
    }
    if (reenter || set5 !== falsy) {
      const flag2 = pulse2.MOD | (_.modified() ? pulse2.REFLOW : 0);
      if (reenter) {
        pulse2.visit(flag2, (t) => {
          const mod = enter(t, _) || fmod;
          if (set5(t, _) || mod)
            out.mod.push(t);
        });
        if (out.mod.length)
          out.modifies(enter.output);
      } else {
        pulse2.visit(flag2, (t) => {
          if (set5(t, _) || fmod)
            out.mod.push(t);
        });
      }
      if (out.mod.length)
        out.modifies(set5.output);
    }
    return out.changed() ? out : pulse2.StopPropagation;
  }
});
function LegendEntries(params2) {
  Transform.call(this, [], params2);
}
inherits(LegendEntries, Transform, {
  transform(_, pulse2) {
    if (this.value != null && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale4 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), items = this.value, type2 = _.type || SymbolLegend, scale6 = _.scale, limit = +_.limit, count2 = tickCount(scale6, _.count == null ? 5 : _.count, _.minstep), lskip = !!_.values || type2 === SymbolLegend, format5 = _.format || labelFormat(locale4, scale6, count2, type2, _.formatSpecifier, _.formatType, lskip), values2 = _.values || labelValues(scale6, count2), domain2, fraction, size, offset4, ellipsis;
    if (items)
      out.rem = items;
    if (type2 === SymbolLegend) {
      if (limit && values2.length > limit) {
        pulse2.dataflow.warn("Symbol legend count exceeds limit, filtering items.");
        items = values2.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values2;
      }
      if (isFunction(size = _.size)) {
        if (!_.values && scale6(items[0]) === 0) {
          items = items.slice(1);
        }
        offset4 = items.reduce((max4, value3) => Math.max(max4, size(value3, _)), 0);
      } else {
        size = constant(offset4 = size || 8);
      }
      items = items.map((value3, index3) => ingest$1({
        index: index3,
        label: format5(value3, index3, items),
        value: value3,
        offset: offset4,
        size: size(value3, _)
      }));
      if (ellipsis) {
        ellipsis = values2[items.length];
        items.push(ingest$1({
          index: items.length,
          label: "\u2026".concat(values2.length - items.length, " entries"),
          value: ellipsis,
          offset: offset4,
          size: size(ellipsis, _)
        }));
      }
    } else if (type2 === GradientLegend) {
      domain2 = scale6.domain(), fraction = scaleFraction(scale6, domain2[0], peek(domain2));
      if (values2.length < 3 && !_.values && domain2[0] !== peek(domain2)) {
        values2 = [domain2[0], peek(domain2)];
      }
      items = values2.map((value3, index3) => ingest$1({
        index: index3,
        label: format5(value3, index3, values2),
        value: value3,
        perc: fraction(value3)
      }));
    } else {
      size = values2.length - 1;
      fraction = labelFraction(scale6);
      items = values2.map((value3, index3) => ingest$1({
        index: index3,
        label: format5(value3, index3, values2),
        value: value3,
        perc: index3 ? fraction(value3) : 0,
        perc2: index3 === size ? 1 : fraction(values2[index3 + 1])
      }));
    }
    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }
});
var sourceX = (t) => t.source.x;
var sourceY = (t) => t.source.y;
var targetX = (t) => t.target.x;
var targetY = (t) => t.target.y;
function LinkPath(params2) {
  Transform.call(this, {}, params2);
}
LinkPath.Definition = {
  "type": "LinkPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sourceX",
    "type": "field",
    "default": "source.x"
  }, {
    "name": "sourceY",
    "type": "field",
    "default": "source.y"
  }, {
    "name": "targetX",
    "type": "field",
    "default": "target.x"
  }, {
    "name": "targetY",
    "type": "field",
    "default": "target.y"
  }, {
    "name": "orient",
    "type": "enum",
    "default": "vertical",
    "values": ["horizontal", "vertical", "radial"]
  }, {
    "name": "shape",
    "type": "enum",
    "default": "line",
    "values": ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    "name": "require",
    "type": "signal"
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits(LinkPath, Transform, {
  transform(_, pulse2) {
    var sx = _.sourceX || sourceX, sy = _.sourceY || sourceY, tx = _.targetX || targetX, ty = _.targetY || targetY, as = _.as || "path", orient2 = _.orient || "vertical", shape2 = _.shape || "line", path3 = Paths.get(shape2 + "-" + orient2) || Paths.get(shape2);
    if (!path3) {
      error("LinkPath unsupported type: " + _.shape + (_.orient ? "-" + _.orient : ""));
    }
    pulse2.visit(pulse2.SOURCE, (t) => {
      t[as] = path3(sx(t), sy(t), tx(t), ty(t));
    });
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var line2 = (sx, sy, tx, ty) => "M" + sx + "," + sy + "L" + tx + "," + ty;
var lineR = (sa2, sr, ta, tr2) => line2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var arc2 = (sx, sy, tx, ty) => {
  var dx = tx - sx, dy = ty - sy, rr = Math.sqrt(dx * dx + dy * dy) / 2, ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return "M" + sx + "," + sy + "A" + rr + "," + rr + " " + ra + " 0 1 " + tx + "," + ty;
};
var arcR = (sa2, sr, ta, tr2) => arc2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var curve = (sx, sy, tx, ty) => {
  const dx = tx - sx, dy = ty - sy, ix = 0.2 * (dx + dy), iy = 0.2 * (dy - dx);
  return "M" + sx + "," + sy + "C" + (sx + ix) + "," + (sy + iy) + " " + (tx + iy) + "," + (ty - ix) + " " + tx + "," + ty;
};
var curveR = (sa2, sr, ta, tr2) => curve(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var orthoX = (sx, sy, tx, ty) => "M" + sx + "," + sy + "V" + ty + "H" + tx;
var orthoY = (sx, sy, tx, ty) => "M" + sx + "," + sy + "H" + tx + "V" + ty;
var orthoR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), sf = Math.abs(ta - sa2) > Math.PI ? ta <= sa2 : ta > sa2;
  return "M" + sr * sc + "," + sr * ss + "A" + sr + "," + sr + " 0 0," + (sf ? 1 : 0) + " " + sr * tc + "," + sr * ts2 + "L" + tr2 * tc + "," + tr2 * ts2;
};
var diagonalX = (sx, sy, tx, ty) => {
  const m2 = (sx + tx) / 2;
  return "M" + sx + "," + sy + "C" + m2 + "," + sy + " " + m2 + "," + ty + " " + tx + "," + ty;
};
var diagonalY = (sx, sy, tx, ty) => {
  const m2 = (sy + ty) / 2;
  return "M" + sx + "," + sy + "C" + sx + "," + m2 + " " + tx + "," + m2 + " " + tx + "," + ty;
};
var diagonalR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), mr = (sr + tr2) / 2;
  return "M" + sr * sc + "," + sr * ss + "C" + mr * sc + "," + mr * ss + " " + mr * tc + "," + mr * ts2 + " " + tr2 * tc + "," + tr2 * ts2;
};
var Paths = fastmap({
  "line": line2,
  "line-radial": lineR,
  "arc": arc2,
  "arc-radial": arcR,
  "curve": curve,
  "curve-radial": curveR,
  "orthogonal-horizontal": orthoX,
  "orthogonal-vertical": orthoY,
  "orthogonal-radial": orthoR,
  "diagonal-horizontal": diagonalX,
  "diagonal-vertical": diagonalY,
  "diagonal-radial": diagonalR
});
function Pie(params2) {
  Transform.call(this, null, params2);
}
Pie.Definition = {
  "type": "Pie",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "startAngle",
    "type": "number",
    "default": 0
  }, {
    "name": "endAngle",
    "type": "number",
    "default": 6.283185307179586
  }, {
    "name": "sort",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["startAngle", "endAngle"]
  }]
};
inherits(Pie, Transform, {
  transform(_, pulse2) {
    var as = _.as || ["startAngle", "endAngle"], startAngle = as[0], endAngle = as[1], field3 = _.field || one, start = _.startAngle || 0, stop2 = _.endAngle != null ? _.endAngle : 2 * Math.PI, data3 = pulse2.source, values2 = data3.map(field3), n = values2.length, a2 = start, k = (stop2 - start) / sum(values2), index3 = range_default(n), i, t, v;
    if (_.sort) {
      index3.sort((a3, b2) => values2[a3] - values2[b2]);
    }
    for (i = 0; i < n; ++i) {
      v = values2[index3[i]];
      t = data3[index3[i]];
      t[startAngle] = a2;
      t[endAngle] = a2 += v * k;
    }
    this.value = values2;
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var DEFAULT_COUNT = 5;
function includeZero(scale6) {
  const type2 = scale6.type;
  return !scale6.bins && (type2 === Linear2 || type2 === Pow || type2 === Sqrt);
}
function includePad(type2) {
  return isContinuous(type2) && type2 !== Sequential;
}
var SKIP2 = toSet(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function Scale(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Scale, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, scale$12 = this.value, key2 = scaleKey(_);
    if (!scale$12 || key2 !== scale$12.type) {
      this.value = scale$12 = scale(key2)();
    }
    for (key2 in _)
      if (!SKIP2[key2]) {
        if (key2 === "padding" && includePad(scale$12.type))
          continue;
        isFunction(scale$12[key2]) ? scale$12[key2](_[key2]) : df.warn("Unsupported scale property: " + key2);
      }
    configureRange(scale$12, _, configureBins(scale$12, _, configureDomain(scale$12, _, df)));
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function scaleKey(_) {
  var t = _.type, d = "", n;
  if (t === Sequential)
    return Sequential + "-" + Linear2;
  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? Sequential + "-" : n === 3 ? Diverging + "-" : "";
  }
  return (d + t || Linear2).toLowerCase();
}
function isContinuousColor(_) {
  const t = _.type;
  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));
}
function configureDomain(scale6, _, df) {
  const raw = rawDomain(scale6, _.domainRaw, df);
  if (raw > -1)
    return raw;
  var domain2 = _.domain, type2 = scale6.type, zero5 = _.zero || _.zero === void 0 && includeZero(scale6), n, mid;
  if (!domain2)
    return 0;
  if (includePad(type2) && _.padding && domain2[0] !== peek(domain2)) {
    domain2 = padDomain(type2, domain2, _.range, _.padding, _.exponent, _.constant);
  }
  if (zero5 || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain2 = domain2.slice()).length - 1 || 1;
    if (zero5) {
      if (domain2[0] > 0)
        domain2[0] = 0;
      if (domain2[n] < 0)
        domain2[n] = 0;
    }
    if (_.domainMin != null)
      domain2[0] = _.domainMin;
    if (_.domainMax != null)
      domain2[n] = _.domainMax;
    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain2[n] ? n + 1 : mid < domain2[0] ? 0 : n;
      if (i !== n)
        df.warn("Scale domainMid exceeds domain min or max.", mid);
      domain2.splice(i, 0, mid);
    }
  }
  scale6.domain(domainCheck(type2, domain2, df));
  if (type2 === Ordinal) {
    scale6.unknown(_.domainImplicit ? implicit : void 0);
  }
  if (_.nice && scale6.nice) {
    scale6.nice(_.nice !== true && tickCount(scale6, _.nice) || null);
  }
  return domain2.length;
}
function rawDomain(scale6, raw, df) {
  if (raw) {
    scale6.domain(domainCheck(scale6.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}
function padDomain(type2, domain2, range4, pad4, exponent, constant2) {
  var span2 = Math.abs(peek(range4) - range4[0]), frac = span2 / (span2 - 2 * pad4), d = type2 === Log ? zoomLog(domain2, null, frac) : type2 === Sqrt ? zoomPow(domain2, null, frac, 0.5) : type2 === Pow ? zoomPow(domain2, null, frac, exponent || 1) : type2 === Symlog ? zoomSymlog(domain2, null, frac, constant2 || 1) : zoomLinear(domain2, null, frac);
  domain2 = domain2.slice();
  domain2[0] = d[0];
  domain2[domain2.length - 1] = d[1];
  return domain2;
}
function domainCheck(type2, domain2, df) {
  if (isLogarithmic(type2)) {
    var s = Math.abs(domain2.reduce((s2, v) => s2 + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));
    if (s !== domain2.length) {
      df.warn("Log scale domain includes zero: " + $(domain2));
    }
  }
  return domain2;
}
function configureBins(scale6, _, count2) {
  let bins = _.bins;
  if (bins && !isArray(bins)) {
    const domain2 = scale6.domain(), lo = domain2[0], hi = peek(domain2), step = bins.step;
    let start = bins.start == null ? lo : bins.start, stop2 = bins.stop == null ? hi : bins.stop;
    if (!step)
      error("Scale bins parameter missing step property.");
    if (start < lo)
      start = step * Math.ceil(lo / step);
    if (stop2 > hi)
      stop2 = step * Math.floor(hi / step);
    bins = range_default(start, stop2 + step / 2, step);
  }
  if (bins) {
    scale6.bins = bins;
  } else if (scale6.bins) {
    delete scale6.bins;
  }
  if (scale6.type === BinOrdinal) {
    if (!bins) {
      scale6.bins = scale6.domain();
    } else if (!_.domain && !_.domainRaw) {
      scale6.domain(bins);
      count2 = bins.length;
    }
  }
  return count2;
}
function configureRange(scale6, _, count2) {
  var type2 = scale6.type, round = _.round || false, range4 = _.range;
  if (_.rangeStep != null) {
    range4 = configureRangeStep(type2, _, count2);
  } else if (_.scheme) {
    range4 = configureScheme(type2, _, count2);
    if (isFunction(range4)) {
      if (scale6.interpolator) {
        return scale6.interpolator(range4);
      } else {
        error("Scale type ".concat(type2, " does not support interpolating color schemes."));
      }
    }
  }
  if (range4 && isInterpolating(type2)) {
    return scale6.interpolator(interpolateColors(flip(range4, _.reverse), _.interpolate, _.interpolateGamma));
  }
  if (range4 && _.interpolate && scale6.interpolate) {
    scale6.interpolate(interpolate(_.interpolate, _.interpolateGamma));
  } else if (isFunction(scale6.round)) {
    scale6.round(round);
  } else if (isFunction(scale6.rangeRound)) {
    scale6.interpolate(round ? round_default2 : value_default2);
  }
  if (range4)
    scale6.range(flip(range4, _.reverse));
}
function configureRangeStep(type2, _, count2) {
  if (type2 !== Band && type2 !== Point) {
    error("Only band and point scales support rangeStep.");
  }
  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0, inner = type2 === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * bandSpace(count2, inner, outer)];
}
function configureScheme(type2, _, count2) {
  var extent2 = _.schemeExtent, name2, scheme$1;
  if (isArray(_.scheme)) {
    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name2 = _.scheme.toLowerCase();
    scheme$1 = scheme(name2);
    if (!scheme$1)
      error("Unrecognized scheme name: ".concat(_.scheme));
  }
  count2 = type2 === Threshold ? count2 + 1 : type2 === BinOrdinal ? count2 - 1 : type2 === Quantile2 || type2 === Quantize ? +_.schemeCount || DEFAULT_COUNT : count2;
  return isInterpolating(type2) ? adjustScheme(scheme$1, extent2, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent2), count2) : type2 === Ordinal ? scheme$1 : scheme$1.slice(0, count2);
}
function adjustScheme(scheme2, extent2, reverse2) {
  return isFunction(scheme2) && (extent2 || reverse2) ? interpolateRange(scheme2, flip(extent2 || [0, 1], reverse2)) : scheme2;
}
function flip(array4, reverse2) {
  return reverse2 ? array4.slice().reverse() : array4;
}
function SortItems(params2) {
  Transform.call(this, null, params2);
}
inherits(SortItems, Transform, {
  transform(_, pulse2) {
    const mod = _.modified("sort") || pulse2.changed(pulse2.ADD) || pulse2.modified(_.sort.fields) || pulse2.modified("datum");
    if (mod)
      pulse2.source.sort(stableCompare(_.sort));
    this.modified(mod);
    return pulse2;
  }
});
var Zero = "zero";
var Center = "center";
var Normalize = "normalize";
var DefOutput = ["y0", "y1"];
function Stack(params2) {
  Transform.call(this, null, params2);
}
Stack.Definition = {
  "type": "Stack",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "offset",
    "type": "enum",
    "default": Zero,
    "values": [Zero, Center, Normalize]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": DefOutput
  }]
};
inherits(Stack, Transform, {
  transform(_, pulse2) {
    var as = _.as || DefOutput, y06 = as[0], y12 = as[1], sort2 = stableCompare(_.sort), field3 = _.field || one, stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero, groups, i, n, max4;
    groups = partition2(pulse2.source, _.groupby, sort2, field3);
    for (i = 0, n = groups.length, max4 = groups.max; i < n; ++i) {
      stack(groups[i], max4, field3, y06, y12);
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function stackCenter(group2, max4, field3, y06, y12) {
  var last = (max4 - group2.sum) / 2, m2 = group2.length, j = 0, t;
  for (; j < m2; ++j) {
    t = group2[j];
    t[y06] = last;
    t[y12] = last += Math.abs(field3(t));
  }
}
function stackNormalize(group2, max4, field3, y06, y12) {
  var scale6 = 1 / group2.sum, last = 0, m2 = group2.length, j = 0, v = 0, t;
  for (; j < m2; ++j) {
    t = group2[j];
    t[y06] = last;
    t[y12] = last = scale6 * (v += Math.abs(field3(t)));
  }
}
function stackZero(group2, max4, field3, y06, y12) {
  var lastPos = 0, lastNeg = 0, m2 = group2.length, j = 0, v, t;
  for (; j < m2; ++j) {
    t = group2[j];
    v = +field3(t);
    if (v < 0) {
      t[y06] = lastNeg;
      t[y12] = lastNeg += v;
    } else {
      t[y06] = lastPos;
      t[y12] = lastPos += v;
    }
  }
}
function partition2(data3, groupby, sort2, field3) {
  var groups = [], get6 = (f) => f(t), map3, i, n, m2, t, k, g, s, max4;
  if (groupby == null) {
    groups.push(data3.slice());
  } else {
    for (map3 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k = groupby.map(get6);
      g = map3[k];
      if (!g) {
        map3[k] = g = [];
        groups.push(g);
      }
      g.push(t);
    }
  }
  for (k = 0, max4 = 0, m2 = groups.length; k < m2; ++k) {
    g = groups[k];
    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field3(g[i]));
    }
    g.sum = s;
    if (s > max4)
      max4 = s;
    if (sort2)
      g.sort(sort2);
  }
  groups.max = max4;
  return groups;
}

// node_modules/vega-geo/build/vega-geo.module.js
var vega_geo_module_exports = {};
__export(vega_geo_module_exports, {
  contour: () => Contour,
  geojson: () => GeoJSON,
  geopath: () => GeoPath,
  geopoint: () => GeoPoint,
  geoshape: () => GeoShape,
  graticule: () => Graticule,
  heatmap: () => Heatmap,
  isocontour: () => Isocontour,
  kde2d: () => KDE2D,
  projection: () => Projection
});

// node_modules/d3-geo/src/math.js
var epsilon4 = 1e-6;
var epsilon23 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees3 = 180 / pi3;
var radians2 = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil = Math.ceil;
var exp3 = Math.exp;
var hypot = Math.hypot;
var log4 = Math.log;
var pow4 = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x5) {
  return x5 > 0 ? 1 : x5 < 0 ? -1 : 0;
};
var sqrt3 = Math.sqrt;
var tan = Math.tan;
function acos2(x5) {
  return x5 > 1 ? 0 : x5 < -1 ? pi3 : Math.acos(x5);
}
function asin2(x5) {
  return x5 > 1 ? halfPi2 : x5 < -1 ? -halfPi2 : Math.asin(x5);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream2) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream2);
  }
}
var streamObjectType = {
  Feature: function(object2, stream2) {
    streamGeometry(object2.geometry, stream2);
  },
  FeatureCollection: function(object2, stream2) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream2);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream2) {
    stream2.sphere();
  },
  Point: function(object2, stream2) {
    object2 = object2.coordinates;
    stream2.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object2 = coordinates[i], stream2.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream2) {
    streamLine(object2.coordinates, stream2, 0);
  },
  MultiLineString: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream2, 0);
  },
  Polygon: function(object2, stream2) {
    streamPolygon(object2.coordinates, stream2);
  },
  MultiPolygon: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream2);
  },
  GeometryCollection: function(object2, stream2) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream2);
  }
};
function streamLine(coordinates, stream2, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream2.lineStart();
  while (++i < n)
    coordinate = coordinates[i], stream2.point(coordinate[0], coordinate[1], coordinate[2]);
  stream2.lineEnd();
}
function streamPolygon(coordinates, stream2) {
  var i = -1, n = coordinates.length;
  stream2.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream2, 1);
  stream2.polygonEnd();
}
function stream_default(object2, stream2) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream2);
  } else {
    streamGeometry(object2, stream2);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;
var areaStream = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaRingSum = new Adder();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau3 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop2;
  },
  sphere: function() {
    areaSum.add(tau3);
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaRingEnd() {
  areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi2) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians2, phi2 *= radians2;
  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);
}
function areaPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos2(adLambda), v = k * sdLambda * sin2(adLambda);
  areaRingSum.add(atan22(v, u));
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
function area_default2(object2) {
  areaSum = new Adder();
  stream_default(object2, areaStream);
  return areaSum * 2;
}

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cartesianCross(a2, b2) {
  return [a2[1] * b2[2] - a2[2] * b2[1], a2[2] * b2[0] - a2[0] * b2[2], a2[0] * b2[1] - a2[1] * b2[0]];
}
function cartesianAddInPlace(a2, b2) {
  a2[0] += b2[0], a2[1] += b2[1], a2[2] += b2[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt3(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// node_modules/d3-geo/src/bounds.js
var lambda02;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda002;
var phi002;
var p0;
var deltaSum;
var ranges;
var range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum = new Adder();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0)
      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon4)
      phi1 = 90;
    else if (deltaSum < -epsilon4)
      phi0 = -90;
    range[0] = lambda02, range[1] = lambda1;
  },
  sphere: function() {
    lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};
function boundsPoint(lambda, phi2) {
  ranges.push(range = [lambda02 = lambda, lambda1 = lambda]);
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians2, phi2 * radians2]);
  if (p0) {
    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign3 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign3, phii, antimeridian = abs2(delta) > 180;
    if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
      phii = inflection[1] * degrees3;
      if (phii > phi1)
        phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
      phii = -inflection[1] * degrees3;
      if (phii < phi0)
        phi0 = phii;
    } else {
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda02, lambda) > angle(lambda02, lambda1))
          lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda02, lambda1))
          lambda02 = lambda;
      }
    } else {
      if (lambda1 >= lambda02) {
        if (lambda < lambda02)
          lambda02 = lambda;
        if (lambda > lambda1)
          lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1))
            lambda02 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda02 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream.point = linePoint;
}
function boundsLineEnd() {
  range[0] = lambda02, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda002 = lambda, phi002 = phi2;
  }
  areaStream.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda002, phi002);
  areaStream.lineEnd();
  if (abs2(deltaSum) > epsilon4)
    lambda02 = -(lambda1 = 180);
  range[0] = lambda02, range[1] = lambda1;
  p0 = null;
}
function angle(lambda03, lambda12) {
  return (lambda12 -= lambda03) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a2, b2) {
  return a2[0] - b2[0];
}
function rangeContains(range4, x5) {
  return range4[0] <= range4[1] ? range4[0] <= x5 && x5 <= range4[1] : x5 < range4[0] || range4[1] < x5;
}
function bounds_default(feature2) {
  var i, n, a2, b2, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
  ranges = [];
  stream_default(feature2, boundsStream);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a2 = ranges[0], merged = [a2]; i < n; ++i) {
      b2 = ranges[i];
      if (rangeContains(a2, b2[0]) || rangeContains(a2, b2[1])) {
        if (angle(a2[0], b2[1]) > angle(a2[0], a2[1]))
          a2[1] = b2[1];
        if (angle(b2[0], a2[1]) > angle(a2[0], a2[1]))
          a2[0] = b2[0];
      } else {
        merged.push(a2 = b2);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a2 = merged[n]; i <= n; a2 = b2, ++i) {
      b2 = merged[i];
      if ((delta = angle(a2[1], b2[0])) > deltaMax)
        deltaMax = delta, lambda02 = b2[0], lambda1 = a2[1];
    }
  }
  ranges = range = null;
  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
}

// node_modules/d3-geo/src/centroid.js
var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda003;
var phi003;
var x0;
var y0;
var z0;
var centroidStream = {
  sphere: noop2,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};
function centroidPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
}
function centroidPointCartesian(x5, y5, z) {
  ++W0;
  X0 += (x5 - X0) / W0;
  Y0 += (y5 - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x5 = cosPhi * cos2(lambda), y5 = cosPhi * sin2(lambda), z = sin2(phi2), w2 = atan22(sqrt3((w2 = y0 * z - z0 * y5) * w2 + (w2 = z0 * x5 - x0 * z) * w2 + (w2 = x0 * y5 - y0 * x5) * w2), x0 * x5 + y0 * y5 + z0 * z);
  W1 += w2;
  X1 += w2 * (x0 + (x0 = x5));
  Y1 += w2 * (y0 + (y0 = y5));
  Z1 += w2 * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda003, phi003);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda003 = lambda, phi003 = phi2;
  lambda *= radians2, phi2 *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x5 = cosPhi * cos2(lambda), y5 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y5, cy = z0 * x5 - x0 * z, cz = x0 * y5 - y0 * x5, m2 = hypot(cx, cy, cz), w2 = asin2(m2), v = m2 && -w2 / m2;
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w2;
  X1 += w2 * (x0 + (x0 = x5));
  Y1 += w2 * (y0 + (y0 = y5));
  Z1 += w2 * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object2) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder();
  Y2 = new Adder();
  Z2 = new Adder();
  stream_default(object2, centroidStream);
  var x5 = +X2, y5 = +Y2, z = +Z2, m2 = hypot(x5, y5, z);
  if (m2 < epsilon23) {
    x5 = X1, y5 = Y1, z = Z1;
    if (W1 < epsilon4)
      x5 = X0, y5 = Y0, z = Z0;
    m2 = hypot(x5, y5, z);
    if (m2 < epsilon23)
      return [NaN, NaN];
  }
  return [atan22(y5, x5) * degrees3, asin2(z / m2) * degrees3];
}

// node_modules/d3-geo/src/compose.js
function compose_default(a2, b2) {
  function compose(x5, y5) {
    return x5 = a2(x5, y5), b2(x5[0], x5[1]);
  }
  if (a2.invert && b2.invert)
    compose.invert = function(x5, y5) {
      return x5 = b2.invert(x5, y5), x5 && a2.invert(x5[0], x5[1]);
    };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  return [abs2(lambda) > pi3 ? lambda + Math.round(-lambda / tau3) * tau3 : lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi3 ? lambda - tau3 : lambda < -pi3 ? lambda + tau3 : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x5 = cos2(lambda) * cosPhi, y5 = sin2(lambda) * cosPhi, z = sin2(phi2), k = z * cosDeltaPhi + x5 * sinDeltaPhi;
    return [
      atan22(y5 * cosDeltaGamma - k * sinDeltaGamma, x5 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k * cosDeltaGamma + y5 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x5 = cos2(lambda) * cosPhi, y5 = sin2(lambda) * cosPhi, z = sin2(phi2), k = z * cosDeltaGamma - y5 * sinDeltaGamma;
    return [
      atan22(y5 * cosDeltaGamma + z * sinDeltaGamma, x5 * cosDeltaPhi + k * sinDeltaPhi),
      asin2(k * cosDeltaPhi - x5 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate2) {
  rotate2 = rotateRadians(rotate2[0] * radians2, rotate2[1] * radians2, rotate2.length > 2 ? rotate2[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate2(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate2.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream2, radius2, delta, direction, t05, t14) {
  if (!delta)
    return;
  var cosRadius = cos2(radius2), sinRadius = sin2(radius2), step = direction * delta;
  if (t05 == null) {
    t05 = radius2 + direction * tau3;
    t14 = radius2 - step / 2;
  } else {
    t05 = circleRadius(cosRadius, t05);
    t14 = circleRadius(cosRadius, t14);
    if (direction > 0 ? t05 < t14 : t05 > t14)
      t05 += direction * tau3;
  }
  for (var point7, t = t05; direction > 0 ? t > t14 : t < t14; t -= step) {
    point7 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream2.point(point7[0], point7[1]);
  }
}
function circleRadius(cosRadius, point7) {
  point7 = cartesian(point7), point7[0] -= cosRadius;
  cartesianNormalizeInPlace(point7);
  var radius2 = acos2(-point7[1]);
  return ((-point7[2] < 0 ? -radius2 : radius2) + tau3 - epsilon4) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line3;
  return {
    point: function(x5, y5, m2) {
      line3.push([x5, y5, m2]);
    },
    lineStart: function() {
      lines.push(line3 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line3 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a2, b2) {
  return abs2(a2[0] - b2[0]) < epsilon4 && abs2(a2[1] - b2[1]) < epsilon4;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point7, points2, other, entry2) {
  this.x = point7;
  this.z = points2;
  this.o = other;
  this.e = entry2;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments2, compareIntersection2, startInside, interpolate2, stream2) {
  var subject = [], clip3 = [], i, n;
  segments2.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p02 = segment[0], p1 = segment[n2], x5;
    if (pointEqual_default(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream2.lineStart();
        for (i = 0; i < n2; ++i)
          stream2.point((p02 = segment[i])[0], p02[1]);
        stream2.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon4;
    }
    subject.push(x5 = new Intersection(p02, segment, null, true));
    clip3.push(x5.o = new Intersection(p02, null, x5, false));
    subject.push(x5 = new Intersection(p1, segment, null, false));
    clip3.push(x5.o = new Intersection(p1, null, x5, true));
  });
  if (!subject.length)
    return;
  clip3.sort(compareIntersection2);
  link(subject);
  link(clip3);
  for (i = 0, n = clip3.length; i < n; ++i) {
    clip3[i].e = startInside = !startInside;
  }
  var start = subject[0], points2, point7;
  while (1) {
    var current = start, isSubject = true;
    while (current.v)
      if ((current = current.n) === start)
        return;
    points2 = current.z;
    stream2.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i)
            stream2.point((point7 = points2[i])[0], point7[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream2);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points2 = current.p.z;
          for (i = points2.length - 1; i >= 0; --i)
            stream2.point((point7 = points2[i])[0], point7[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream2);
        }
        current = current.p;
      }
      current = current.o;
      points2 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream2.lineEnd();
  }
}
function link(array4) {
  if (!(n = array4.length))
    return;
  var n, i = 0, a2 = array4[0], b2;
  while (++i < n) {
    a2.n = b2 = array4[i];
    b2.p = a2;
    a2 = b2;
  }
  a2.n = b2 = array4[0];
  b2.p = a2;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point7) {
  if (abs2(point7[0]) <= pi3)
    return point7[0];
  else
    return sign2(point7[0]) * ((abs2(point7[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point7) {
  var lambda = longitude(point7), phi2 = point7[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum2 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi2 + epsilon4;
  else if (sinPhi === -1)
    phi2 = -halfPi2 - epsilon4;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m2 = (ring = polygon[i]).length))
      continue;
    var ring, m2, point0 = ring[m2 - 1], lambda03 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin2(phi02), cosPhi02 = cos2(phi02);
    for (var j = 0; j < m2; ++j, lambda03 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda03, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k = sinPhi02 * sinPhi1;
      sum2.add(atan22(k * sign3 * sin2(absDelta), cosPhi02 * cosPhi1 + k * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda03 >= lambda ^ lambda12 >= lambda) {
        var arc3 = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc3);
        var intersection = cartesianCross(normal, arc3);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc3[0] || arc3[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon4 || angle2 < epsilon4 && sum2 < -epsilon23) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate2, start) {
  return function(sink) {
    var line3 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments2, ring;
    var clip3 = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip3.point = pointRing;
        clip3.lineStart = ringStart;
        clip3.lineEnd = ringEnd;
        segments2 = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip3.point = point7;
        clip3.lineStart = lineStart;
        clip3.lineEnd = lineEnd;
        segments2 = merge2(segments2);
        var startInside = polygonContains_default(polygon, start);
        if (segments2.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments2, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments2 = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point7(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line3.point(lambda, phi2);
    }
    function lineStart() {
      clip3.point = pointLine;
      line3.lineStart();
    }
    function lineEnd() {
      clip3.point = point7;
      line3.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point8;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m2; ++i)
            sink.point((point8 = segment[i])[0], point8[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments2.push(ringSegments.filter(validSegment));
    }
    return clip3;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a2, b2) {
  return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi2 - epsilon4 : halfPi2 - a2[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi2 - epsilon4 : halfPi2 - b2[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(function() {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi3, -halfPi2]);
function clipAntimeridianLine(stream2) {
  var lambda03 = NaN, phi02 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream2.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi3 : -pi3, delta = abs2(lambda12 - lambda03);
      if (abs2(delta - pi3) < epsilon4) {
        stream2.point(lambda03, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi2 : -halfPi2);
        stream2.point(sign0, phi02);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi02);
        stream2.point(lambda12, phi02);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda03 - sign0) < epsilon4)
          lambda03 -= sign0 * epsilon4;
        if (abs2(lambda12 - sign1) < epsilon4)
          lambda12 -= sign1 * epsilon4;
        phi02 = clipAntimeridianIntersect(lambda03, phi02, lambda12, phi12);
        stream2.point(sign0, phi02);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi02);
        clean = 0;
      }
      stream2.point(lambda03 = lambda12, phi02 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream2.lineEnd();
      lambda03 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda03, phi02, lambda12, phi12) {
  var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin2(lambda03 - lambda12);
  return abs2(sinLambda0Lambda1) > epsilon4 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi02 = cos2(phi02)) * sin2(lambda03)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream2) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream2.point(-pi3, phi2);
    stream2.point(0, phi2);
    stream2.point(pi3, phi2);
    stream2.point(pi3, 0);
    stream2.point(pi3, -phi2);
    stream2.point(0, -phi2);
    stream2.point(-pi3, -phi2);
    stream2.point(-pi3, 0);
    stream2.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon4) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream2.point(-lambda, phi2);
    stream2.point(0, phi2);
    stream2.point(lambda, phi2);
  } else {
    stream2.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius2) {
  var cr2 = cos2(radius2), delta = 6 * radians2, smallRadius = cr2 > 0, notHemisphere = abs2(cr2) > epsilon4;
  function interpolate2(from, to, direction, stream2) {
    circleStream(stream2, radius2, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr2;
  }
  function clipLine(stream2) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c2 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v))
          stream2.lineStart();
        if (v !== v0) {
          point22 = intersect5(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream2.lineStart();
            point22 = intersect5(point1, point0);
            stream2.point(point22[0], point22[1]);
          } else {
            point22 = intersect5(point0, point1);
            stream2.point(point22[0], point22[1], 2);
            stream2.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c2 & c0) && (t = intersect5(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream2.lineStart();
              stream2.point(t[0][0], t[0][1]);
              stream2.point(t[1][0], t[1][1]);
              stream2.lineEnd();
            } else {
              stream2.point(t[1][0], t[1][1]);
              stream2.lineEnd();
              stream2.lineStart();
              stream2.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream2.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c2;
      },
      lineEnd: function() {
        if (v0)
          stream2.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect5(a2, b2, two) {
    var pa2 = cartesian(a2), pb = cartesian(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa2, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a2;
    var c1 = cr2 * n2n2 / determinant, c2 = -cr2 * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
    cartesianAddInPlace(A5, B2);
    var u = n1xn2, w2 = cartesianDot(A5, u), uu = cartesianDot(u, u), t23 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
    if (t23 < 0)
      return;
    var t = sqrt3(t23), q = cartesianScale(u, (-w2 - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two)
      return q;
    var lambda03 = a2[0], lambda12 = b2[0], phi02 = a2[1], phi12 = b2[1], z;
    if (lambda12 < lambda03)
      z = lambda03, lambda03 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda03, polar = abs2(delta2 - pi3) < epsilon4, meridian = polar || delta2 < epsilon4;
    if (!polar && phi12 < phi02)
      z = phi02, phi02 = phi12, phi12 = z;
    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs2(q[0] - lambda03) < epsilon4 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi3 ^ (lambda03 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u, (-w2 + t) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius2 : pi3 - radius2, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi2 < -r)
      code2 |= 4;
    else if (phi2 > r)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate2, smallRadius ? [0, -radius2] : [-pi3, radius2 - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a2, b2, x06, y06, x12, y12) {
  var ax = a2[0], ay = a2[1], bx = b2[0], by = b2[1], t05 = 0, t14 = 1, dx = bx - ax, dy = by - ay, r;
  r = x06 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t05)
      return;
    if (r < t14)
      t14 = r;
  } else if (dx > 0) {
    if (r > t14)
      return;
    if (r > t05)
      t05 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t14)
      return;
    if (r > t05)
      t05 = r;
  } else if (dx > 0) {
    if (r < t05)
      return;
    if (r < t14)
      t14 = r;
  }
  r = y06 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t05)
      return;
    if (r < t14)
      t14 = r;
  } else if (dy > 0) {
    if (r > t14)
      return;
    if (r > t05)
      t05 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t14)
      return;
    if (r > t05)
      t05 = r;
  } else if (dy > 0) {
    if (r < t05)
      return;
    if (r < t14)
      t14 = r;
  }
  if (t05 > 0)
    a2[0] = ax + t05 * dx, a2[1] = ay + t05 * dy;
  if (t14 < 1)
    b2[0] = ax + t14 * dx, b2[1] = ay + t14 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x06, y06, x12, y12) {
  function visible(x5, y5) {
    return x06 <= x5 && x5 <= x12 && y06 <= y5 && y5 <= y12;
  }
  function interpolate2(from, to, direction, stream2) {
    var a2 = 0, a1 = 0;
    if (from == null || (a2 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream2.point(a2 === 0 || a2 === 3 ? x06 : x12, a2 > 1 ? y12 : y06);
      while ((a2 = (a2 + direction + 4) % 4) !== a1);
    } else {
      stream2.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs2(p[0] - x06) < epsilon4 ? direction > 0 ? 0 : 3 : abs2(p[0] - x12) < epsilon4 ? direction > 0 ? 2 : 1 : abs2(p[1] - y06) < epsilon4 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a2, b2) {
    return comparePoint(a2.x, b2.x);
  }
  function comparePoint(a2, b2) {
    var ca = corner(a2, 1), cb = corner(b2, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a2[1] : ca === 1 ? a2[0] - b2[0] : ca === 2 ? a2[1] - b2[1] : b2[0] - a2[0];
  }
  return function(stream2) {
    var activeStream = stream2, bufferStream = buffer_default(), segments2, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point7(x5, y5) {
      if (visible(x5, y5))
        activeStream.point(x5, y5);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m2 = ring2.length, point8 = ring2[0], a0, a1, b0 = point8[0], b1 = point8[1]; j < m2; ++j) {
          a0 = b0, a1 = b1, point8 = ring2[j], b0 = point8[0], b1 = point8[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x06 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x06 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments2 = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments2 = merge2(segments2)).length;
      if (cleanInside || visible2) {
        stream2.polygonStart();
        if (cleanInside) {
          stream2.lineStart();
          interpolate2(null, null, 1, stream2);
          stream2.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments2, compareIntersection2, startInside, interpolate2, stream2);
        }
        stream2.polygonEnd();
      }
      activeStream = stream2, segments2 = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments2) {
        linePoint2(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments2.push(bufferStream.result());
      }
      clipStream.point = point7;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint2(x5, y5) {
      var v = visible(x5, y5);
      if (polygon)
        ring.push([x5, y5]);
      if (first) {
        x__ = x5, y__ = y5, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x5, y5);
        }
      } else {
        if (v && v_)
          activeStream.point(x5, y5);
        else {
          var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x5 = Math.max(clipMin, Math.min(clipMax, x5)), y5 = Math.max(clipMin, Math.min(clipMax, y5))];
          if (line_default2(a2, b2, x06, y06, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a2[0], a2[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x5, y5);
            clean = false;
          }
        }
      }
      x_ = x5, y_ = y5, v_ = v;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y06, y12, dy) {
  var y5 = range_default(y06, y12 - epsilon4, dy).concat(y12);
  return function(x5) {
    return y5.map(function(y6) {
      return [x5, y6];
    });
  };
}
function graticuleY(x06, x12, dx) {
  var x5 = range_default(x06, x12 - epsilon4, dx).concat(x12);
  return function(y5) {
    return x5.map(function(x6) {
      return [x6, y5];
    });
  };
}
function graticule() {
  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x5, y5, X3, Y3, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range_default(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range_default(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range_default(ceil(x06 / dx) * dx, x12, dx).filter(function(x6) {
      return abs2(x6 % DX) > epsilon4;
    }).map(x5)).concat(range_default(ceil(y06 / dy) * dy, y12, dy).filter(function(y6) {
      return abs2(y6 % DY) > epsilon4;
    }).map(y5));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X03).concat(Y3(Y13).slice(1), X3(X13).reverse().slice(1), Y3(Y03).reverse().slice(1))
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length)
      return [[X03, Y03], [X13, Y13]];
    X03 = +_[0][0], X13 = +_[1][0];
    Y03 = +_[0][1], Y13 = +_[1][1];
    if (X03 > X13)
      _ = X03, X03 = X13, X13 = _;
    if (Y03 > Y13)
      _ = Y03, Y03 = Y13, Y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length)
      return [[x06, y06], [x12, y12]];
    x06 = +_[0][0], x12 = +_[1][0];
    y06 = +_[0][1], y12 = +_[1][1];
    if (x06 > x12)
      _ = x06, x06 = x12, x12 = _;
    if (y06 > y12)
      _ = y06, y06 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length)
      return precision;
    precision = +_;
    x5 = graticuleX(y06, y12, 90);
    y5 = graticuleY(x06, x12, precision);
    X3 = graticuleX(Y03, Y13, 90);
    Y3 = graticuleY(X03, X13, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon4], [180, 90 - epsilon4]]).extentMinor([[-180, -80 - epsilon4], [180, 80 + epsilon4]]);
}

// node_modules/d3-geo/src/identity.js
var identity_default3 = (x5) => x5;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x02;
var y02;
var areaStream2 = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart2;
    areaStream2.lineEnd = areaRingEnd2;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area3 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area3;
  }
};
function areaRingStart2() {
  areaStream2.point = areaPointFirst2;
}
function areaPointFirst2(x5, y5) {
  areaStream2.point = areaPoint2;
  x00 = x02 = x5, y00 = y02 = y5;
}
function areaPoint2(x5, y5) {
  areaRingSum2.add(y02 * x5 - x02 * y5);
  x02 = x5, y02 = y5;
}
function areaRingEnd2() {
  areaPoint2(x00, y00);
}
var area_default3 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x03 = Infinity;
var y03 = x03;
var x1 = -x03;
var y1 = x1;
var boundsStream2 = {
  point: boundsPoint2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds2 = [[x03, y03], [x1, y1]];
    x1 = y1 = -(y03 = x03 = Infinity);
    return bounds2;
  }
};
function boundsPoint2(x5, y5) {
  if (x5 < x03)
    x03 = x5;
  if (x5 > x1)
    x1 = x5;
  if (y5 < y03)
    y03 = y5;
  if (y5 > y1)
    y1 = y5;
}
var bounds_default2 = boundsStream2;

// node_modules/d3-geo/src/path/centroid.js
var X02 = 0;
var Y02 = 0;
var Z02 = 0;
var X12 = 0;
var Y12 = 0;
var Z12 = 0;
var X22 = 0;
var Y22 = 0;
var Z22 = 0;
var x002;
var y002;
var x04;
var y04;
var centroidStream2 = {
  point: centroidPoint2,
  lineStart: centroidLineStart2,
  lineEnd: centroidLineEnd2,
  polygonStart: function() {
    centroidStream2.lineStart = centroidRingStart2;
    centroidStream2.lineEnd = centroidRingEnd2;
  },
  polygonEnd: function() {
    centroidStream2.point = centroidPoint2;
    centroidStream2.lineStart = centroidLineStart2;
    centroidStream2.lineEnd = centroidLineEnd2;
  },
  result: function() {
    var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
    return centroid;
  }
};
function centroidPoint2(x5, y5) {
  X02 += x5;
  Y02 += y5;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x5, y5) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x5, y04 = y5);
}
function centroidPointLine(x5, y5) {
  var dx = x5 - x04, dy = y5 - y04, z = sqrt3(dx * dx + dy * dy);
  X12 += z * (x04 + x5) / 2;
  Y12 += z * (y04 + y5) / 2;
  Z12 += z;
  centroidPoint2(x04 = x5, y04 = y5);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x5, y5) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x5, y002 = y04 = y5);
}
function centroidPointRing(x5, y5) {
  var dx = x5 - x04, dy = y5 - y04, z = sqrt3(dx * dx + dy * dy);
  X12 += z * (x04 + x5) / 2;
  Y12 += z * (y04 + y5) / 2;
  Z12 += z;
  z = y04 * x5 - x04 * y5;
  X22 += z * (x04 + x5);
  Y22 += z * (y04 + y5);
  Z22 += z * 3;
  centroidPoint2(x04 = x5, y04 = y5);
}
var centroid_default2 = centroidStream2;

// node_modules/d3-geo/src/path/context.js
function PathContext(context3) {
  this._context = context3;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x5, y5) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x5, y5);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x5, y5);
        break;
      }
      default: {
        this._context.moveTo(x5 + this._radius, y5);
        this._context.arc(x5, y5, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x05;
var y05;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum;
    lengthSum = new Adder();
    return length2;
  }
};
function lengthPointFirst(x5, y5) {
  lengthStream.point = lengthPoint;
  x003 = x05 = x5, y003 = y05 = y5;
}
function lengthPoint(x5, y5) {
  x05 -= x5, y05 -= y5;
  lengthSum.add(sqrt3(x05 * x05 + y05 * y05));
  x05 = x5, y05 = y5;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius)
      this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._string.push("Z");
    this._point = NaN;
  },
  point: function(x5, y5) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x5, ",", y5);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x5, ",", y5);
        break;
      }
      default: {
        if (this._circle == null)
          this._circle = circle(this._radius);
        this._string.push("M", x5, ",", y5, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};
function circle(radius2) {
  return "m0," + radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + -2 * radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + 2 * radius2 + "z";
}

// node_modules/d3-geo/src/path/index.js
function path_default2(projection3, context3) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path3(object2) {
    if (object2) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path3.area = function(object2) {
    stream_default(object2, projectionStream(area_default3));
    return area_default3.result();
  };
  path3.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path3.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default2));
    return bounds_default2.result();
  };
  path3.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path3.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection3 = null, identity_default3) : (projection3 = _).stream, path3) : projection3;
  };
  path3.context = function(_) {
    if (!arguments.length)
      return context3;
    contextStream = _ == null ? (context3 = null, new PathString()) : new PathContext(context3 = _);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path3;
  };
  path3.pointRadius = function(_) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path3;
  };
  return path3.projection(projection3).context(context3);
}

// node_modules/d3-geo/src/transform.js
function transformer4(methods2) {
  return function(stream2) {
    var s = new TransformStream();
    for (var key2 in methods2)
      s[key2] = methods2[key2];
    s.stream = stream2;
    return s;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x5, y5) {
    this.stream.point(x5, y5);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object2) {
  var clip3 = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip3 != null)
    projection3.clipExtent(null);
  stream_default(object2, projection3.stream(bounds_default2));
  fitBounds(bounds_default2.result());
  if (clip3 != null)
    projection3.clipExtent(clip3);
  return projection3;
}
function fitExtent(projection3, extent2, object2) {
  return fit(projection3, function(b2) {
    var w2 = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k = Math.min(w2 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x5 = +extent2[0][0] + (w2 - k * (b2[1][0] + b2[0][0])) / 2, y5 = +extent2[0][1] + (h2 - k * (b2[1][1] + b2[0][1])) / 2;
    projection3.scale(150 * k).translate([x5, y5]);
  }, object2);
}
function fitSize(projection3, size, object2) {
  return fitExtent(projection3, [[0, 0], size], object2);
}
function fitWidth(projection3, width2, object2) {
  return fit(projection3, function(b2) {
    var w2 = +width2, k = w2 / (b2[1][0] - b2[0][0]), x5 = (w2 - k * (b2[1][0] + b2[0][0])) / 2, y5 = -k * b2[0][1];
    projection3.scale(150 * k).translate([x5, y5]);
  }, object2);
}
function fitHeight(projection3, height2, object2) {
  return fit(projection3, function(b2) {
    var h2 = +height2, k = h2 / (b2[1][1] - b2[0][1]), x5 = -k * b2[0][0], y5 = (h2 - k * (b2[1][1] + b2[0][1])) / 2;
    projection3.scale(150 * k).translate([x5, y5]);
  }, object2);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians2);
function resample_default(project2, delta2) {
  return +delta2 ? resample(project2, delta2) : resampleNone(project2);
}
function resampleNone(project2) {
  return transformer4({
    point: function(x5, y5) {
      x5 = project2(x5, y5);
      this.stream.point(x5[0], x5[1]);
    }
  });
}
function resample(project2, delta2) {
  function resampleLineTo(x06, y06, lambda03, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream2) {
    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a2 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt3(a2 * a2 + b2 * b2 + c2 * c2), phi2 = asin2(c2 /= m2), lambda22 = abs2(abs2(c2) - 1) < epsilon4 || abs2(lambda03 - lambda12) < epsilon4 ? (lambda03 + lambda12) / 2 : atan22(b2, a2), p = project2(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x06, y06, lambda03, a0, b0, c0, x22, y22, lambda22, a2 /= m2, b2 /= m2, c2, depth, stream2);
        stream2.point(x22, y22);
        resampleLineTo(x22, y22, lambda22, a2, b2, c2, x12, y12, lambda12, a1, b1, c1, depth, stream2);
      }
    }
  }
  return function(stream2) {
    var lambda004, x004, y004, a00, b00, c00, lambda03, x06, y06, a0, b0, c0;
    var resampleStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream2.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream2.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point7(x5, y5) {
      x5 = project2(x5, y5);
      stream2.point(x5[0], x5[1]);
    }
    function lineStart() {
      x06 = NaN;
      resampleStream.point = linePoint2;
      stream2.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c2 = cartesian([lambda, phi2]), p = project2(lambda, phi2);
      resampleLineTo(x06, y06, lambda03, a0, b0, c0, x06 = p[0], y06 = p[1], lambda03 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream2);
      stream2.point(x06, y06);
    }
    function lineEnd() {
      resampleStream.point = point7;
      stream2.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x06, y06, lambda03, a0, b0, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream2);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer4({
  point: function(x5, y5) {
    this.stream.point(x5 * radians2, y5 * radians2);
  }
});
function transformRotate(rotate2) {
  return transformer4({
    point: function(x5, y5) {
      var r = rotate2(x5, y5);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k, dx, dy, sx, sy) {
  function transform4(x5, y5) {
    x5 *= sx;
    y5 *= sy;
    return [dx + k * x5, dy - k * y5];
  }
  transform4.invert = function(x5, y5) {
    return [(x5 - dx) / k * sx, (dy - y5) / k * sy];
  };
  return transform4;
}
function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a2 = cosAlpha * k, b2 = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform4(x5, y5) {
    x5 *= sx;
    y5 *= sy;
    return [a2 * x5 - b2 * y5 + dx, dy - b2 * x5 - a2 * y5];
  }
  transform4.invert = function(x5, y5) {
    return [sx * (ai * x5 - bi * y5 + ci), sy * (fi - bi * x5 - ai * y5)];
  };
  return transform4;
}
function projection(project2) {
  return projectionMutator(function() {
    return project2;
  })();
}
function projectionMutator(projectAt) {
  var project2, k = 150, x5 = 480, y5 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate2, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection3(point7) {
    return projectRotateTransform(point7[0] * radians2, point7[1] * radians2);
  }
  function invert2(point7) {
    point7 = projectRotateTransform.invert(point7[0], point7[1]);
    return point7 && [point7[0] * degrees3, point7[1] * degrees3];
  }
  projection3.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = transformRadians(transformRotate(rotate2)(preclip(projectResample(postclip(cacheStream = stream2)))));
  };
  projection3.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset2()) : preclip;
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset2()) : postclip;
  };
  projection3.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset2()) : theta * degrees3;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset2()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };
  projection3.translate = function(_) {
    return arguments.length ? (x5 = +_[0], y5 = +_[1], recenter()) : [x5, y5];
  };
  projection3.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
  };
  projection3.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset2()) : sqrt3(delta2);
  };
  projection3.fitExtent = function(extent2, object2) {
    return fitExtent(projection3, extent2, object2);
  };
  projection3.fitSize = function(size, object2) {
    return fitSize(projection3, size, object2);
  };
  projection3.fitWidth = function(width2, object2) {
    return fitWidth(projection3, width2, object2);
  };
  projection3.fitHeight = function(height2, object2) {
    return fitHeight(projection3, height2, object2);
  };
  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi2)), transform4 = scaleTranslateRotate(k, x5 - center[0], y5 - center[1], sx, sy, alpha);
    rotate2 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project2, transform4);
    projectRotateTransform = compose_default(rotate2, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset2();
  }
  function reset2() {
    cache2 = cacheStream = null;
    return projection3;
  }
  return function() {
    project2 = projectAt.apply(this, arguments);
    projection3.invert = project2.invert && invert2;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi02 = 0, phi12 = pi3 / 3, m2 = projectionMutator(projectAt), p = m2(phi02, phi12);
  p.parallels = function(_) {
    return arguments.length ? m2(phi02 = _[0] * radians2, phi12 = _[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];
  };
  return p;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi02 = cos2(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin2(phi2) / cosPhi02];
  }
  forward.invert = function(x5, y5) {
    return [x5 / cosPhi02, asin2(y5 * cosPhi02)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y06, y12) {
  var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;
  if (abs2(n) < epsilon4)
    return cylindricalEqualAreaRaw(y06);
  var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt3(c2) / n;
  function project2(x5, y5) {
    var r = sqrt3(c2 - 2 * n * sin2(y5)) / n;
    return [r * sin2(x5 *= n), r0 - r * cos2(x5)];
  }
  project2.invert = function(x5, y5) {
    var r0y = r0 - y5, l = atan22(x5, abs2(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign2(x5) * sign2(r0y);
    return [l / n, asin2((c2 - (x5 * x5 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project2;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x5, y5) {
      var i = -1;
      while (++i < n)
        streams[i].point(x5, y5);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point7, pointStream = { point: function(x5, y5) {
    point7 = [x5, y5];
  } };
  function albersUsa(coordinates) {
    var x5 = coordinates[0], y5 = coordinates[1];
    return point7 = null, (lower48Point.point(x5, y5), point7) || (alaskaPoint.point(x5, y5), point7) || (hawaiiPoint.point(x5, y5), point7);
  }
  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(), t = lower48.translate(), x5 = (coordinates[0] - t[0]) / k, y5 = (coordinates[1] - t[1]) / k;
    return (y5 >= 0.12 && y5 < 0.234 && x5 >= -0.425 && x5 < -0.214 ? alaska : y5 >= 0.166 && y5 < 0.234 && x5 >= -0.214 && x5 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream2), alaska.stream(stream2), hawaii.stream(stream2)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset2();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length)
      return lower48.translate();
    var k = lower48.scale(), x5 = +_[0], y5 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x5 - 0.455 * k, y5 - 0.238 * k], [x5 + 0.455 * k, y5 + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x5 - 0.307 * k, y5 + 0.201 * k]).clipExtent([[x5 - 0.425 * k + epsilon4, y5 + 0.12 * k + epsilon4], [x5 - 0.214 * k - epsilon4, y5 + 0.234 * k - epsilon4]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x5 - 0.205 * k, y5 + 0.212 * k]).clipExtent([[x5 - 0.214 * k + epsilon4, y5 + 0.166 * k + epsilon4], [x5 - 0.115 * k - epsilon4, y5 + 0.234 * k - epsilon4]]).stream(pointStream);
    return reset2();
  };
  albersUsa.fitExtent = function(extent2, object2) {
    return fitExtent(albersUsa, extent2, object2);
  };
  albersUsa.fitSize = function(size, object2) {
    return fitSize(albersUsa, size, object2);
  };
  albersUsa.fitWidth = function(width2, object2) {
    return fitWidth(albersUsa, width2, object2);
  };
  albersUsa.fitHeight = function(height2, object2) {
    return fitHeight(albersUsa, height2, object2);
  };
  function reset2() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale6) {
  return function(x5, y5) {
    var cx = cos2(x5), cy = cos2(y5), k = scale6(cx * cy);
    if (k === Infinity)
      return [2, 0];
    return [
      k * cy * sin2(x5),
      k * sin2(y5)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x5, y5) {
    var z = sqrt3(x5 * x5 + y5 * y5), c2 = angle2(z), sc = sin2(c2), cc = cos2(c2);
    return [
      atan22(x5 * sc, z * cc),
      asin2(z && y5 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt3(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
  return (c2 = acos2(c2)) && c2 / sin2(c2);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log4(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x5, y5) {
  return [x5, 2 * atan(exp3(y5)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project2) {
  var m2 = projection(project2), center = m2.center, scale6 = m2.scale, translate3 = m2.translate, clipExtent = m2.clipExtent, x06 = null, y06, x12, y12;
  m2.scale = function(_) {
    return arguments.length ? (scale6(_), reclip()) : scale6();
  };
  m2.translate = function(_) {
    return arguments.length ? (translate3(_), reclip()) : translate3();
  };
  m2.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };
  m2.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x06 = y06 = x12 = y12 = null : (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  function reclip() {
    var k = pi3 * scale6(), t = m2(rotation_default(m2.rotate()).invert([0, 0]));
    return clipExtent(x06 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project2 === mercatorRaw ? [[Math.max(t[0] - k, x06), y06], [Math.min(t[0] + k, x12), y12]] : [[x06, Math.max(t[1] - k, y06)], [x12, Math.min(t[1] + k, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y5) {
  return tan((halfPi2 + y5) / 2);
}
function conicConformalRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log4(cy0 / cos2(y12)) / log4(tany(y12) / tany(y06)), f = cy0 * pow4(tany(y06), n) / n;
  if (!n)
    return mercatorRaw;
  function project2(x5, y5) {
    if (f > 0) {
      if (y5 < -halfPi2 + epsilon4)
        y5 = -halfPi2 + epsilon4;
    } else {
      if (y5 > halfPi2 - epsilon4)
        y5 = halfPi2 - epsilon4;
    }
    var r = f / pow4(tany(y5), n);
    return [r * sin2(n * x5), f - r * cos2(n * x5)];
  }
  project2.invert = function(x5, y5) {
    var fy = f - y5, r = sign2(n) * sqrt3(x5 * x5 + fy * fy), l = atan22(x5, abs2(fy)) * sign2(fy);
    if (fy * n < 0)
      l -= pi3 * sign2(x5) * sign2(fy);
    return [l / n, 2 * atan(pow4(f / r, 1 / n)) - halfPi2];
  };
  return project2;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;
  if (abs2(n) < epsilon4)
    return equirectangularRaw;
  function project2(x5, y5) {
    var gy = g - y5, nx = n * x5;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project2.invert = function(x5, y5) {
    var gy = g - y5, l = atan22(x5, abs2(gy)) * sign2(gy);
    if (gy * n < 0)
      l -= pi3 * sign2(x5) * sign2(gy);
    return [l / n, g - sign2(n) * sqrt3(x5 * x5 + gy * gy)];
  };
  return project2;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt3(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin2(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x5, y5) {
  var l = y5, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y5;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon23)
      break;
  }
  return [
    M * x5 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin2(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x5, y5) {
  var cy = cos2(y5), k = cos2(x5) * cy;
  return [cy * sin2(x5) / k, sin2(y5) / k];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default4() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa2, x06 = null, y06, x12, y12, kx = 1, ky = 1, transform4 = transformer4({
    point: function(x5, y5) {
      var p = projection3([x5, y5]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity_default3, cache2, cacheStream;
  function reset2() {
    kx = k * sx;
    ky = k * sy;
    cache2 = cacheStream = null;
    return projection3;
  }
  function projection3(p) {
    var x5 = p[0] * kx, y5 = p[1] * ky;
    if (alpha) {
      var t = y5 * ca - x5 * sa2;
      x5 = x5 * ca + y5 * sa2;
      y5 = t;
    }
    return [x5 + tx, y5 + ty];
  }
  projection3.invert = function(p) {
    var x5 = p[0] - tx, y5 = p[1] - ty;
    if (alpha) {
      var t = y5 * ca + x5 * sa2;
      x5 = x5 * ca - y5 * sa2;
      y5 = t;
    }
    return [x5 / kx, y5 / ky];
  };
  projection3.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = transform4(postclip(cacheStream = stream2));
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset2()) : postclip;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset2()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k = +_, reset2()) : k;
  };
  projection3.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset2()) : [tx, ty];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, sa2 = sin2(alpha), ca = cos2(alpha), reset2()) : alpha * degrees3;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset2()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset2()) : sy < 0;
  };
  projection3.fitExtent = function(extent2, object2) {
    return fitExtent(projection3, extent2, object2);
  };
  projection3.fitSize = function(size, object2) {
    return fitSize(projection3, size, object2);
  };
  projection3.fitWidth = function(width2, object2) {
    return fitWidth(projection3, width2, object2);
  };
  projection3.fitHeight = function(height2, object2) {
    return fitHeight(projection3, height2, object2);
  };
  return projection3;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x5, y5) {
  var phi2 = y5, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y5) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon4 && --i > 0);
  return [
    x5 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x5, y5) {
  return [cos2(y5) * sin2(x5), sin2(y5)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon4);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x5, y5) {
  var cy = cos2(y5), k = 1 + cos2(x5) * cy;
  return [cy * sin2(x5) / k, sin2(y5) / k];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log4(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x5, y5) {
  return [-y5, 2 * atan(exp3(x5)) - halfPi2];
};
function transverseMercator_default() {
  var m2 = mercatorProjection(transverseMercatorRaw), center = m2.center, rotate2 = m2.rotate;
  m2.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };
  m2.rotate = function(_) {
    return arguments.length ? rotate2([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate2(), [_[0], _[1], _[2] - 90]);
  };
  return rotate2([0, 0, 90]).scale(159.155);
}

// node_modules/d3-geo-projection/src/math.js
var abs3 = Math.abs;
var cos3 = Math.cos;
var sin3 = Math.sin;
var epsilon5 = 1e-6;
var pi4 = Math.PI;
var halfPi3 = pi4 / 2;
var quarterPi2 = pi4 / 4;
var sqrt22 = sqrt4(2);
var sqrtPi = sqrt4(pi4);
var tau4 = pi4 * 2;
var degrees4 = 180 / pi4;
var radians3 = pi4 / 180;
function asin3(x5) {
  return x5 > 1 ? halfPi3 : x5 < -1 ? -halfPi3 : Math.asin(x5);
}
function sqrt4(x5) {
  return x5 > 0 ? Math.sqrt(x5) : 0;
}

// node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi2) {
  var cpsinPhi = cp * sin3(phi2), i = 30, delta;
  do
    phi2 -= delta = (phi2 + sin3(phi2) - cpsinPhi) / (1 + cos3(phi2));
  while (abs3(delta) > epsilon5 && --i > 0);
  return phi2 / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi2) {
    return [cx * lambda * cos3(phi2 = mollweideBromleyTheta(cp, phi2)), cy * sin3(phi2)];
  }
  forward.invert = function(x5, y5) {
    return y5 = asin3(y5 / cy), [x5 / (cx * cos3(y5)), asin3((2 * y5 + sin3(2 * y5)) / cp)];
  };
  return forward;
}
var mollweideRaw = mollweideBromleyRaw(sqrt22 / halfPi3, sqrt22, pi4);
function mollweide_default() {
  return projection(mollweideRaw).scale(169.529);
}

// node_modules/vega-projection/build/vega-projection.module.js
var defaultPath = path_default2();
var projectionProperties = [
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function create2(type2, constructor) {
  return function projection3() {
    const p = constructor();
    p.type = type2;
    p.path = path_default2().projection(p);
    p.copy = p.copy || function() {
      const c2 = projection3();
      projectionProperties.forEach((prop) => {
        if (p[prop])
          c2[prop](p[prop]());
      });
      c2.path.pointRadius(p.path.pointRadius());
      return c2;
    };
    return p;
  };
}
function projection2(type2, proj) {
  if (!type2 || typeof type2 !== "string") {
    throw new Error("Projection type must be a name string.");
  }
  type2 = type2.toLowerCase();
  if (arguments.length > 1) {
    projections[type2] = create2(type2, proj);
    return this;
  } else {
    return projections[type2] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
var projections = {
  albers: albers_default,
  albersusa: albersUsa_default,
  azimuthalequalarea: azimuthalEqualArea_default,
  azimuthalequidistant: azimuthalEquidistant_default,
  conicconformal: conicConformal_default,
  conicequalarea: conicEqualArea_default,
  conicequidistant: conicEquidistant_default,
  equalEarth: equalEarth_default,
  equirectangular: equirectangular_default,
  gnomonic: gnomonic_default,
  identity: identity_default4,
  mercator: mercator_default,
  mollweide: mollweide_default,
  naturalEarth1: naturalEarth1_default,
  orthographic: orthographic_default,
  stereographic: stereographic_default,
  transversemercator: transverseMercator_default
};
for (const key2 in projections) {
  projection2(key2, projections[key2]);
}

// node_modules/vega-geo/node_modules/d3-color/src/define.js
function define_default3(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend4(parent, definition3) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition3)
    prototype2[key2] = definition3[key2];
  return prototype2;
}

// node_modules/vega-geo/node_modules/d3-color/src/color.js
function Color3() {
}
var darker3 = 0.7;
var brighter3 = 1 / darker3;
var reI3 = "\\s*([+-]?\\d+)\\s*";
var reN3 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP3 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex3 = /^#([0-9a-f]{3,8})$/;
var reRgbInteger3 = new RegExp("^rgb\\(" + [reI3, reI3, reI3] + "\\)$");
var reRgbPercent3 = new RegExp("^rgb\\(" + [reP3, reP3, reP3] + "\\)$");
var reRgbaInteger3 = new RegExp("^rgba\\(" + [reI3, reI3, reI3, reN3] + "\\)$");
var reRgbaPercent3 = new RegExp("^rgba\\(" + [reP3, reP3, reP3, reN3] + "\\)$");
var reHslPercent3 = new RegExp("^hsl\\(" + [reN3, reP3, reP3] + "\\)$");
var reHslaPercent3 = new RegExp("^hsla\\(" + [reN3, reP3, reP3, reN3] + "\\)$");
var named3 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default3(Color3, color4, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex3,
  formatHex: color_formatHex3,
  formatHsl: color_formatHsl3,
  formatRgb: color_formatRgb3,
  toString: color_formatRgb3
});
function color_formatHex3() {
  return this.rgb().formatHex();
}
function color_formatHsl3() {
  return hslConvert3(this).formatHsl();
}
function color_formatRgb3() {
  return this.rgb().formatRgb();
}
function color4(format5) {
  var m2, l;
  format5 = (format5 + "").trim().toLowerCase();
  return (m2 = reHex3.exec(format5)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn3(m2) : l === 3 ? new Rgb3(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba3(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba3(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger3.exec(format5)) ? new Rgb3(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent3.exec(format5)) ? new Rgb3(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger3.exec(format5)) ? rgba3(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent3.exec(format5)) ? rgba3(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent3.exec(format5)) ? hsla3(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent3.exec(format5)) ? hsla3(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named3.hasOwnProperty(format5) ? rgbn3(named3[format5]) : format5 === "transparent" ? new Rgb3(NaN, NaN, NaN, 0) : null;
}
function rgbn3(n) {
  return new Rgb3(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba3(r, g, b2, a2) {
  if (a2 <= 0)
    r = g = b2 = NaN;
  return new Rgb3(r, g, b2, a2);
}
function rgbConvert3(o) {
  if (!(o instanceof Color3))
    o = color4(o);
  if (!o)
    return new Rgb3();
  o = o.rgb();
  return new Rgb3(o.r, o.g, o.b, o.opacity);
}
function rgb3(r, g, b2, opacity) {
  return arguments.length === 1 ? rgbConvert3(r) : new Rgb3(r, g, b2, opacity == null ? 1 : opacity);
}
function Rgb3(r, g, b2, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default3(Rgb3, rgb3, extend4(Color3, {
  brighter: function(k) {
    k = k == null ? brighter3 : Math.pow(brighter3, k);
    return new Rgb3(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker3 : Math.pow(darker3, k);
    return new Rgb3(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex3,
  formatHex: rgb_formatHex3,
  formatRgb: rgb_formatRgb3,
  toString: rgb_formatRgb3
}));
function rgb_formatHex3() {
  return "#" + hex3(this.r) + hex3(this.g) + hex3(this.b);
}
function rgb_formatRgb3() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex3(value3) {
  value3 = Math.max(0, Math.min(255, Math.round(value3) || 0));
  return (value3 < 16 ? "0" : "") + value3.toString(16);
}
function hsla3(h2, s, l, a2) {
  if (a2 <= 0)
    h2 = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s = NaN;
  else if (s <= 0)
    h2 = NaN;
  return new Hsl3(h2, s, l, a2);
}
function hslConvert3(o) {
  if (o instanceof Hsl3)
    return new Hsl3(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color3))
    o = color4(o);
  if (!o)
    return new Hsl3();
  if (o instanceof Hsl3)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b2 = o.b / 255, min4 = Math.min(r, g, b2), max4 = Math.max(r, g, b2), h2 = NaN, s = max4 - min4, l = (max4 + min4) / 2;
  if (s) {
    if (r === max4)
      h2 = (g - b2) / s + (g < b2) * 6;
    else if (g === max4)
      h2 = (b2 - r) / s + 2;
    else
      h2 = (r - g) / s + 4;
    s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl3(h2, s, l, o.opacity);
}
function hsl4(h2, s, l, opacity) {
  return arguments.length === 1 ? hslConvert3(h2) : new Hsl3(h2, s, l, opacity == null ? 1 : opacity);
}
function Hsl3(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default3(Hsl3, hsl4, extend4(Color3, {
  brighter: function(k) {
    k = k == null ? brighter3 : Math.pow(brighter3, k);
    return new Hsl3(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker3 : Math.pow(darker3, k);
    return new Hsl3(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb3(hsl2rgb3(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb3(h2, m1, m2), hsl2rgb3(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb3(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/vega-geo/build/vega-geo.module.js
function noop3() {
}
var cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function contours() {
  var dx = 1, dy = 1, smooth = smoothLinear;
  function contours2(values2, tz) {
    return tz.map((value3) => contour(values2, value3));
  }
  function contour(values2, value3) {
    var polygons = [], holes = [];
    isorings(values2, value3, (ring) => {
      smooth(ring, values2, value3);
      if (area2(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach((hole) => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value: value3,
      coordinates: polygons
    };
  }
  function isorings(values2, value3, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x5, y5, t05, t14, t23, t33;
    x5 = y5 = -1;
    t14 = values2[0] >= value3;
    cases[t14 << 1].forEach(stitch);
    while (++x5 < dx - 1) {
      t05 = t14, t14 = values2[x5 + 1] >= value3;
      cases[t05 | t14 << 1].forEach(stitch);
    }
    cases[t14 << 0].forEach(stitch);
    while (++y5 < dy - 1) {
      x5 = -1;
      t14 = values2[y5 * dx + dx] >= value3;
      t23 = values2[y5 * dx] >= value3;
      cases[t14 << 1 | t23 << 2].forEach(stitch);
      while (++x5 < dx - 1) {
        t05 = t14, t14 = values2[y5 * dx + dx + x5 + 1] >= value3;
        t33 = t23, t23 = values2[y5 * dx + x5 + 1] >= value3;
        cases[t05 | t14 << 1 | t23 << 2 | t33 << 3].forEach(stitch);
      }
      cases[t14 | t23 << 3].forEach(stitch);
    }
    x5 = -1;
    t23 = values2[y5 * dx] >= value3;
    cases[t23 << 2].forEach(stitch);
    while (++x5 < dx - 1) {
      t33 = t23, t23 = values2[y5 * dx + x5 + 1] >= value3;
      cases[t23 << 2 | t33 << 3].forEach(stitch);
    }
    cases[t23 << 3].forEach(stitch);
    function stitch(line3) {
      var start = [line3[0][0] + x5, line3[0][1] + y5], end = [line3[1][0] + x5, line3[1][1] + y5], startIndex = index3(start), endIndex = index3(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }
  function index3(point7) {
    return point7[0] * 2 + point7[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values2, value3) {
    ring.forEach((point7) => {
      var x5 = point7[0], y5 = point7[1], xt = x5 | 0, yt = y5 | 0, v0, v1 = values2[yt * dx + xt];
      if (x5 > 0 && x5 < dx && xt === x5) {
        v0 = values2[yt * dx + xt - 1];
        point7[0] = x5 + (value3 - v0) / (v1 - v0) - 0.5;
      }
      if (y5 > 0 && y5 < dy && yt === y5) {
        v0 = values2[(yt - 1) * dx + xt];
        point7[1] = y5 + (value3 - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0))
      error("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop3, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function area2(ring) {
  var i = 0, n = ring.length, area3 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area3 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area3;
}
function contains(ring, hole) {
  var i = -1, n = hole.length, c2;
  while (++i < n)
    if (c2 = ringContains(ring, hole[i]))
      return c2;
  return 0;
}
function ringContains(ring, point7) {
  var x5 = point7[0], y5 = point7[1], contains2 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi5 = ring[i], xi = pi5[0], yi = pi5[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi5, pj, point7))
      return 0;
    if (yi > y5 !== yj > y5 && x5 < (xj - xi) * (y5 - yi) / (yj - yi) + xi)
      contains2 = -contains2;
  }
  return contains2;
}
function segmentContains(a2, b2, c2) {
  var i;
  return collinear(a2, b2, c2) && within(a2[i = +(a2[0] === b2[0])], c2[i], b2[i]);
}
function collinear(a2, b2, c2) {
  return (b2[0] - a2[0]) * (c2[1] - a2[1]) === (c2[0] - a2[0]) * (b2[1] - a2[1]);
}
function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}
function quantize2(k, nice2, zero5) {
  return function(values2) {
    var ex = extent(values2), start = zero5 ? Math.min(ex[0], 0) : ex[0], stop2 = ex[1], span2 = stop2 - start, step = nice2 ? tickStep(start, stop2, k) : span2 / (k + 1);
    return range_default(start + step, stop2, step);
  };
}
function Isocontour(params2) {
  Transform.call(this, null, params2);
}
Isocontour.Definition = {
  "type": "Isocontour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "levels",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "zero",
    "type": "boolean",
    "default": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }, {
    "name": "scale",
    "type": "number",
    "expr": true
  }, {
    "name": "translate",
    "type": "number",
    "array": true,
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "default": "contour"
  }]
};
inherits(Isocontour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source3 = pulse2.materialize(pulse2.SOURCE).source, field3 = _.field || identity, contour = contours().smooth(_.smooth !== false), tz = _.thresholds || levels(source3, field3, _), as = _.as === null ? null : _.as || "contour", values2 = [];
    source3.forEach((t) => {
      const grid = field3(t);
      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values));
      transformPaths(paths, grid, t, _);
      paths.forEach((p) => {
        values2.push(rederive(t, ingest$1(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = values2;
    return out;
  }
});
function levels(values2, f, _) {
  const q = quantize2(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== "shared" ? q : q(values2.map((t) => max(f(t).values)));
}
function transformPaths(paths, grid, datum2, _) {
  let s = _.scale || grid.scale, t = _.translate || grid.translate;
  if (isFunction(s))
    s = s(datum2, _);
  if (isFunction(t))
    t = t(datum2, _);
  if ((s === 1 || s == null) && !t)
    return;
  const sx = (isNumber(s) ? s : s[0]) || 1, sy = (isNumber(s) ? s : s[1]) || 1, tx = t && t[0] || 0, ty = t && t[1] || 0;
  paths.forEach(transform2(grid, sx, sy, tx, ty));
}
function transform2(grid, sx, sy, tx, ty) {
  const x12 = grid.x1 || 0, y12 = grid.y1 || 0, flip2 = sx * sy < 0;
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    if (flip2)
      coordinates.reverse();
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x12) * sx + tx;
    coordinates[1] = (coordinates[1] - y12) * sy + ty;
  }
  return function(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}
function radius(bw, data3, f) {
  const v = bw >= 0 ? bw : estimateBandwidth(data3, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}
function number4(_) {
  return isFunction(_) ? _ : constant(+_);
}
function density2D() {
  var x5 = (d) => d[0], y5 = (d) => d[1], weight = one, bandwidth2 = [-1, -1], dx = 960, dy = 500, k = 2;
  function density(data3, counts) {
    const rx = radius(bandwidth2[0], data3, x5) >> k, ry = radius(bandwidth2[1], data3, y5) >> k, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k), m2 = 2 * oy + (dy >> k), values0 = new Float32Array(n * m2), values1 = new Float32Array(n * m2);
    let values2 = values0;
    data3.forEach((d) => {
      const xi = ox + (+x5(d) >> k), yi = oy + (+y5(d) >> k);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m2) {
        values0[xi + yi * n] += +weight(d);
      }
    });
    if (rx > 0 && ry > 0) {
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m2, values0, values1, rx);
      blurX(n, m2, values1, values0, rx);
      blurX(n, m2, values0, values1, rx);
      values2 = values1;
    } else if (ry > 0) {
      blurY(n, m2, values0, values1, ry);
      blurY(n, m2, values1, values0, ry);
      blurY(n, m2, values0, values1, ry);
      values2 = values1;
    }
    const s = counts ? Math.pow(2, -2 * k) : 1 / sum(values2);
    for (let i = 0, sz2 = n * m2; i < sz2; ++i)
      values2[i] *= s;
    return {
      values: values2,
      scale: 1 << k,
      width: n,
      height: m2,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k),
      y2: oy + (dy >> k)
    };
  }
  density.x = function(_) {
    return arguments.length ? (x5 = number4(_), density) : x5;
  };
  density.y = function(_) {
    return arguments.length ? (y5 = number4(_), density) : y5;
  };
  density.weight = function(_) {
    return arguments.length ? (weight = number4(_), density) : weight;
  };
  density.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0))
      error("invalid size");
    return dx = _0, dy = _1, density;
  };
  density.cellSize = function(_) {
    if (!arguments.length)
      return 1 << k;
    if (!((_ = +_) >= 1))
      error("invalid cell size");
    k = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };
  density.bandwidth = function(_) {
    if (!arguments.length)
      return bandwidth2;
    _ = array(_);
    if (_.length === 1)
      _ = [+_[0], +_[0]];
    if (_.length !== 2)
      error("invalid bandwidth");
    return bandwidth2 = _, density;
  };
  return density;
}
function blurX(n, m2, source3, target2, r) {
  const w2 = (r << 1) + 1;
  for (let j = 0; j < m2; ++j) {
    for (let i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source3[i + j * n];
      }
      if (i >= r) {
        if (i >= w2) {
          sr -= source3[i - w2 + j * n];
        }
        target2[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w2 - i, w2);
      }
    }
  }
}
function blurY(n, m2, source3, target2, r) {
  const w2 = (r << 1) + 1;
  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m2 + r; ++j) {
      if (j < m2) {
        sr += source3[i + j * n];
      }
      if (j >= r) {
        if (j >= w2) {
          sr -= source3[i + (j - w2) * n];
        }
        target2[i + (j - r) * n] = sr / Math.min(j + 1, m2 - 1 + w2 - j, w2);
      }
    }
  }
}
function KDE2D(params2) {
  Transform.call(this, null, params2);
}
KDE2D.Definition = {
  "type": "KDE2D",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": "grid"
  }]
};
var PARAMS = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function params(obj, _) {
  PARAMS.forEach((param2) => _[param2] != null ? obj[param2](_[param2]) : 0);
  return obj;
}
inherits(KDE2D, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified())
      return pulse2.StopPropagation;
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition3(source3, _.groupby), names = (_.groupby || []).map(accessorName), kde2 = params(density2D(), _), as = _.as || "grid", values2 = [];
    function set5(t, vals) {
      for (let i = 0; i < names.length; ++i)
        t[names[i]] = vals[i];
      return t;
    }
    values2 = groups.map((g) => ingest$1(set5({
      [as]: kde2(g, _.counts)
    }, g.dims)));
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = values2;
    return out;
  }
});
function partition3(data3, groupby) {
  var groups = [], get6 = (f) => f(t), map3, i, n, t, k, g;
  if (groupby == null) {
    groups.push(data3);
  } else {
    for (map3 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k = groupby.map(get6);
      g = map3[k];
      if (!g) {
        map3[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(t);
    }
  }
  return groups;
}
function Contour(params2) {
  Transform.call(this, null, params2);
}
Contour.Definition = {
  "type": "Contour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "values",
    "type": "number",
    "array": true
  }, {
    "name": "x",
    "type": "field"
  }, {
    "name": "y",
    "type": "field"
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number"
  }, {
    "name": "count",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }]
};
inherits(Contour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), contour = contours().smooth(_.smooth !== false), values2 = _.values, thresh = _.thresholds || quantize2(_.count || 10, _.nice, !!values2), size = _.size, grid, post;
    if (!values2) {
      values2 = pulse2.materialize(pulse2.SOURCE).source;
      grid = params(density2D(), _)(values2, true);
      post = transform2(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values2 = grid.values;
    }
    thresh = isArray(thresh) ? thresh : thresh(values2);
    values2 = contour.size(size)(values2, thresh);
    if (post)
      values2.forEach(post);
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = (values2 || []).map(ingest$1);
    return out;
  }
});
var Feature = "Feature";
var FeatureCollection = "FeatureCollection";
var MultiPoint = "MultiPoint";
function GeoJSON(params2) {
  Transform.call(this, null, params2);
}
GeoJSON.Definition = {
  "type": "GeoJSON",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "length": 2
  }, {
    "name": "geojson",
    "type": "field"
  }]
};
inherits(GeoJSON, Transform, {
  transform(_, pulse2) {
    var features = this._features, points2 = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && identity, flag2 = pulse2.ADD, mod;
    mod = _.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(geojson)) || lon && pulse2.modified(accessorFields(lon)) || lat && pulse2.modified(accessorFields(lat));
    if (!this.value || mod) {
      flag2 = pulse2.SOURCE;
      this._features = features = [];
      this._points = points2 = [];
    }
    if (geojson) {
      pulse2.visit(flag2, (t) => features.push(geojson(t)));
    }
    if (lon && lat) {
      pulse2.visit(flag2, (t) => {
        var x5 = lon(t), y5 = lat(t);
        if (x5 != null && y5 != null && (x5 = +x5) === x5 && (y5 = +y5) === y5) {
          points2.push([x5, y5]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points2
        }
      });
    }
    this.value = {
      type: FeatureCollection,
      features
    };
  }
});
function GeoPath(params2) {
  Transform.call(this, null, params2);
}
GeoPath.Definition = {
  "type": "GeoPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits(GeoPath, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), path3 = this.value, field3 = _.field || identity, as = _.as || "path", flag2 = out.SOURCE;
    if (!path3 || _.modified()) {
      this.value = path3 = getProjectionPath(_.projection);
      out.materialize().reflow();
    } else {
      flag2 = field3 === identity || pulse2.modified(field3.fields) ? out.ADD_MOD : out.ADD;
    }
    const prev = initPath(path3, _.pointRadius);
    out.visit(flag2, (t) => t[as] = path3(field3(t)));
    path3.pointRadius(prev);
    return out.modifies(as);
  }
});
function initPath(path3, pointRadius) {
  const prev = path3.pointRadius();
  path3.context(null);
  if (pointRadius != null) {
    path3.pointRadius(pointRadius);
  }
  return prev;
}
function GeoPoint(params2) {
  Transform.call(this, null, params2);
}
GeoPoint.Definition = {
  "type": "GeoPoint",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection",
    "required": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["x", "y"]
  }]
};
inherits(GeoPoint, Transform, {
  transform(_, pulse2) {
    var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x5 = as[0], y5 = as[1], mod;
    function set5(t) {
      const xy = proj([lon(t), lat(t)]);
      if (xy) {
        t[x5] = xy[0];
        t[y5] = xy[1];
      } else {
        t[x5] = void 0;
        t[y5] = void 0;
      }
    }
    if (_.modified()) {
      pulse2 = pulse2.materialize().reflow(true).visit(pulse2.SOURCE, set5);
    } else {
      mod = pulse2.modified(lon.fields) || pulse2.modified(lat.fields);
      pulse2.visit(mod ? pulse2.ADD_MOD : pulse2.ADD, set5);
    }
    return pulse2.modifies(as);
  }
});
function GeoShape(params2) {
  Transform.call(this, null, params2);
}
GeoShape.Definition = {
  "type": "GeoShape",
  "metadata": {
    "modifies": true,
    "nomod": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field",
    "default": "datum"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "shape"
  }]
};
inherits(GeoShape, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), shape2 = this.value, as = _.as || "shape", flag2 = out.ADD;
    if (!shape2 || _.modified()) {
      this.value = shape2 = shapeGenerator(getProjectionPath(_.projection), _.field || field("datum"), _.pointRadius);
      out.materialize().reflow();
      flag2 = out.SOURCE;
    }
    out.visit(flag2, (t) => t[as] = shape2);
    return out.modifies(as);
  }
});
function shapeGenerator(path3, field3, pointRadius) {
  const shape2 = pointRadius == null ? (_) => path3(field3(_)) : (_) => {
    var prev = path3.pointRadius(), value3 = path3.pointRadius(pointRadius)(field3(_));
    path3.pointRadius(prev);
    return value3;
  };
  shape2.context = (_) => {
    path3.context(_);
    return shape2;
  };
  return shape2;
}
function Graticule(params2) {
  Transform.call(this, [], params2);
  this.generator = graticule();
}
Graticule.Definition = {
  "type": "Graticule",
  "metadata": {
    "changes": true,
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMajor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMinor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "step",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "stepMajor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [90, 360]
  }, {
    "name": "stepMinor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [10, 10]
  }, {
    "name": "precision",
    "type": "number",
    "default": 2.5
  }]
};
inherits(Graticule, Transform, {
  transform(_, pulse2) {
    var src = this.value, gen = this.generator, t;
    if (!src.length || _.modified()) {
      for (const prop in _) {
        if (isFunction(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }
    t = gen();
    if (src.length) {
      pulse2.mod.push(replace(src[0], t));
    } else {
      pulse2.add.push(ingest$1(t));
    }
    src[0] = t;
    return pulse2;
  }
});
function Heatmap(params2) {
  Transform.call(this, null, params2);
}
Heatmap.Definition = {
  "type": "heatmap",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "color",
    "type": "string",
    "expr": true
  }, {
    "name": "opacity",
    "type": "number",
    "expr": true
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "as",
    "type": "string",
    "default": "image"
  }]
};
inherits(Heatmap, Transform, {
  transform(_, pulse2) {
    if (!pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var source3 = pulse2.materialize(pulse2.SOURCE).source, shared = _.resolve === "shared", field3 = _.field || identity, opacity = opacity_(_.opacity, _), color7 = color_(_.color, _), as = _.as || "image", obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? max(source3.map((t) => max(field3(t).values))) : 0
    };
    source3.forEach((t) => {
      const v = field3(t);
      const o = extend({}, t, obj);
      if (!shared)
        o.$max = max(v.values || []);
      t[as] = toCanvas(v, o, color7.dep ? color7 : constant(color7(o)), opacity.dep ? opacity : constant(opacity(o)));
    });
    return pulse2.reflow(true).modifies(as);
  }
});
function color_(color7, _) {
  let f;
  if (isFunction(color7)) {
    f = (obj) => rgb3(color7(obj, _));
    f.dep = dependency(color7);
  } else {
    f = constant(rgb3(color7 || "#888"));
  }
  return f;
}
function opacity_(opacity, _) {
  let f;
  if (isFunction(opacity)) {
    f = (obj) => opacity(obj, _);
    f.dep = dependency(opacity);
  } else if (opacity) {
    f = constant(opacity);
  } else {
    f = (obj) => obj.$value / obj.$max || 0;
    f.dep = true;
  }
  return f;
}
function dependency(f) {
  if (!isFunction(f))
    return false;
  const set5 = toSet(accessorFields(f));
  return set5.$x || set5.$y || set5.$value || set5.$max;
}
function toCanvas(grid, obj, color7, opacity) {
  const n = grid.width, m2 = grid.height, x12 = grid.x1 || 0, y12 = grid.y1 || 0, x22 = grid.x2 || n, y22 = grid.y2 || m2, val = grid.values, value3 = val ? (i) => val[i] : zero, can = domCanvas(x22 - x12, y22 - y12), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x22 - x12, y22 - y12), pix = img.data;
  for (let j = y12, k = 0; j < y22; ++j) {
    obj.$y = j - y12;
    for (let i = x12, r = j * n; i < x22; ++i, k += 4) {
      obj.$x = i - x12;
      obj.$value = value3(i + r);
      const v = color7(obj);
      pix[k + 0] = v.r;
      pix[k + 1] = v.g;
      pix[k + 2] = v.b;
      pix[k + 3] = ~~(255 * opacity(obj));
    }
  }
  ctx.putImageData(img, 0, 0);
  return can;
}
function Projection(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Projection, Transform, {
  transform(_, pulse2) {
    let proj = this.value;
    if (!proj || _.modified("type")) {
      this.value = proj = create3(_.type);
      projectionProperties.forEach((prop) => {
        if (_[prop] != null)
          set3(proj, prop, _[prop]);
      });
    } else {
      projectionProperties.forEach((prop) => {
        if (_.modified(prop))
          set3(proj, prop, _[prop]);
      });
    }
    if (_.pointRadius != null)
      proj.path.pointRadius(_.pointRadius);
    if (_.fit)
      fit2(proj, _);
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function fit2(proj, _) {
  const data3 = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data3) : _.size ? proj.fitSize(_.size, data3) : 0;
}
function create3(type2) {
  const constructor = projection2((type2 || "mercator").toLowerCase());
  if (!constructor)
    error("Unrecognized projection type: " + type2);
  return constructor();
}
function set3(proj, key2, value3) {
  if (isFunction(proj[key2]))
    proj[key2](value3);
}
function collectGeoJSON(data3) {
  data3 = array(data3);
  return data3.length === 1 ? data3[0] : {
    type: FeatureCollection,
    features: data3.reduce((a2, f) => a2.concat(featurize(f)), [])
  };
}
function featurize(f) {
  return f.type === FeatureCollection ? f.features : array(f).filter((d) => d != null).map((d) => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}

// node_modules/vega-force/build/vega-force.module.js
var vega_force_module_exports = {};
__export(vega_force_module_exports, {
  force: () => Force
});

// node_modules/vega-force/node_modules/d3-force/src/center.js
function center_default(x5, y5) {
  var nodes, strength = 1;
  if (x5 == null)
    x5 = 0;
  if (y5 == null)
    y5 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x5) * strength, sy = (sy / n - y5) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_) {
    nodes = _;
  };
  force.x = function(_) {
    return arguments.length ? (x5 = +_, force) : x5;
  };
  force.y = function(_) {
    return arguments.length ? (y5 = +_, force) : y5;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  return force;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x5 = +this._x.call(null, d), y5 = +this._y.call(null, d);
  return add4(this.cover(x5, y5), x5, y5, d);
}
function add4(tree, x5, y5, d) {
  if (isNaN(x5) || isNaN(y5))
    return tree;
  var parent, node = tree._root, leaf = { data: d }, x06 = tree._x0, y06 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x5 >= (xm = (x06 + x12) / 2))
      x06 = xm;
    else
      x12 = xm;
    if (bottom = y5 >= (ym = (y06 + y12) / 2))
      y06 = ym;
    else
      y12 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right]))
      return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x5 === xp && y5 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x5 >= (xm = (x06 + x12) / 2))
      x06 = xm;
    else
      x12 = xm;
    if (bottom = y5 >= (ym = (y06 + y12) / 2))
      y06 = ym;
    else
      y12 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data3) {
  var d, i, n = data3.length, x5, y5, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x5 = +this._x.call(null, d = data3[i])) || isNaN(y5 = +this._y.call(null, d)))
      continue;
    xz[i] = x5;
    yz[i] = y5;
    if (x5 < x06)
      x06 = x5;
    if (x5 > x12)
      x12 = x5;
    if (y5 < y06)
      y06 = y5;
    if (y5 > y12)
      y12 = y5;
  }
  if (x06 > x12 || y06 > y12)
    return this;
  this.cover(x06, y06).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add4(this, xz[i], yz[i], data3[i]);
  }
  return this;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/cover.js
function cover_default(x5, y5) {
  if (isNaN(x5 = +x5) || isNaN(y5 = +y5))
    return this;
  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x06)) {
    x12 = (x06 = Math.floor(x5)) + 1;
    y12 = (y06 = Math.floor(y5)) + 1;
  } else {
    var z = x12 - x06 || 1, node = this._root, parent, i;
    while (x06 > x5 || x5 >= x12 || y06 > y5 || y5 >= y12) {
      i = (y5 < y06) << 1 | x5 < x06;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x06 + z, y12 = y06 + z;
          break;
        case 1:
          x06 = x12 - z, y12 = y06 + z;
          break;
        case 2:
          x12 = x06 + z, y06 = y12 - z;
          break;
        case 3:
          x06 = x12 - z, y06 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/data.js
function data_default() {
  var data3 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data3.push(node.data);
      while (node = node.next);
  });
  return data3;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/vega-force/node_modules/d3-quadtree/src/quad.js
function quad_default(node, x06, y06, x12, y12) {
  this.node = node;
  this.x0 = x06;
  this.y0 = y06;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/find.js
function find_default(x5, y5, radius2) {
  var data3, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x06, y06, x32, y32));
  if (radius2 == null)
    radius2 = Infinity;
  else {
    x06 = x5 - radius2, y06 = y5 - radius2;
    x32 = x5 + radius2, y32 = y5 + radius2;
    radius2 *= radius2;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06)
      continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(new quad_default(node[3], xm, ym, x22, y22), new quad_default(node[2], x12, ym, xm, y22), new quad_default(node[1], xm, y12, x22, ym), new quad_default(node[0], x12, y12, xm, ym));
      if (i = (y5 >= ym) << 1 | x5 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x5 - +this._x.call(null, node.data), dy = y5 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius2) {
        var d = Math.sqrt(radius2 = d2);
        x06 = x5 - d, y06 = y5 - d;
        x32 = x5 + d, y32 = y5 + d;
        data3 = node.data;
      }
    }
  }
  return data3;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/remove.js
function remove_default(d) {
  if (isNaN(x5 = +this._x.call(null, d)) || isNaN(y5 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x5, y5, xm, ym, right, bottom, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x5 >= (xm = (x06 + x12) / 2))
        x06 = xm;
      else
        x12 = xm;
      if (bottom = y5 >= (ym = (y06 + y12) / 2))
        y06 = ym;
      else
        y12 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data3) {
  for (var i = 0, n = data3.length; i < n; ++i)
    this.remove(data3[i]);
  return this;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x06, y06, x12, y12;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
      if (child = node[2])
        quads.push(new quad_default(child, x06, ym, xm, y12));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y06, x12, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x06, y06, xm, ym));
    }
  }
  return this;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x06, y06, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y06, x12, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x06, ym, xm, y12));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/vega-force/node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x5, y5) {
  var tree = new Quadtree(x5 == null ? defaultX : x5, y5 == null ? defaultY : y5, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x5, y5, x06, y06, x12, y12) {
  this._x = x5;
  this._y = y5;
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy4 = { data: leaf.data }, next = copy4;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy4;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy4 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy4;
  if (!node.length)
    return copy4._root = leaf_copy(node), copy4;
  nodes = [{ source: node, target: copy4._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy4;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/vega-force/node_modules/d3-force/src/constant.js
function constant_default4(x5) {
  return function() {
    return x5;
  };
}

// node_modules/vega-force/node_modules/d3-force/src/jiggle.js
function jiggle_default(random2) {
  return (random2() - 0.5) * 1e-6;
}

// node_modules/vega-force/node_modules/d3-force/src/collide.js
function x3(d) {
  return d.x + d.vx;
}
function y3(d) {
  return d.y + d.vy;
}
function collide_default(radius2) {
  var nodes, radii, random2, strength = 1, iterations2 = 1;
  if (typeof radius2 !== "function")
    radius2 = constant_default4(radius2 == null ? 1 : +radius2);
  function force() {
    var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k = 0; k < iterations2; ++k) {
      tree = quadtree(nodes, x3, y3).visitAfter(prepare2);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply2);
      }
    }
    function apply2(quad2, x06, y06, x12, y12) {
      var data3 = quad2.data, rj = quad2.r, r = ri + rj;
      if (data3) {
        if (data3.index > node.index) {
          var x5 = xi - data3.x - data3.vx, y5 = yi - data3.y - data3.vy, l = x5 * x5 + y5 * y5;
          if (l < r * r) {
            if (x5 === 0)
              x5 = jiggle_default(random2), l += x5 * x5;
            if (y5 === 0)
              y5 = jiggle_default(random2), l += y5 * y5;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x5 *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y5 *= l) * r;
            data3.vx -= x5 * (r = 1 - r);
            data3.vy -= y5 * r;
          }
        }
        return;
      }
      return x06 > xi + r || x12 < xi - r || y06 > yi + r || y12 < yi - r;
    }
  }
  function prepare2(quad2) {
    if (quad2.data)
      return quad2.r = radii[quad2.data.index];
    for (var i = quad2.r = 0; i < 4; ++i) {
      if (quad2[i] && quad2[i].r > quad2.r) {
        quad2.r = quad2[i].r;
      }
    }
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i)
      node = nodes[i], radii[node.index] = +radius2(node, i, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize3();
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default4(+_), initialize3(), force) : radius2;
  };
  return force;
}

// node_modules/vega-force/node_modules/d3-force/src/link.js
function index(d) {
  return d.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id2 = index, strength = defaultStrength, strengths, distance = constant_default4(30), distances, nodes, count2, bias, random2, iterations2 = 1;
  if (links == null)
    links = [];
  function defaultStrength(link2) {
    return 1 / Math.min(count2[link2.source.index], count2[link2.target.index]);
  }
  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations2; ++k) {
      for (var i = 0, link2, source3, target2, x5, y5, l, b2; i < n; ++i) {
        link2 = links[i], source3 = link2.source, target2 = link2.target;
        x5 = target2.x + target2.vx - source3.x - source3.vx || jiggle_default(random2);
        y5 = target2.y + target2.vy - source3.y - source3.vy || jiggle_default(random2);
        l = Math.sqrt(x5 * x5 + y5 * y5);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x5 *= l, y5 *= l;
        target2.vx -= x5 * (b2 = bias[i]);
        target2.vy -= y5 * b2;
        source3.vx += x5 * (b2 = 1 - b2);
        source3.vy += y5 * b2;
      }
    }
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link2;
    for (i = 0, count2 = new Array(n); i < m2; ++i) {
      link2 = links[i], link2.index = i;
      if (typeof link2.source !== "object")
        link2.source = find2(nodeById, link2.source);
      if (typeof link2.target !== "object")
        link2.target = find2(nodeById, link2.target);
      count2[link2.source.index] = (count2[link2.source.index] || 0) + 1;
      count2[link2.target.index] = (count2[link2.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m2); i < m2; ++i) {
      link2 = links[i], bias[i] = count2[link2.source.index] / (count2[link2.source.index] + count2[link2.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize3();
  };
  force.links = function(_) {
    return arguments.length ? (links = _, initialize3(), force) : links;
  };
  force.id = function(_) {
    return arguments.length ? (id2 = _, force) : id2;
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default4(+_), initializeStrength(), force) : strength;
  };
  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default4(+_), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/vega-force/node_modules/d3-dispatch/src/dispatch.js
var noop4 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types2) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types2.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get5(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set4(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set4(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy4 = {}, _ = this._;
    for (var t in _)
      copy4[t] = _[t].slice();
    return new Dispatch(copy4);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get5(type2, name2) {
  for (var i = 0, n = type2.length, c2; i < n; ++i) {
    if ((c2 = type2[i]).name === name2) {
      return c2.value;
    }
  }
}
function set4(type2, name2, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name2) {
      type2[i] = noop4, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name: name2, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/vega-force/node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time3) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time3 = (time3 == null ? now() : +time3) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time3;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time3) {
  var t = new Timer();
  t.restart(callback, delay, time3);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay = now3 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now3;
}
function nap() {
  var t05, t14 = taskHead, t23, time3 = Infinity;
  while (t14) {
    if (t14._call) {
      if (time3 > t14._time)
        time3 = t14._time;
      t05 = t14, t14 = t14._next;
    } else {
      t23 = t14._next, t14._next = null;
      t14 = t05 ? t05._next = t23 : taskHead = t23;
    }
  }
  taskTail = t05;
  sleep(time3);
}
function sleep(time3) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time3 - clockNow;
  if (delay > 24) {
    if (time3 < Infinity)
      timeout = setTimeout(wake, time3 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/vega-force/node_modules/d3-force/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}

// node_modules/vega-force/node_modules/d3-force/src/simulation.js
function x4(d) {
  return d.x;
}
function y4(d) {
  return d.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = new Map(), stepper = timer(step), event2 = dispatch_default("tick", "end"), random2 = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick();
    event2.call("tick", simulation2);
    if (alpha < alphaMin) {
      stepper.stop();
      event2.call("end", simulation2);
    }
  }
  function tick(iterations2) {
    var i, n = nodes.length, node;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k = 0; k < iterations2; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation2;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
        node.x = radius2 * Math.cos(angle2);
        node.y = radius2 * Math.sin(angle2);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random2);
    return force;
  }
  initializeNodes();
  return simulation2 = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation2;
    },
    stop: function() {
      return stepper.stop(), simulation2;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation2) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation2) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation2) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation2) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation2) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation2) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random2 = _, forces.forEach(initializeForce), simulation2) : random2;
    },
    force: function(name2, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name2) : forces.set(name2, initializeForce(_)), simulation2) : forces.get(name2);
    },
    find: function(x5, y5, radius2) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius2 == null)
        radius2 = Infinity;
      else
        radius2 *= radius2;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x5 - node.x;
        dy = y5 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius2)
          closest = node, radius2 = d2;
      }
      return closest;
    },
    on: function(name2, _) {
      return arguments.length > 1 ? (event2.on(name2, _), simulation2) : event2.on(name2);
    }
  };
}

// node_modules/vega-force/node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random2, alpha, strength = constant_default4(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x4, y4).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i)
      node = nodes[i], tree.visit(apply2);
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad2) {
    var strength2 = 0, q, c2, weight = 0, x5, y5, i;
    if (quad2.length) {
      for (x5 = y5 = i = 0; i < 4; ++i) {
        if ((q = quad2[i]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x5 += c2 * q.x, y5 += c2 * q.y;
        }
      }
      quad2.x = x5 / weight;
      quad2.y = y5 / weight;
    } else {
      q = quad2;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad2.value = strength2;
  }
  function apply2(quad2, x12, _, x22) {
    if (!quad2.value)
      return true;
    var x5 = quad2.x - node.x, y5 = quad2.y - node.y, w2 = x22 - x12, l = x5 * x5 + y5 * y5;
    if (w2 * w2 / theta2 < l) {
      if (l < distanceMax2) {
        if (x5 === 0)
          x5 = jiggle_default(random2), l += x5 * x5;
        if (y5 === 0)
          y5 = jiggle_default(random2), l += y5 * y5;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x5 * quad2.value * alpha / l;
        node.vy += y5 * quad2.value * alpha / l;
      }
      return true;
    } else if (quad2.length || l >= distanceMax2)
      return;
    if (quad2.data !== node || quad2.next) {
      if (x5 === 0)
        x5 = jiggle_default(random2), l += x5 * x5;
      if (y5 === 0)
        y5 = jiggle_default(random2), l += y5 * y5;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad2.data !== node) {
        w2 = strengths[quad2.data.index] * alpha / l;
        node.vx += x5 * w2;
        node.vy += y5 * w2;
      }
    while (quad2 = quad2.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize3();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default4(+_), initialize3(), force) : strength;
  };
  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/vega-force/node_modules/d3-force/src/x.js
function x_default2(x5) {
  var strength = constant_default4(0.1), nodes, strengths, xz;
  if (typeof x5 !== "function")
    x5 = constant_default4(x5 == null ? 0 : +x5);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x5(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize3();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default4(+_), initialize3(), force) : strength;
  };
  force.x = function(_) {
    return arguments.length ? (x5 = typeof _ === "function" ? _ : constant_default4(+_), initialize3(), force) : x5;
  };
  return force;
}

// node_modules/vega-force/node_modules/d3-force/src/y.js
function y_default2(y5) {
  var strength = constant_default4(0.1), nodes, strengths, yz;
  if (typeof y5 !== "function")
    y5 = constant_default4(y5 == null ? 0 : +y5);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y5(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize3();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default4(+_), initialize3(), force) : strength;
  };
  force.y = function(_) {
    return arguments.length ? (y5 = typeof _ === "function" ? _ : constant_default4(+_), initialize3(), force) : y5;
  };
  return force;
}

// node_modules/vega-force/build/vega-force.module.js
var ForceMap = {
  center: center_default,
  collide: collide_default,
  nbody: manyBody_default,
  link: link_default,
  x: x_default2,
  y: y_default2
};
var Forces = "forces";
var ForceParams = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"];
var ForceConfig = ["static", "iterations"];
var ForceOutput = ["x", "y", "vx", "vy"];
function Force(params2) {
  Transform.call(this, null, params2);
}
Force.Definition = {
  "type": "Force",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "static",
    "type": "boolean",
    "default": false
  }, {
    "name": "restart",
    "type": "boolean",
    "default": false
  }, {
    "name": "iterations",
    "type": "number",
    "default": 300
  }, {
    "name": "alpha",
    "type": "number",
    "default": 1
  }, {
    "name": "alphaMin",
    "type": "number",
    "default": 1e-3
  }, {
    "name": "alphaTarget",
    "type": "number",
    "default": 0
  }, {
    "name": "velocityDecay",
    "type": "number",
    "default": 0.4
  }, {
    "name": "forces",
    "type": "param",
    "array": true,
    "params": [{
      "key": {
        "force": "center"
      },
      "params": [{
        "name": "x",
        "type": "number",
        "default": 0
      }, {
        "name": "y",
        "type": "number",
        "default": 0
      }]
    }, {
      "key": {
        "force": "collide"
      },
      "params": [{
        "name": "radius",
        "type": "number",
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "default": 0.7
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "nbody"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": -30
      }, {
        "name": "theta",
        "type": "number",
        "default": 0.9
      }, {
        "name": "distanceMin",
        "type": "number",
        "default": 1
      }, {
        "name": "distanceMax",
        "type": "number"
      }]
    }, {
      "key": {
        "force": "link"
      },
      "params": [{
        "name": "links",
        "type": "data"
      }, {
        "name": "id",
        "type": "field"
      }, {
        "name": "distance",
        "type": "number",
        "default": 30,
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "expr": true
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "x"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "x",
        "type": "field"
      }]
    }, {
      "key": {
        "force": "y"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "y",
        "type": "field"
      }]
    }]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "modify": false,
    "default": ForceOutput
  }]
};
inherits(Force, Transform, {
  transform(_, pulse2) {
    var sim = this.value, change2 = pulse2.changed(pulse2.ADD_REM), params2 = _.modified(ForceParams), iters = _.iterations || 300;
    if (!sim) {
      this.value = sim = simulation(pulse2.source, _);
      sim.on("tick", rerun(pulse2.dataflow, this));
      if (!_.static) {
        change2 = true;
        sim.tick();
      }
      pulse2.modifies("index");
    } else {
      if (change2) {
        pulse2.modifies("index");
        sim.nodes(pulse2.source);
      }
      if (params2 || pulse2.changed(pulse2.MOD)) {
        setup(sim, _, 0, pulse2);
      }
    }
    if (params2 || change2 || _.modified(ForceConfig) || pulse2.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
      if (_.static) {
        for (sim.stop(); --iters >= 0; )
          sim.tick();
      } else {
        if (sim.stopped())
          sim.restart();
        if (!change2)
          return pulse2.StopPropagation;
      }
    }
    return this.finish(_, pulse2);
  },
  finish(_, pulse2) {
    const dataflow = pulse2.dataflow;
    for (let args = this._argops, j = 0, m2 = args.length, arg; j < m2; ++j) {
      arg = args[j];
      if (arg.name !== Forces || arg.op._argval.force !== "link") {
        continue;
      }
      for (var ops2 = arg.op._argops, i = 0, n = ops2.length, op; i < n; ++i) {
        if (ops2[i].name === "links" && (op = ops2[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    }
    return pulse2.reflow(_.modified()).modifies(ForceOutput);
  }
});
function rerun(df, op) {
  return () => df.touch(op).run();
}
function simulation(nodes, _) {
  const sim = simulation_default(nodes), stop2 = sim.stop, restart = sim.restart;
  let stopped = false;
  sim.stopped = () => stopped;
  sim.restart = () => (stopped = false, restart());
  sim.stop = () => (stopped = true, stop2());
  return setup(sim, _, true).on("end", () => stopped = true);
}
function setup(sim, _, init2, pulse2) {
  var f = array(_.forces), i, n, p, name2;
  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p))
      sim[p](_[p]);
  }
  for (i = 0, n = f.length; i < n; ++i) {
    name2 = Forces + i;
    p = init2 || _.modified(Forces, i) ? getForce(f[i]) : pulse2 && modified(f[i], pulse2) ? sim.force(name2) : null;
    if (p)
      sim.force(name2, p);
  }
  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null);
  }
  sim.numForces = f.length;
  return sim;
}
function modified(f, pulse2) {
  var k, v;
  for (k in f) {
    if (isFunction(v = f[k]) && pulse2.modified(accessorFields(v)))
      return 1;
  }
  return 0;
}
function getForce(_) {
  var f, p;
  if (!has(ForceMap, _.force)) {
    error("Unrecognized force: " + _.force);
  }
  f = ForceMap[_.force]();
  for (p in _) {
    if (isFunction(f[p]))
      setForceParam(f[p], _[p], _);
  }
  return f;
}
function setForceParam(f, v, _) {
  f(isFunction(v) ? (d) => v(d, _) : v);
}

// node_modules/vega-hierarchy/build/vega-hierarchy.module.js
var vega_hierarchy_module_exports = {};
__export(vega_hierarchy_module_exports, {
  nest: () => Nest,
  pack: () => Pack,
  partition: () => Partition,
  stratify: () => Stratify,
  tree: () => Tree,
  treelinks: () => TreeLinks,
  treemap: () => Treemap
});

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a2, b2) {
  return a2.parent === b2.parent ? 1 : 2;
}
function meanX(children3) {
  return children3.reduce(meanXReduce, 0) / children3.length;
}
function meanXReduce(x5, c2) {
  return x5 + c2.x;
}
function maxY(children3) {
  return 1 + children3.reduce(maxYReduce, 0);
}
function maxYReduce(y5, c2) {
  return Math.max(y5, c2.y);
}
function leafLeft(node) {
  var children3;
  while (children3 = node.children)
    node = children3[0];
  return node;
}
function leafRight(node) {
  var children3;
  while (children3 = node.children)
    node = children3[children3.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root) {
    var previousNode, x5 = 0;
    root.eachAfter(function(node) {
      var children3 = node.children;
      if (children3) {
        node.x = meanX(children3);
        node.y = maxY(children3);
      } else {
        node.x = previousNode ? x5 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root), right = leafRight(root), x06 = left.x - separation(left, right) / 2, x12 = right.x + separation(right, left) / 2;
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x06) / (x12 - x06) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }
  cluster.separation = function(x5) {
    return arguments.length ? (separation = x5, cluster) : separation;
  };
  cluster.size = function(x5) {
    return arguments.length ? (nodeSize = false, dx = +x5[0], dy = +x5[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x5) {
    return arguments.length ? (nodeSize = true, dx = +x5[0], dy = +x5[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum2 = 0, children3 = node.children, i = children3 && children3.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children3[i].value;
  node.value = sum2;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index3 = -1;
  for (const node of this) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children3, i, index3 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index3, this);
    if (children3 = node.children) {
      for (i = children3.length - 1; i >= 0; --i) {
        nodes.push(children3[i]);
      }
    }
  }
  return this;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children3, i, n, index3 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children3 = node.children) {
      for (i = 0, n = children3.length; i < n; ++i) {
        nodes.push(children3[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index3 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index3, this)) {
      return node;
    }
  }
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value3) {
  return this.eachAfter(function(node) {
    var sum2 = +value3(node.data) || 0, children3 = node.children, i = children3 && children3.length;
    while (--i >= 0)
      sum2 += children3[i].value;
    node.value = sum2;
  });
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare3) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare3);
    }
  });
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default3(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b2) {
  if (a2 === b2)
    return a2;
  var aNodes = a2.ancestors(), bNodes = b2.ancestors(), c2 = null;
  a2 = aNodes.pop();
  b2 = bNodes.pop();
  while (a2 === b2) {
    c2 = a2;
    a2 = aNodes.pop();
    b2 = bNodes.pop();
  }
  return c2;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children3, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children3 = node.children) {
        for (i = 0, n = children3.length; i < n; ++i) {
          next.push(children3[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data3, children3) {
  if (data3 instanceof Map) {
    data3 = [void 0, data3];
    if (children3 === void 0)
      children3 = mapChildren;
  } else if (children3 === void 0) {
    children3 = objectChildren;
  }
  var root = new Node(data3), node, nodes = [root], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children3(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height2 = 0;
  do
    node.height = height2;
  while ((node = node.parent) && node.height < ++height2);
}
function Node(data3) {
  this.data = data3;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default3,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/array.js
function array_default3(x5) {
  return typeof x5 === "object" && "length" in x5 ? x5 : Array.from(x5);
}
function shuffle(array4) {
  var m2 = array4.length, t, i;
  while (m2) {
    i = Math.random() * m2-- | 0;
    t = array4[m2];
    array4[m2] = array4[i];
    array4[i] = t;
  }
  return array4;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/enclose.js
function enclose_default(circles) {
  var i = 0, n = (circles = shuffle(Array.from(circles))).length, B2 = [], p, e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p))
      ++i;
    else
      e = encloseBasis(B2 = extendBasis(B2, p)), i = 0;
  }
  return e;
}
function extendBasis(B2, p) {
  var i, j;
  if (enclosesWeakAll(p, B2))
    return [p];
  for (i = 0; i < B2.length; ++i) {
    if (enclosesNot(p, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p), B2)) {
      return [B2[i], p];
    }
  }
  for (i = 0; i < B2.length - 1; ++i) {
    for (j = i + 1; j < B2.length; ++j) {
      if (enclosesNot(encloseBasis2(B2[i], B2[j]), p) && enclosesNot(encloseBasis2(B2[i], p), B2[j]) && enclosesNot(encloseBasis2(B2[j], p), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j], p), B2)) {
        return [B2[i], B2[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a2, b2) {
  var dr = a2.r - b2.r, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a2, b2) {
  var dr = a2.r - b2.r + Math.max(a2.r, b2.r, 1) * 1e-9, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a2, B2) {
  for (var i = 0; i < B2.length; ++i) {
    if (!enclosesWeak(a2, B2[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a2) {
  return {
    x: a2.x,
    y: a2.y,
    r: a2.r
  };
}
function encloseBasis2(a2, b2) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x22 = b2.x, y22 = b2.y, r2 = b2.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x22 + x21 / l * r21) / 2,
    y: (y12 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a2, b2, c2) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x22 = b2.x, y22 = b2.y, r2 = b2.r, x32 = c2.x, y32 = c2.y, r3 = c2.r, a22 = x12 - x22, a3 = x12 - x32, b22 = y12 - y22, b3 = y12 - y32, c22 = r2 - r1, c3 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab = a3 * b22 - a22 * b3, xa = (b22 * d3 - b3 * d2) / (ab * 2) - x12, xb = (b3 * c22 - b22 * c3) / ab, ya = (a3 * d2 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c3 - a3 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(A5 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C3)) / (2 * A5) : C3 / B2);
  return {
    x: x12 + xa + xb * r,
    y: y12 + ya + yb * r,
    r
  };
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/siblings.js
function place(b2, a2, c2) {
  var dx = b2.x - a2.x, x5, a22, dy = b2.y - a2.y, y5, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a2.r + c2.r, a22 *= a22;
    b22 = b2.r + c2.r, b22 *= b22;
    if (a22 > b22) {
      x5 = (d2 + b22 - a22) / (2 * d2);
      y5 = Math.sqrt(Math.max(0, b22 / d2 - x5 * x5));
      c2.x = b2.x - x5 * dx - y5 * dy;
      c2.y = b2.y - x5 * dy + y5 * dx;
    } else {
      x5 = (d2 + a22 - b22) / (2 * d2);
      y5 = Math.sqrt(Math.max(0, a22 / d2 - x5 * x5));
      c2.x = a2.x + x5 * dx - y5 * dy;
      c2.y = a2.y + x5 * dy + y5 * dx;
    }
  } else {
    c2.x = a2.x + c2.r;
    c2.y = a2.y;
  }
}
function intersects(a2, b2) {
  var dr = a2.r + b2.r - 1e-6, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a2 = node._, b2 = node.next._, ab = a2.r + b2.r, dx = (a2.x * b2.r + b2.x * a2.r) / ab, dy = (a2.y * b2.r + b2.y * a2.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array_default3(circles)).length))
    return 0;
  var a2, b2, c2, n, aa, ca, i, j, k, sj, sk;
  a2 = circles[0], a2.x = 0, a2.y = 0;
  if (!(n > 1))
    return a2.r;
  b2 = circles[1], a2.x = -b2.r, b2.x = a2.r, b2.y = 0;
  if (!(n > 2))
    return a2.r + b2.r;
  place(b2, a2, c2 = circles[2]);
  a2 = new Node2(a2), b2 = new Node2(b2), c2 = new Node2(c2);
  a2.next = c2.previous = b2;
  b2.next = a2.previous = c2;
  c2.next = b2.previous = a2;
  pack:
    for (i = 3; i < n; ++i) {
      place(a2._, b2._, c2 = circles[i]), c2 = new Node2(c2);
      j = b2.next, k = a2.previous, sj = b2._.r, sk = a2._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c2._)) {
            b2 = j, a2.next = b2, b2.previous = a2, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c2._)) {
            a2 = k, a2.next = b2, b2.previous = a2, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c2.previous = a2, c2.next = b2, a2.next = b2.previous = b2 = c2;
      aa = score(a2);
      while ((c2 = c2.next) !== b2) {
        if ((ca = score(c2)) < aa) {
          a2 = c2, aa = ca;
        }
      }
      b2 = a2.next;
    }
  a2 = [b2._], c2 = b2;
  while ((c2 = c2.next) !== b2)
    a2.push(c2._);
  c2 = enclose_default(a2);
  for (i = 0; i < n; ++i)
    a2 = circles[i], a2.x -= c2.x, a2.y -= c2.y;
  return c2.r;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default5(x5) {
  return function() {
    return x5;
  };
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius2 = null, dx = 1, dy = 1, padding2 = constantZero;
  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius2) {
      root.eachBefore(radiusLeaf(radius2)).eachAfter(packChildren(padding2, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding2, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }
  pack.radius = function(x5) {
    return arguments.length ? (radius2 = optional(x5), pack) : radius2;
  };
  pack.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], pack) : [dx, dy];
  };
  pack.padding = function(x5) {
    return arguments.length ? (padding2 = typeof x5 === "function" ? x5 : constant_default5(+x5), pack) : padding2;
  };
  return pack;
}
function radiusLeaf(radius2) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius2(node) || 0);
    }
  };
}
function packChildren(padding2, k) {
  return function(node) {
    if (children3 = node.children) {
      var children3, i, n = children3.length, r = padding2(node) * k || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children3[i].r += r;
      e = packEnclose(children3);
      if (r)
        for (i = 0; i < n; ++i)
          children3[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/round.js
function round_default3(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x12 - x06) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y06, node.y1 = y12;
    node.x0 = x06, node.x1 = x06 += node.value * k;
  }
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding2 = 0, round = false;
  function partition5(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding2;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round)
      root.eachBefore(round_default3);
    return root;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding2, y12 = node.y1 - padding2;
      if (x12 < x06)
        x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06)
        y06 = y12 = (y06 + y12) / 2;
      node.x0 = x06;
      node.y0 = y06;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition5.round = function(x5) {
    return arguments.length ? (round = !!x5, partition5) : round;
  };
  partition5.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], partition5) : [dx, dy];
  };
  partition5.padding = function(x5) {
    return arguments.length ? (padding2 = +x5, partition5) : padding2;
  };
  return partition5;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id2 = defaultId, parentId = defaultParentId;
  function stratify(data3) {
    var nodes = Array.from(data3), n = nodes.length, d, i, root, parent, node, nodeId, nodeKey, nodeByKey = new Map();
    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = id2(d, i, data3)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data3)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root)
          throw new Error("multiple roots");
        root = node;
      }
    }
    if (!root)
      throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root;
  }
  stratify.id = function(x5) {
    return arguments.length ? (id2 = required(x5), stratify) : id2;
  };
  stratify.parentId = function(x5) {
    return arguments.length ? (parentId = required(x5), stratify) : parentId;
  };
  return stratify;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a2, b2) {
  return a2.parent === b2.parent ? 1 : 2;
}
function nextLeft(v) {
  var children3 = v.children;
  return children3 ? children3[0] : v.t;
}
function nextRight(v) {
  var children3 = v.children;
  return children3 ? children3[children3.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change2 = shift / (wp.i - wm.i);
  wp.c -= change2;
  wp.s += shift;
  wm.c += change2;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change2 = 0, children3 = v.children, i = children3.length, w2;
  while (--i >= 0) {
    w2 = children3[i];
    w2.z += shift;
    w2.m += shift;
    shift += w2.s + (change2 += w2.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root) {
  var tree = new TreeNode(root, 0), node, nodes = [tree], child, children3, i, n;
  while (node = nodes.pop()) {
    if (children3 = node._.children) {
      node.children = new Array(n = children3.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children3[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root) {
    var t = treeRoot(root);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root.eachBefore(sizeNode);
    else {
      var left = root, right = root, bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x)
          left = node;
        if (node.x > right.x)
          right = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root;
  }
  function firstWalk(v) {
    var children3 = v.children, siblings = v.parent.children, w2 = v.i ? siblings[v.i - 1] : null;
    if (children3) {
      executeShifts(v);
      var midpoint = (children3[0].z + children3[children3.length - 1].z) / 2;
      if (w2) {
        v.z = w2.z + separation(v._, w2._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w2) {
      v.z = w2.z + separation(v._, w2._);
    }
    v.parent.A = apportion(v, w2, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w2, ancestor) {
    if (w2) {
      var vip = v, vop = v, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x5) {
    return arguments.length ? (separation = x5, tree) : separation;
  };
  tree.size = function(x5) {
    return arguments.length ? (nodeSize = false, dx = +x5[0], dy = +x5[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x5) {
    return arguments.length ? (nodeSize = true, dx = +x5[0], dy = +x5[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y12 - y06) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x06, node.x1 = x12;
    node.y0 = y06, node.y1 = y06 += node.value * k;
  }
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x06, y06, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value3 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x06, dy = y12 - y06;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value3 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x06, y06, x12, value3 ? y06 += dy * sumValue / value3 : y12);
    else
      slice_default(row, x06, y06, value3 ? x06 += dx * sumValue / value3 : x12, y12);
    value3 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom9(ratio) {
  function squarify(parent, x06, y06, x12, y12) {
    squarifyRatio(ratio, parent, x06, y06, x12, y12);
  }
  squarify.ratio = function(x5) {
    return custom9((x5 = +x5) > 1 ? x5 : 1);
  };
  return squarify;
}(phi);

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round)
      root.eachBefore(round_default3);
    return root;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;
    if (x12 < x06)
      x06 = x12 = (x06 + x12) / 2;
    if (y12 < y06)
      y06 = y12 = (y06 + y12) / 2;
    node.x0 = x06;
    node.y0 = y06;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x06 += paddingLeft(node) - p;
      y06 += paddingTop(node) - p;
      x12 -= paddingRight(node) - p;
      y12 -= paddingBottom(node) - p;
      if (x12 < x06)
        x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06)
        y06 = y12 = (y06 + y12) / 2;
      tile(node, x06, y06, x12, y12);
    }
  }
  treemap.round = function(x5) {
    return arguments.length ? (round = !!x5, treemap) : round;
  };
  treemap.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x5) {
    return arguments.length ? (tile = required(x5), treemap) : tile;
  };
  treemap.padding = function(x5) {
    return arguments.length ? treemap.paddingInner(x5).paddingOuter(x5) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x5) {
    return arguments.length ? (paddingInner = typeof x5 === "function" ? x5 : constant_default5(+x5), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x5) {
    return arguments.length ? treemap.paddingTop(x5).paddingRight(x5).paddingBottom(x5).paddingLeft(x5) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x5) {
    return arguments.length ? (paddingTop = typeof x5 === "function" ? x5 : constant_default5(+x5), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x5) {
    return arguments.length ? (paddingRight = typeof x5 === "function" ? x5 : constant_default5(+x5), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x5) {
    return arguments.length ? (paddingBottom = typeof x5 === "function" ? x5 : constant_default5(+x5), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x5) {
    return arguments.length ? (paddingLeft = typeof x5 === "function" ? x5 : constant_default5(+x5), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
  for (sums[0] = sum2 = i = 0; i < n; ++i) {
    sums[i + 1] = sum2 += nodes[i].value;
  }
  partition5(0, n, parent.value, x06, y06, x12, y12);
  function partition5(i2, j, value3, x07, y07, x13, y13) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x07, node.y0 = y07;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value3 / 2 + valueOffset, k = i2 + 1, hi = j - 1;
    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget)
        k = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
      --k;
    var valueLeft = sums[k] - valueOffset, valueRight = value3 - valueLeft;
    if (x13 - x07 > y13 - y07) {
      var xk = value3 ? (x07 * valueRight + x13 * valueLeft) / value3 : x13;
      partition5(i2, k, valueLeft, x07, y07, xk, y13);
      partition5(k, j, valueRight, xk, y07, x13, y13);
    } else {
      var yk = value3 ? (y07 * valueRight + y13 * valueLeft) / value3 : y13;
      partition5(i2, k, valueLeft, x07, y07, x13, yk);
      partition5(k, j, valueRight, x07, yk, x13, y13);
    }
  }
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x06, y06, x12, y12) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);
}

// node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom10(ratio) {
  function resquarify(parent, x06, y06, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m2 = rows.length, value3 = parent.value;
      while (++j < m2) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          dice_default(row, x06, y06, x12, value3 ? y06 += (y12 - y06) * row.value / value3 : y12);
        else
          slice_default(row, x06, y06, value3 ? x06 += (x12 - x06) * row.value / value3 : x12, y12);
        value3 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x5) {
    return custom10((x5 = +x5) > 1 ? x5 : 1);
  };
  return resquarify;
}(phi);

// node_modules/vega-hierarchy/build/vega-hierarchy.module.js
function lookup3(tree, key2, filter3) {
  const map3 = {};
  tree.each((node) => {
    const t = node.data;
    if (filter3(t))
      map3[key2(t)] = node;
  });
  tree.lookup = map3;
  return tree;
}
function Nest(params2) {
  Transform.call(this, null, params2);
}
Nest.Definition = {
  "type": "Nest",
  "metadata": {
    "treesource": true,
    "changes": true
  },
  "params": [{
    "name": "keys",
    "type": "field",
    "array": true
  }, {
    "name": "generate",
    "type": "boolean"
  }]
};
var children = (n) => n.values;
inherits(Nest, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Nest transform requires an upstream data source.");
    }
    var gen = _.generate, mod = _.modified(), out = pulse2.clone(), tree = this.value;
    if (!tree || mod || pulse2.changed()) {
      if (tree) {
        tree.each((node) => {
          if (node.children && isTuple(node.data)) {
            out.rem.push(node.data);
          }
        });
      }
      this.value = tree = hierarchy({
        values: array(_.keys).reduce((n, k) => {
          n.key(k);
          return n;
        }, nest()).entries(out.source)
      }, children);
      if (gen) {
        tree.each((node) => {
          if (node.children) {
            node = ingest$1(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      }
      lookup3(tree, tupleid, tupleid);
    }
    out.source.root = tree;
    return out;
  }
});
function nest() {
  const keys3 = [], nest2 = {
    entries: (array4) => entries(apply2(array4, 0), 0),
    key: (d) => (keys3.push(d), nest2)
  };
  function apply2(array4, depth) {
    if (depth >= keys3.length) {
      return array4;
    }
    const n = array4.length, key2 = keys3[depth++], valuesByKey = {}, result = {};
    let i = -1, keyValue, value3, values2;
    while (++i < n) {
      keyValue = key2(value3 = array4[i]) + "";
      if (values2 = valuesByKey[keyValue]) {
        values2.push(value3);
      } else {
        valuesByKey[keyValue] = [value3];
      }
    }
    for (keyValue in valuesByKey) {
      result[keyValue] = apply2(valuesByKey[keyValue], depth);
    }
    return result;
  }
  function entries(map3, depth) {
    if (++depth > keys3.length)
      return map3;
    const array4 = [];
    for (const key2 in map3) {
      array4.push({
        key: key2,
        values: entries(map3[key2], depth)
      });
    }
    return array4;
  }
  return nest2;
}
function HierarchyLayout(params2) {
  Transform.call(this, null, params2);
}
var defaultSeparation3 = (a2, b2) => a2.parent === b2.parent ? 1 : 2;
inherits(HierarchyLayout, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source || !pulse2.source.root) {
      error(this.constructor.name + " transform requires a backing tree data source.");
    }
    const layout = this.layout(_.method), fields = this.fields, root = pulse2.source.root, as = _.as || fields;
    if (_.field)
      root.sum(_.field);
    else
      root.count();
    if (_.sort)
      root.sort(stableCompare(_.sort, (d) => d.data));
    setParams(layout, this.params, _);
    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation3 : one);
    }
    try {
      this.value = layout(root);
    } catch (err) {
      error(err);
    }
    root.each((node) => setFields(node, fields, as));
    return pulse2.reflow(_.modified()).modifies(as).modifies("leaf");
  }
});
function setParams(layout, params2, _) {
  for (let p, i = 0, n = params2.length; i < n; ++i) {
    p = params2[i];
    if (p in _)
      layout[p](_[p]);
  }
}
function setFields(node, fields, as) {
  const t = node.data, n = fields.length - 1;
  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }
  t[as[n]] = node.children ? node.children.length : 0;
}
var Output2 = ["x", "y", "r", "depth", "children"];
function Pack(params2) {
  HierarchyLayout.call(this, params2);
}
Pack.Definition = {
  "type": "Pack",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "radius",
    "type": "field",
    "default": null
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output2.length,
    "default": Output2
  }]
};
inherits(Pack, HierarchyLayout, {
  layout: pack_default,
  params: ["radius", "size", "padding"],
  fields: Output2
});
var Output$1 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Partition(params2) {
  HierarchyLayout.call(this, params2);
}
Partition.Definition = {
  "type": "Partition",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$1.length,
    "default": Output$1
  }]
};
inherits(Partition, HierarchyLayout, {
  layout: partition_default,
  params: ["size", "round", "padding"],
  fields: Output$1
});
function Stratify(params2) {
  Transform.call(this, null, params2);
}
Stratify.Definition = {
  "type": "Stratify",
  "metadata": {
    "treesource": true
  },
  "params": [{
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "parentKey",
    "type": "field",
    "required": true
  }]
};
inherits(Stratify, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Stratify transform requires an upstream data source.");
    }
    let tree = this.value;
    const mod = _.modified(), out = pulse2.fork(pulse2.ALL).materialize(pulse2.SOURCE), run2 = !tree || mod || pulse2.changed(pulse2.ADD_REM) || pulse2.modified(_.key.fields) || pulse2.modified(_.parentKey.fields);
    out.source = out.source.slice();
    if (run2) {
      tree = out.source.length ? lookup3(stratify_default().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup3(stratify_default()([{}]), _.key, _.key);
    }
    out.source.root = this.value = tree;
    return out;
  }
});
var Layouts = {
  tidy: tree_default,
  cluster: cluster_default
};
var Output$2 = ["x", "y", "depth", "children"];
function Tree(params2) {
  HierarchyLayout.call(this, params2);
}
Tree.Definition = {
  "type": "Tree",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "tidy",
    "values": ["tidy", "cluster"]
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "nodeSize",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "separation",
    "type": "boolean",
    "default": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$2.length,
    "default": Output$2
  }]
};
inherits(Tree, HierarchyLayout, {
  layout(method2) {
    const m2 = method2 || "tidy";
    if (has(Layouts, m2))
      return Layouts[m2]();
    else
      error("Unrecognized Tree layout method: " + m2);
  },
  params: ["size", "nodeSize"],
  fields: Output$2
});
function TreeLinks(params2) {
  Transform.call(this, [], params2);
}
TreeLinks.Definition = {
  "type": "TreeLinks",
  "metadata": {
    "tree": true,
    "generates": true,
    "changes": true
  },
  "params": []
};
inherits(TreeLinks, Transform, {
  transform(_, pulse2) {
    const links = this.value, tree = pulse2.source && pulse2.source.root, out = pulse2.fork(pulse2.NO_SOURCE), lut = {};
    if (!tree)
      error("TreeLinks transform requires a tree data source.");
    if (pulse2.changed(pulse2.ADD_REM)) {
      out.rem = links;
      pulse2.visit(pulse2.SOURCE, (t) => lut[tupleid(t)] = 1);
      tree.each((node) => {
        const t = node.data, p = node.parent && node.parent.data;
        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {
          out.add.push(ingest$1({
            source: p,
            target: t
          }));
        }
      });
      this.value = out.add;
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t) => lut[tupleid(t)] = 1);
      links.forEach((link2) => {
        if (lut[tupleid(link2.source)] || lut[tupleid(link2.target)]) {
          out.mod.push(link2);
        }
      });
    }
    return out;
  }
});
var Tiles = {
  binary: binary_default,
  dice: dice_default,
  slice: slice_default,
  slicedice: sliceDice_default,
  squarify: squarify_default,
  resquarify: resquarify_default
};
var Output$3 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Treemap(params2) {
  HierarchyLayout.call(this, params2);
}
Treemap.Definition = {
  "type": "Treemap",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "squarify",
    "values": ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingInner",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingOuter",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingTop",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingRight",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingBottom",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingLeft",
    "type": "number",
    "default": 0
  }, {
    "name": "ratio",
    "type": "number",
    "default": 1.618033988749895
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$3.length,
    "default": Output$3
  }]
};
inherits(Treemap, HierarchyLayout, {
  layout() {
    const x5 = treemap_default();
    x5.ratio = (_) => {
      const t = x5.tile();
      if (t.ratio)
        x5.tile(t.ratio(_));
    };
    x5.method = (_) => {
      if (has(Tiles, _))
        x5.tile(Tiles[_]);
      else
        error("Unrecognized Treemap layout method: " + _);
    };
    return x5;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: Output$3
});

// node_modules/vega-label/build/vega-label.module.js
var vega_label_module_exports = {};
__export(vega_label_module_exports, {
  label: () => Label
});
var ALPHA_MASK = 4278190080;
var INSIDE_OPACITY_IN_ALPHA = 268435456;
var INSIDE_OPACITY = 0.0625;
function baseBitmaps($2, data3) {
  const bitmap = $2.bitmap();
  (data3 || []).forEach((d) => bitmap.set($2(d.boundary[0]), $2(d.boundary[3])));
  return [bitmap, void 0];
}
function markBitmaps($2, avoidMarks, labelInside, isGroupArea) {
  const width2 = $2.width, height2 = $2.height, border = labelInside || isGroupArea, context3 = domCanvas(width2, height2).getContext("2d");
  avoidMarks.forEach((items) => draw2(context3, items, border));
  const buffer = new Uint32Array(context3.getImageData(0, 0, width2, height2).data.buffer), layer1 = $2.bitmap(), layer2 = border && $2.bitmap();
  let x5, y5, u, v, alpha;
  for (y5 = 0; y5 < height2; ++y5) {
    for (x5 = 0; x5 < width2; ++x5) {
      alpha = buffer[y5 * width2 + x5] & ALPHA_MASK;
      if (alpha) {
        u = $2(x5);
        v = $2(y5);
        if (!isGroupArea)
          layer1.set(u, v);
        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA)
          layer2.set(u, v);
      }
    }
  }
  return [layer1, layer2];
}
function draw2(context3, items, interior) {
  if (!items.length)
    return;
  const type2 = items[0].mark.marktype;
  if (type2 === "group") {
    items.forEach((group2) => {
      group2.items.forEach((mark) => draw2(context3, mark.items, interior));
    });
  } else {
    Marks[type2].draw(context3, {
      items: interior ? items.map(prepare) : items
    });
  }
}
function prepare(source3) {
  const item = rederive(source3, {});
  if (item.stroke) {
    item.strokeOpacity = 1;
  }
  if (item.fill) {
    item.fillOpacity = INSIDE_OPACITY;
    item.stroke = "#000";
    item.strokeOpacity = 1;
    item.strokeWidth = 2;
  }
  return item;
}
var DIV = 5;
var MOD2 = 31;
var SIZE = 32;
var RIGHT0 = new Uint32Array(SIZE + 1);
var RIGHT1 = new Uint32Array(SIZE + 1);
RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}
function Bitmap(w2, h2) {
  const array4 = new Uint32Array(~~((w2 * h2 + SIZE) / SIZE));
  function _set(index3, mask) {
    array4[index3] |= mask;
  }
  function _clear(index3, mask) {
    array4[index3] &= mask;
  }
  return {
    array: array4,
    get: (x5, y5) => {
      const index3 = y5 * w2 + x5;
      return array4[index3 >>> DIV] & 1 << (index3 & MOD2);
    },
    set: (x5, y5) => {
      const index3 = y5 * w2 + x5;
      _set(index3 >>> DIV, 1 << (index3 & MOD2));
    },
    clear: (x5, y5) => {
      const index3 = y5 * w2 + x5;
      _clear(index3 >>> DIV, ~(1 << (index3 & MOD2)));
    },
    getRange: (x5, y5, x22, y22) => {
      let r = y22, start, end, indexStart, indexEnd;
      for (; r >= y5; --r) {
        start = r * w2 + x5;
        end = r * w2 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          if (array4[indexStart] & RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]) {
            return true;
          }
        } else {
          if (array4[indexStart] & RIGHT0[start & MOD2])
            return true;
          if (array4[indexEnd] & RIGHT1[(end & MOD2) + 1])
            return true;
          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array4[i])
              return true;
          }
        }
      }
      return false;
    },
    setRange: (x5, y5, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y5 <= y22; ++y5) {
        start = y5 * w2 + x5;
        end = y5 * w2 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD2]);
          _set(indexEnd, RIGHT1[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _set(i, 4294967295);
        }
      }
    },
    clearRange: (x5, y5, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y5 <= y22; ++y5) {
        start = y5 * w2 + x5;
        end = y5 * w2 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD2] | RIGHT0[(end & MOD2) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD2]);
          _clear(indexEnd, RIGHT0[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _clear(i, 0);
        }
      }
    },
    outOfBounds: (x5, y5, x22, y22) => x5 < 0 || y5 < 0 || y22 >= h2 || x22 >= w2
  };
}
function scaler(width2, height2, padding2) {
  const ratio = Math.max(1, Math.sqrt(width2 * height2 / 1e6)), w2 = ~~((width2 + 2 * padding2 + ratio) / ratio), h2 = ~~((height2 + 2 * padding2 + ratio) / ratio), scale6 = (_) => ~~((_ + padding2) / ratio);
  scale6.invert = (_) => _ * ratio - padding2;
  scale6.bitmap = () => Bitmap(w2, h2);
  scale6.ratio = ratio;
  scale6.padding = padding2;
  scale6.width = width2;
  scale6.height = height2;
  return scale6;
}
function placeAreaLabelNaive($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height;
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxAreaWidth = 0, x12, x22, y12, y22, x5, y5, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x22 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y22 = items[i].y2 === void 0 ? y12 : items[i].y2;
      x5 = (x12 + x22) / 2;
      y5 = (y12 + y22) / 2;
      areaWidth = Math.abs(x22 - x12 + y22 - y12);
      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x5;
        d.y = y5;
      }
    }
    x5 = textWidth / 2;
    y5 = textHeight / 2;
    x12 = d.x - x5;
    x22 = d.x + x5;
    y12 = d.y - y5;
    y22 = d.y + y5;
    d.align = "center";
    if (x12 < 0 && x22 <= width2) {
      d.align = "left";
    } else if (0 <= x12 && width2 < x22) {
      d.align = "right";
    }
    d.baseline = "middle";
    if (y12 < 0 && y22 <= height2) {
      d.baseline = "top";
    } else if (0 <= y12 && height2 < y22) {
      d.baseline = "bottom";
    }
    return true;
  };
}
function outOfBounds(x5, y5, textWidth, textHeight, width2, height2) {
  let r = textWidth / 2;
  return x5 - r < 0 || x5 + r > width2 || y5 - (r = textHeight / 2) < 0 || y5 + r > height2;
}
function collision($2, x5, y5, textHeight, textWidth, h2, bm0, bm1) {
  const w2 = textWidth * h2 / (textHeight * 2), x12 = $2(x5 - w2), x22 = $2(x5 + w2), y12 = $2(y5 - (h2 = h2 / 2)), y22 = $2(y5 + h2);
  return bm0.outOfBounds(x12, y12, x22, y22) || bm0.getRange(x12, y12, x22, y22) || bm1 && bm1.getRange(x12, y12, x22, y22);
}
function placeAreaLabelReducedSearch($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1];
  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {
    const x5 = $2.invert(_x), y5 = $2.invert(_y);
    let lo = maxSize, hi = height2, mid;
    if (!outOfBounds(x5, y5, textWidth, textHeight, width2, height2) && !collision($2, x5, y5, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x5, y5, textHeight, textWidth, textHeight, bm0, null)) {
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;
        if (collision($2, x5, y5, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      if (lo > maxSize) {
        return [x5, y5, lo, true];
      }
    }
  }
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x22, y12, y22, x5, y5, _x, _y, _x1, _xMid, _x2, _y1, _yMid, _y2, areaWidth, result, swapTmp;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x22 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y22 = items[i].y2 === void 0 ? y12 : items[i].y2;
      if (x12 > x22) {
        swapTmp = x12;
        x12 = x22;
        x22 = swapTmp;
      }
      if (y12 > y22) {
        swapTmp = y12;
        y12 = y22;
        y22 = swapTmp;
      }
      _x1 = $2(x12);
      _x2 = $2(x22);
      _xMid = ~~((_x1 + _x2) / 2);
      _y1 = $2(y12);
      _y2 = $2(y22);
      _yMid = ~~((_y1 + _y2) / 2);
      for (_x = _xMid; _x >= _x1; --_x) {
        for (_y = _yMid; _y >= _y1; --_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      for (_x = _xMid; _x <= _x2; ++_x) {
        for (_y = _yMid; _y <= _y2; ++_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x22 - x12 + y22 - y12);
        x5 = (x12 + x22) / 2;
        y5 = (y12 + y22) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x5, y5, textWidth, textHeight, width2, height2) && !collision($2, x5, y5, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x5;
          d.y = y5;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x5 = textWidth / 2;
      y5 = textHeight / 2;
      bm0.setRange($2(d.x - x5), $2(d.y - y5), $2(d.x + x5), $2(d.y + y5));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var X_DIR = [-1, -1, 1, 1];
var Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], bm2 = $2.bitmap();
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text), stack = [];
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x22, y12, y22, x5, y5, _x, _y, lo, hi, mid, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x22 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y22 = items[i].y2 === void 0 ? y12 : items[i].y2;
      stack.push([$2((x12 + x22) / 2), $2((y12 + y22) / 2)]);
      while (stack.length) {
        [_x, _y] = stack.pop();
        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y))
          continue;
        bm2.set(_x, _y);
        for (let j = 0; j < 4; ++j) {
          x5 = _x + X_DIR[j];
          y5 = _y + Y_DIR[j];
          if (!bm2.outOfBounds(x5, y5, x5, y5))
            stack.push([x5, y5]);
        }
        x5 = $2.invert(_x);
        y5 = $2.invert(_y);
        lo = maxSize;
        hi = height2;
        if (!outOfBounds(x5, y5, textWidth, textHeight, width2, height2) && !collision($2, x5, y5, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x5, y5, textHeight, textWidth, textHeight, bm0, null)) {
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($2, x5, y5, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          if (lo > maxSize) {
            d.x = x5;
            d.y = y5;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x22 - x12 + y22 - y12);
        x5 = (x12 + x22) / 2;
        y5 = (y12 + y22) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x5, y5, textWidth, textHeight, width2, height2) && !collision($2, x5, y5, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x5;
          d.y = y5;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x5 = textWidth / 2;
      y5 = textHeight / 2;
      bm0.setRange($2(d.x - x5), $2(d.y - y5), $2(d.x + x5), $2(d.y + y5));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var Aligns = ["right", "center", "left"];
var Baselines = ["bottom", "middle", "top"];
function placeMarkLabel($2, bitmaps, anchors, offsets2) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], n = offsets2.length;
  return function(d) {
    const boundary = d.boundary, textHeight = d.datum.fontSize;
    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width2 || boundary[3] > height2) {
      return false;
    }
    let textWidth = 0, dx, dy, isInside, sizeFactor, insideFactor, x12, x22, y12, y22, xc, yc, _x1, _x2, _y1, _y2;
    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 3) - 1;
      dy = (anchors[i] >>> 2 & 3) - 1;
      isInside = dx === 0 && dy === 0 || offsets2[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets2[i] < 0 ? -1 : 1;
      x12 = boundary[1 + dx] + offsets2[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets2[i] * dy * sizeFactor;
      y12 = yc - textHeight / 2;
      y22 = yc + textHeight / 2;
      _x1 = $2(x12);
      _y1 = $2(y12);
      _y2 = $2(y22);
      if (!textWidth) {
        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x12, x12, y12, y22, boundary, isInside)) {
          continue;
        } else {
          textWidth = textMetrics.width(d.datum, d.datum.text);
        }
      }
      xc = x12 + insideFactor * textWidth * dx / 2;
      x12 = xc - textWidth / 2;
      x22 = xc + textWidth / 2;
      _x1 = $2(x12);
      _x2 = $2(x22);
      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x12, x22, y12, y22, boundary, isInside)) {
        d.x = !dx ? xc : dx * insideFactor < 0 ? x22 : x12;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y22 : y12;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x2, _y2);
        return true;
      }
    }
    return false;
  };
}
function test(_x1, _x2, _y1, _y2, bm0, bm1, x12, x22, y12, y22, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x12, y12, x22, y22, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));
}
function isInMarkBound(x12, y12, x22, y22, boundary) {
  return boundary[0] <= x12 && x22 <= boundary[2] && boundary[3] <= y12 && y22 <= boundary[5];
}
var TOP = 0;
var MIDDLE = 4;
var BOTTOM = 8;
var LEFT = 0;
var CENTER = 1;
var RIGHT = 2;
var anchorCode = {
  "top-left": TOP + LEFT,
  "top": TOP + CENTER,
  "top-right": TOP + RIGHT,
  "left": MIDDLE + LEFT,
  "middle": MIDDLE + CENTER,
  "right": MIDDLE + RIGHT,
  "bottom-left": BOTTOM + LEFT,
  "bottom": BOTTOM + CENTER,
  "bottom-right": BOTTOM + RIGHT
};
var placeAreaLabel = {
  "naive": placeAreaLabelNaive,
  "reduced-search": placeAreaLabelReducedSearch,
  "floodfill": placeAreaLabelFloodFill
};
function labelLayout(texts, size, compare3, offset4, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding2, method2) {
  if (!texts.length)
    return texts;
  const positions = Math.max(offset4.length, anchor.length), offsets2 = getOffsets(offset4, positions), anchors = getAnchors(anchor, positions), marktype = markType(texts[0].datum), grouptype = marktype === "group" && texts[0].datum.items[markIndex].marktype, isGroupArea = grouptype === "area", boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex), $2 = scaler(size[0], size[1], padding2), isNaiveGroupArea = isGroupArea && method2 === "naive";
  const data3 = texts.map((d) => ({
    datum: d,
    opacity: 0,
    x: void 0,
    y: void 0,
    align: void 0,
    baseline: void 0,
    boundary: boundary(d)
  }));
  let bitmaps;
  if (!isNaiveGroupArea) {
    if (compare3) {
      data3.sort((a2, b2) => compare3(a2.datum, b2.datum));
    }
    let labelInside = false;
    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      labelInside = anchors[i] === 5 || offsets2[i] < 0;
    }
    if (marktype && (avoidBaseMark || isGroupArea)) {
      avoidMarks = [texts.map((d) => d.datum)].concat(avoidMarks);
    }
    bitmaps = avoidMarks.length ? markBitmaps($2, avoidMarks, labelInside, isGroupArea) : baseBitmaps($2, avoidBaseMark && data3);
  }
  const place2 = isGroupArea ? placeAreaLabel[method2]($2, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($2, bitmaps, anchors, offsets2);
  data3.forEach((d) => d.opacity = +place2(d));
  return data3;
}
function getOffsets(_, count2) {
  const offsets2 = new Float64Array(count2), n = _.length;
  for (let i = 0; i < n; ++i)
    offsets2[i] = _[i] || 0;
  for (let i = n; i < count2; ++i)
    offsets2[i] = offsets2[n - 1];
  return offsets2;
}
function getAnchors(_, count2) {
  const anchors = new Int8Array(count2), n = _.length;
  for (let i = 0; i < n; ++i)
    anchors[i] |= anchorCode[_[i]];
  for (let i = n; i < count2; ++i)
    anchors[i] = anchors[n - 1];
  return anchors;
}
function markType(item) {
  return item && item.mark && item.mark.marktype;
}
function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = (d) => [d.x, d.x, d.x, d.y, d.y, d.y];
  if (!marktype) {
    return xy;
  } else if (marktype === "line" || marktype === "area") {
    return (d) => xy(d.datum);
  } else if (grouptype === "line") {
    return (d) => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === "start" ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return (d) => {
      const b2 = d.datum.bounds;
      return [b2.x1, (b2.x1 + b2.x2) / 2, b2.x2, b2.y1, (b2.y1 + b2.y2) / 2, b2.y2];
    };
  }
}
var Output3 = ["x", "y", "opacity", "align", "baseline"];
var Anchors = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function Label(params2) {
  Transform.call(this, null, params2);
}
Label.Definition = {
  type: "Label",
  metadata: {
    modifies: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: true,
    default: Anchors
  }, {
    name: "offset",
    type: "number",
    array: true,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: true
  }, {
    name: "avoidMarks",
    type: "data",
    array: true
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output3.length,
    default: Output3
  }]
};
inherits(Label, Transform, {
  transform(_, pulse2) {
    function modp(param2) {
      const p = _[param2];
      return isFunction(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || modp("sort")))
      return;
    if (!_.size || _.size.length !== 2) {
      error("Size parameter should be specified as a [width, height] array.");
    }
    const as = _.as || Output3;
    labelLayout(pulse2.materialize(pulse2.SOURCE).source, _.size, _.sort, array(_.offset || 1), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark === false ? false : true, _.lineAnchor || "end", _.markIndex || 0, _.padding || 0, _.method || "naive").forEach((l) => {
      const t = l.datum;
      t[as[0]] = l.x;
      t[as[1]] = l.y;
      t[as[2]] = l.opacity;
      t[as[3]] = l.align;
      t[as[4]] = l.baseline;
    });
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-regression/build/vega-regression.module.js
var vega_regression_module_exports = {};
__export(vega_regression_module_exports, {
  loess: () => Loess,
  regression: () => Regression
});
function partition4(data3, groupby) {
  var groups = [], get6 = function(f) {
    return f(t);
  }, map3, i, n, t, k, g;
  if (groupby == null) {
    groups.push(data3);
  } else {
    for (map3 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k = groupby.map(get6);
      g = map3[k];
      if (!g) {
        map3[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(t);
    }
  }
  return groups;
}
function Loess(params2) {
  Transform.call(this, null, params2);
}
Loess.Definition = {
  "type": "Loess",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0.3
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Loess, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition4(source3, _.groupby), names = (_.groupby || []).map(accessorName), m2 = names.length, as = _.as || [accessorName(_.x), accessorName(_.y)], values2 = [];
      groups.forEach((g) => {
        loess(g, _.x, _.y, _.bandwidth || 0.3).forEach((p) => {
          const t = {};
          for (let i = 0; i < m2; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values2.push(ingest$1(t));
        });
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
var Methods2 = {
  linear,
  log: log2,
  exp: exp2,
  pow: pow2,
  quad,
  poly
};
var degreesOfFreedom = (method2, order) => method2 === "poly" ? order : method2 === "quad" ? 2 : 1;
function Regression(params2) {
  Transform.call(this, null, params2);
}
Regression.Definition = {
  "type": "Regression",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "string",
    "default": "linear",
    "values": Object.keys(Methods2)
  }, {
    "name": "order",
    "type": "number",
    "default": 3
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "params",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Regression, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition4(source3, _.groupby), names = (_.groupby || []).map(accessorName), method2 = _.method || "linear", order = _.order || 3, dof = degreesOfFreedom(method2, order), as = _.as || [accessorName(_.x), accessorName(_.y)], fit3 = Methods2[method2], values2 = [];
      let domain2 = _.extent;
      if (!has(Methods2, method2)) {
        error("Invalid regression method: " + method2);
      }
      if (domain2 != null) {
        if (method2 === "log" && domain2[0] <= 0) {
          pulse2.dataflow.warn("Ignoring extent with values <= 0 for log regression.");
          domain2 = null;
        }
      }
      groups.forEach((g) => {
        const n = g.length;
        if (n <= dof) {
          pulse2.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const model = fit3(g, _.x, _.y, order);
        if (_.params) {
          values2.push(ingest$1({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }
        const dom = domain2 || extent(g, _.x), add5 = (p) => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values2.push(ingest$1(t));
        };
        if (method2 === "linear") {
          dom.forEach((x5) => add5([x5, model.predict(x5)]));
        } else {
          sampleCurve(model.predict, dom, 25, 200).forEach(add5);
        }
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});

// node_modules/vega-voronoi/build/vega-voronoi.module.js
var vega_voronoi_module_exports = {};
__export(vega_voronoi_module_exports, {
  voronoi: () => Voronoi2
});

// node_modules/vega-voronoi/node_modules/delaunator/index.js
var EPSILON2 = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class {
  static from(points2, getX = defaultGetX, getY = defaultGetY) {
    const n = points2.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points2[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize).fill(-1);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY2 = -Infinity;
    for (let i = 0; i < n; i++) {
      const x5 = coords[2 * i];
      const y5 = coords[2 * i + 1];
      if (x5 < minX)
        minX = x5;
      if (y5 < minY)
        minY = y5;
      if (x5 > maxX)
        maxX = x5;
      if (y5 > maxY2)
        maxY2 = y5;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY2) / 2;
    let minDist = Infinity;
    let i0, i1, i2;
    for (let i = 0; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    minDist = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0)
        continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1)
        continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id2 = this._ids[i];
        if (this._dists[id2] > d0) {
          hull[j++] = id2;
          d0 = this._dists[id2];
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
      const i = i1;
      const x5 = i1x;
      const y5 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x5;
      i2y = y5;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k = 0, xp, yp; k < this._ids.length; k++) {
      const i = this._ids[k];
      const x5 = coords[2 * i];
      const y5 = coords[2 * i + 1];
      if (k > 0 && Math.abs(x5 - xp) <= EPSILON2 && Math.abs(y5 - yp) <= EPSILON2)
        continue;
      xp = x5;
      yp = y5;
      if (i === i0 || i === i1 || i === i2)
        continue;
      let start = 0;
      for (let j = 0, key2 = this._hashKey(x5, y5); j < this._hashSize; j++) {
        start = hullHash[(key2 + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start])
          break;
      }
      start = hullPrev[start];
      let e = start, q;
      while (q = hullNext[e], !orient(x5, y5, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
        e = q;
        if (e === start) {
          e = -1;
          break;
        }
      }
      if (e === -1)
        continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q = hullNext[n2], orient(x5, y5, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1])) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e === start) {
        while (q = hullPrev[e], orient(x5, y5, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e] = e;
          hullSize--;
          e = q;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x5, y5)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x5, y5) {
    return Math.floor(pseudoAngle(x5 - this._cx, y5 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a2) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b2 = halfedges[a2];
      const a0 = a2 - a2 % 3;
      ar = a0 + (a2 + 2) % 3;
      if (b2 === -1) {
        if (i === 0)
          break;
        a2 = EDGE_STACK[--i];
        continue;
      }
      const b0 = b2 - b2 % 3;
      const al = a0 + (a2 + 1) % 3;
      const bl2 = b0 + (b2 + 2) % 3;
      const p02 = triangles[ar];
      const pr = triangles[a2];
      const pl = triangles[al];
      const p1 = triangles[bl2];
      const illegal = inCircle(coords[2 * p02], coords[2 * p02 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);
      if (illegal) {
        triangles[a2] = p1;
        triangles[b2] = p02;
        const hbl = halfedges[bl2];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl2) {
              this._hullTri[e] = a2;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a2, hbl);
        this._link(b2, halfedges[ar]);
        this._link(ar, bl2);
        const br2 = b0 + (b2 + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br2;
        }
      } else {
        if (i === 0)
          break;
        a2 = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a2, b2) {
    this._halfedges[a2] = b2;
    if (b2 !== -1)
      this._halfedges[b2] = a2;
  }
  _addTriangle(i0, i1, i2, a2, b2, c2) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a2);
    this._link(t + 1, b2);
    this._link(t + 2, c2);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function orientIfSure(px2, py2, rx, ry, qx, qy) {
  const l = (ry - py2) * (qx - px2);
  const r = (rx - px2) * (qy - py2);
  return Math.abs(l - r) >= 33306690738754716e-32 * Math.abs(l + r) ? l - r : 0;
}
function orient(rx, ry, qx, qy, px2, py2) {
  const sign3 = orientIfSure(px2, py2, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px2, py2) || orientIfSure(qx, qy, px2, py2, rx, ry);
  return sign3 < 0;
}
function inCircle(ax, ay, bx, by, cx, cy, px2, py2) {
  const dx = ax - px2;
  const dy = ay - py2;
  const ex = bx - px2;
  const ey = by - py2;
  const fx = cx - px2;
  const fy = cy - py2;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl2 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x5 = (ey * bl2 - dy * cl) * d;
  const y5 = (dx * cl - ex * bl2) * d;
  return x5 * x5 + y5 * y5;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl2 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x5 = ax + (ey * bl2 - dy * cl) * d;
  const y5 = ay + (dx * cl - ex * bl2) * d;
  return { x: x5, y: y5 };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp2 = ids[i];
      const tempDist = dists[temp2];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist)
        ids[j + 1] = ids[j--];
      ids[j + 1] = temp2;
    }
  } else {
    const median = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap2(ids, median, i);
    if (dists[ids[left]] > dists[ids[right]])
      swap2(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]])
      swap2(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]])
      swap2(ids, left, i);
    const temp2 = ids[i];
    const tempDist = dists[temp2];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i)
        break;
      swap2(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp2;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap2(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/vega-voronoi/node_modules/d3-delaunay/src/path.js
var epsilon6 = 1e-6;
var Path2 = class {
  constructor() {
    this._x0 = this._y0 = this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x5, y5) {
    this._ += `M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y5}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x5, y5) {
    this._ += `L${this._x1 = +x5},${this._y1 = +y5}`;
  }
  arc(x5, y5, r) {
    x5 = +x5, y5 = +y5, r = +r;
    const x06 = x5 + r;
    const y06 = y5;
    if (r < 0)
      throw new Error("negative radius");
    if (this._x1 === null)
      this._ += `M${x06},${y06}`;
    else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6)
      this._ += "L" + x06 + "," + y06;
    if (!r)
      return;
    this._ += `A${r},${r},0,1,1,${x5 - r},${y5}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
  }
  rect(x5, y5, w2, h2) {
    this._ += `M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y5}h${+w2}v${+h2}h${-w2}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/vega-voronoi/node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x5, y5) {
    this._.push([x5, y5]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x5, y5) {
    this._.push([x5, y5]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/vega-voronoi/node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
      throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points: points2, hull, triangles }, vectors } = this;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x5, y5; i < n; i += 3, j += 2) {
      const t14 = triangles[i] * 2;
      const t23 = triangles[i + 1] * 2;
      const t33 = triangles[i + 2] * 2;
      const x13 = points2[t14];
      const y13 = points2[t14 + 1];
      const x22 = points2[t23];
      const y22 = points2[t23 + 1];
      const x32 = points2[t33];
      const y32 = points2[t33 + 1];
      const dx = x22 - x13;
      const dy = y22 - y13;
      const ex = x32 - x13;
      const ey = y32 - y13;
      const bl2 = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const ab = (dx * ey - dy * ex) * 2;
      if (!ab) {
        x5 = (x13 + x32) / 2 - 1e8 * ey;
        y5 = (y13 + y32) / 2 + 1e8 * ex;
      } else if (Math.abs(ab) < 1e-8) {
        x5 = (x13 + x32) / 2;
        y5 = (y13 + y32) / 2;
      } else {
        const d = 1 / ab;
        x5 = x13 + (ey * bl2 - dy * cl) * d;
        y5 = y13 + (dx * cl - ex * bl2) * d;
      }
      circumcenters[j] = x5;
      circumcenters[j + 1] = y5;
    }
    let h2 = hull[hull.length - 1];
    let p02, p1 = h2 * 4;
    let x06, x12 = points2[2 * h2];
    let y06, y12 = points2[2 * h2 + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h2 = hull[i];
      p02 = p1, x06 = x12, y06 = y12;
      p1 = h2 * 4, x12 = points2[2 * h2], y12 = points2[2 * h2 + 1];
      vectors[p02 + 2] = vectors[p1] = y06 - y12;
      vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;
    }
  }
  render(context3) {
    const buffer = context3 == null ? context3 = new Path2() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1)
      return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i)
        continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context3);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x5 = circumcenters[t];
      const y5 = circumcenters[t + 1];
      const v = h0 * 4;
      const p = this._project(x5, y5, vectors[v + 2], vectors[v + 3]);
      if (p)
        this._renderSegment(x5, y5, p[0], p[1], context3);
    }
    return buffer && buffer.value();
  }
  renderBounds(context3) {
    const buffer = context3 == null ? context3 = new Path2() : void 0;
    context3.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context3) {
    const buffer = context3 == null ? context3 = new Path2() : void 0;
    const points2 = this._clip(i);
    if (points2 === null || !points2.length)
      return;
    context3.moveTo(points2[0], points2[1]);
    let n = points2.length;
    while (points2[0] === points2[n - 2] && points2[1] === points2[n - 1] && n > 1)
      n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points2[i2] !== points2[i2 - 2] || points2[i2 + 1] !== points2[i2 - 1])
        context3.lineTo(points2[i2], points2[i2 + 1]);
    }
    context3.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points: points2 } } = this;
    for (let i = 0, n = points2.length / 2; i < n; ++i) {
      const cell2 = this.cellPolygon(i);
      if (cell2)
        cell2.index = i, yield cell2;
    }
  }
  cellPolygon(i) {
    const polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x06, y06, x12, y12, context3) {
    let S;
    const c0 = this._regioncode(x06, y06);
    const c1 = this._regioncode(x12, y12);
    if (c0 === 0 && c1 === 0) {
      context3.moveTo(x06, y06);
      context3.lineTo(x12, y12);
    } else if (S = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
      context3.moveTo(S[0], S[1]);
      context3.lineTo(S[2], S[3]);
    }
  }
  contains(i, x5, y5) {
    if ((x5 = +x5, x5 !== x5) || (y5 = +y5, y5 !== y5))
      return false;
    return this.delaunay._step(i, x5, y5) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci)
      for (const j of this.delaunay.neighbors(i)) {
        const cj = this._clip(j);
        if (cj)
          loop:
            for (let ai = 0, li = ci.length; ai < li; ai += 2) {
              for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
                  yield j;
                  break loop;
                }
              }
            }
      }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1)
      return null;
    const points2 = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points2.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points2;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points2 = this._cell(i);
    if (points2 === null)
      return null;
    const { vectors: V } = this;
    const v = i * 4;
    return V[v] || V[v + 1] ? this._clipInfinite(i, points2, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points2);
  }
  _clipFinite(i, points2) {
    const n = points2.length;
    let P = null;
    let x06, y06, x12 = points2[n - 2], y12 = points2[n - 1];
    let c0, c1 = this._regioncode(x12, y12);
    let e0, e1;
    for (let j = 0; j < n; j += 2) {
      x06 = x12, y06 = y12, x12 = points2[j], y12 = points2[j + 1];
      c0 = c1, c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P)
          P.push(x12, y12);
        else
          P = [x12, y12];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null)
            continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null)
            continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1)
            this._edge(i, e0, e1, P, P.length);
          if (P)
            P.push(sx0, sy0);
          else
            P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1)
          this._edge(i, e0, e1, P, P.length);
        if (P)
          P.push(sx1, sy1);
        else
          P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1)
        this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x06, y06, x12, y12, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0)
        return [x06, y06, x12, y12];
      if (c0 & c1)
        return null;
      let x5, y5, c2 = c0 || c1;
      if (c2 & 8)
        x5 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y5 = this.ymax;
      else if (c2 & 4)
        x5 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y5 = this.ymin;
      else if (c2 & 2)
        y5 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x5 = this.xmax;
      else
        y5 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x5 = this.xmin;
      if (c0)
        x06 = x5, y06 = y5, c0 = this._regioncode(x06, y06);
      else
        x12 = x5, y12 = y5, c1 = this._regioncode(x12, y12);
    }
  }
  _clipInfinite(i, points2, vx0, vy0, vxn, vyn) {
    let P = Array.from(points2), p;
    if (p = this._project(P[0], P[1], vx0, vy0))
      P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))
      P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1)
          j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x5, y5;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x5 = this.xmax, y5 = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x5 = this.xmax, y5 = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x5 = this.xmin, y5 = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x5 = this.xmin, y5 = this.ymin;
          break;
      }
      if ((P[j] !== x5 || P[j + 1] !== y5) && this.contains(i, x5, y5)) {
        P.splice(j, 0, x5, y5), j += 2;
      }
    }
    if (P.length > 4) {
      for (let i2 = 0; i2 < P.length; i2 += 2) {
        const j2 = (i2 + 2) % P.length, k = (i2 + 4) % P.length;
        if (P[i2] === P[j2] && P[j2] === P[k] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k + 1])
          P.splice(j2, 2), i2 -= 2;
      }
    }
    return j;
  }
  _project(x06, y06, vx, vy) {
    let t = Infinity, c2, x5, y5;
    if (vy < 0) {
      if (y06 <= this.ymin)
        return null;
      if ((c2 = (this.ymin - y06) / vy) < t)
        y5 = this.ymin, x5 = x06 + (t = c2) * vx;
    } else if (vy > 0) {
      if (y06 >= this.ymax)
        return null;
      if ((c2 = (this.ymax - y06) / vy) < t)
        y5 = this.ymax, x5 = x06 + (t = c2) * vx;
    }
    if (vx > 0) {
      if (x06 >= this.xmax)
        return null;
      if ((c2 = (this.xmax - x06) / vx) < t)
        x5 = this.xmax, y5 = y06 + (t = c2) * vy;
    } else if (vx < 0) {
      if (x06 <= this.xmin)
        return null;
      if ((c2 = (this.xmin - x06) / vx) < t)
        x5 = this.xmin, y5 = y06 + (t = c2) * vy;
    }
    return [x5, y5];
  }
  _edgecode(x5, y5) {
    return (x5 === this.xmin ? 1 : x5 === this.xmax ? 2 : 0) | (y5 === this.ymin ? 4 : y5 === this.ymax ? 8 : 0);
  }
  _regioncode(x5, y5) {
    return (x5 < this.xmin ? 1 : x5 > this.xmax ? 2 : 0) | (y5 < this.ymin ? 4 : y5 > this.ymax ? 8 : 0);
  }
};

// node_modules/vega-voronoi/node_modules/d3-delaunay/src/delaunay.js
var tau5 = 2 * Math.PI;
var pow5 = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear2(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a2 = 2 * triangles[i], b2 = 2 * triangles[i + 1], c2 = 2 * triangles[i + 2], cross2 = (coords[c2] - coords[a2]) * (coords[b2 + 1] - coords[a2 + 1]) - (coords[b2] - coords[a2]) * (coords[c2 + 1] - coords[a2 + 1]);
    if (cross2 > 1e-10)
      return false;
  }
  return true;
}
function jitter(x5, y5, r) {
  return [x5 + Math.sin(x5 + y5) * r, y5 + Math.cos(x5 - y5) * r];
}
var Delaunay = class {
  static from(points2, fx = pointX, fy = pointY, that) {
    return new Delaunay("length" in points2 ? flatArray(points2, fx, fy, that) : Float64Array.from(flatIterable(points2, fx, fy, that)));
  }
  constructor(points2) {
    this._delaunator = new Delaunator(points2);
    this.inedges = new Int32Array(points2.length / 2);
    this._hullIndex = new Int32Array(points2.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points2 = this.points;
    if (d.hull && d.hull.length > 2 && collinear2(d)) {
      this.collinear = Int32Array.from({ length: points2.length / 2 }, (_, i) => i).sort((i, j) => points2[2 * i] - points2[2 * j] || points2[2 * i + 1] - points2[2 * j + 1]);
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds2 = [points2[2 * e], points2[2 * e + 1], points2[2 * f], points2[2 * f + 1]], r = 1e-8 * Math.hypot(bounds2[3] - bounds2[1], bounds2[2] - bounds2[0]);
      for (let i = 0, n = points2.length / 2; i < n; ++i) {
        const p = jitter(points2[2 * i], points2[2 * i + 1], r);
        points2[2 * i] = p[0];
        points2[2 * i + 1] = p[1];
      }
      this._delaunator = new Delaunator(points2);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1)
        inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      this.triangles[1] = hull[1];
      this.triangles[2] = hull[1];
      inedges[hull[0]] = 1;
      if (hull.length === 2)
        inedges[hull[1]] = 0;
    }
  }
  voronoi(bounds2) {
    return new Voronoi(this, bounds2);
  }
  *neighbors(i) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;
    if (collinear3) {
      const l = collinear3.indexOf(i);
      if (l > 0)
        yield collinear3[l - 1];
      if (l < collinear3.length - 1)
        yield collinear3[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1)
      return;
    let e = e0, p02 = -1;
    do {
      yield p02 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        return;
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p02)
          yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x5, y5, i = 0) {
    if ((x5 = +x5, x5 !== x5) || (y5 = +y5, y5 !== y5))
      return -1;
    const i0 = i;
    let c2;
    while ((c2 = this._step(i, x5, y5)) >= 0 && c2 !== i && c2 !== i0)
      i = c2;
    return c2;
  }
  _step(i, x5, y5) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points: points2 } = this;
    if (inedges[i] === -1 || !points2.length)
      return (i + 1) % (points2.length >> 1);
    let c2 = i;
    let dc = pow5(x5 - points2[i * 2], 2) + pow5(y5 - points2[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow5(x5 - points2[t * 2], 2) + pow5(y5 - points2[t * 2 + 1], 2);
      if (dt < dc)
        dc = dt, c2 = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        break;
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow5(x5 - points2[e * 2], 2) + pow5(y5 - points2[e * 2 + 1], 2) < dc)
            return e;
        }
        break;
      }
    } while (e !== e0);
    return c2;
  }
  render(context3) {
    const buffer = context3 == null ? context3 = new Path2() : void 0;
    const { points: points2, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i)
        continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context3.moveTo(points2[ti], points2[ti + 1]);
      context3.lineTo(points2[tj], points2[tj + 1]);
    }
    this.renderHull(context3);
    return buffer && buffer.value();
  }
  renderPoints(context3, r = 2) {
    const buffer = context3 == null ? context3 = new Path2() : void 0;
    const { points: points2 } = this;
    for (let i = 0, n = points2.length; i < n; i += 2) {
      const x5 = points2[i], y5 = points2[i + 1];
      context3.moveTo(x5 + r, y5);
      context3.arc(x5, y5, r, 0, tau5);
    }
    return buffer && buffer.value();
  }
  renderHull(context3) {
    const buffer = context3 == null ? context3 = new Path2() : void 0;
    const { hull, points: points2 } = this;
    const h2 = hull[0] * 2, n = hull.length;
    context3.moveTo(points2[h2], points2[h2 + 1]);
    for (let i = 1; i < n; ++i) {
      const h3 = 2 * hull[i];
      context3.lineTo(points2[h3], points2[h3 + 1]);
    }
    context3.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context3) {
    const buffer = context3 == null ? context3 = new Path2() : void 0;
    const { points: points2, triangles } = this;
    const t05 = triangles[i *= 3] * 2;
    const t14 = triangles[i + 1] * 2;
    const t23 = triangles[i + 2] * 2;
    context3.moveTo(points2[t05], points2[t05 + 1]);
    context3.lineTo(points2[t14], points2[t14 + 1]);
    context3.lineTo(points2[t23], points2[t23 + 1]);
    context3.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
};
function flatArray(points2, fx, fy, that) {
  const n = points2.length;
  const array4 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points2[i];
    array4[i * 2] = fx.call(that, p, i, points2);
    array4[i * 2 + 1] = fy.call(that, p, i, points2);
  }
  return array4;
}
function* flatIterable(points2, fx, fy, that) {
  let i = 0;
  for (const p of points2) {
    yield fx.call(that, p, i, points2);
    yield fy.call(that, p, i, points2);
    ++i;
  }
}

// node_modules/vega-voronoi/build/vega-voronoi.module.js
function Voronoi2(params2) {
  Transform.call(this, null, params2);
}
Voronoi2.Definition = {
  "type": "Voronoi",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "default": [[-1e5, -1e5], [1e5, 1e5]],
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
var defaultExtent = [-1e5, -1e5, 1e5, 1e5];
inherits(Voronoi2, Transform, {
  transform(_, pulse2) {
    const as = _.as || "path", data3 = pulse2.source;
    if (!data3 || !data3.length)
      return pulse2;
    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi = this.value = Delaunay.from(data3, _.x, _.y).voronoi(s);
    for (let i = 0, n = data3.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data3[i][as] = polygon ? toPathString(polygon) : null;
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function toPathString(p) {
  const x5 = p[0][0], y5 = p[0][1];
  let n = p.length - 1;
  for (; p[n][0] === x5 && p[n][1] === y5; --n)
    ;
  return "M" + p.slice(0, n + 1).join("L") + "Z";
}

// node_modules/vega-wordcloud/build/vega-wordcloud.module.js
var vega_wordcloud_module_exports = {};
__export(vega_wordcloud_module_exports, {
  wordcloud: () => Wordcloud
});
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloud() {
  var size = [256, 256], text2, font2, fontSize2, fontStyle, fontWeight, rotate2, padding2, spiral = archimedeanSpiral, words = [], random2 = Math.random, cloud2 = {};
  cloud2.layout = function() {
    var contextAndRatio = getContext2(domCanvas()), board = zeroArray((size[0] >> 5) * size[1]), bounds2 = null, n = words.length, i = -1, tags = [], data3 = words.map((d2) => ({
      text: text2(d2),
      font: font2(d2),
      style: fontStyle(d2),
      weight: fontWeight(d2),
      rotate: rotate2(d2),
      size: ~~(fontSize2(d2) + 1e-14),
      padding: padding2(d2),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d2
    })).sort((a2, b2) => b2.size - a2.size);
    while (++i < n) {
      var d = data3[i];
      d.x = size[0] * (random2() + 0.5) >> 1;
      d.y = size[1] * (random2() + 0.5) >> 1;
      cloudSprite(contextAndRatio, d, data3, i);
      if (d.hasText && place2(board, d, bounds2)) {
        tags.push(d);
        if (bounds2)
          cloudBounds(bounds2, d);
        else
          bounds2 = [{
            x: d.x + d.x0,
            y: d.y + d.y0
          }, {
            x: d.x + d.x1,
            y: d.y + d.y1
          }];
        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }
    return tags;
  };
  function getContext2(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context3 = canvas.getContext("2d");
    context3.fillStyle = context3.strokeStyle = "red";
    context3.textAlign = "center";
    return {
      context: context3,
      ratio
    };
  }
  function place2(board, tag, bounds2) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random2() < 0.5 ? 1 : -1, t = -dt, dxdy, dx, dy;
    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
        continue;
      if (!bounds2 || !cloudCollide(tag, board, size[0])) {
        if (!bounds2 || collideRects(tag, bounds2)) {
          var sprite = tag.sprite, w2 = tag.width >> 5, sw = size[0] >> 5, lx2 = tag.x - (w2 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x5 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
          for (var j = 0; j < h2; j++) {
            last = 0;
            for (var i = 0; i <= w2; i++) {
              board[x5 + i] |= last << msx | (i < w2 ? (last = sprite[j * w2 + i]) >>> sx : 0);
            }
            x5 += sw;
          }
          tag.sprite = null;
          return true;
        }
      }
    }
    return false;
  }
  cloud2.words = function(_) {
    if (arguments.length) {
      words = _;
      return cloud2;
    } else {
      return words;
    }
  };
  cloud2.size = function(_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud2;
    } else {
      return size;
    }
  };
  cloud2.font = function(_) {
    if (arguments.length) {
      font2 = functor(_);
      return cloud2;
    } else {
      return font2;
    }
  };
  cloud2.fontStyle = function(_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud2;
    } else {
      return fontStyle;
    }
  };
  cloud2.fontWeight = function(_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud2;
    } else {
      return fontWeight;
    }
  };
  cloud2.rotate = function(_) {
    if (arguments.length) {
      rotate2 = functor(_);
      return cloud2;
    } else {
      return rotate2;
    }
  };
  cloud2.text = function(_) {
    if (arguments.length) {
      text2 = functor(_);
      return cloud2;
    } else {
      return text2;
    }
  };
  cloud2.spiral = function(_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud2;
    } else {
      return spiral;
    }
  };
  cloud2.fontSize = function(_) {
    if (arguments.length) {
      fontSize2 = functor(_);
      return cloud2;
    } else {
      return fontSize2;
    }
  };
  cloud2.padding = function(_) {
    if (arguments.length) {
      padding2 = functor(_);
      return cloud2;
    } else {
      return padding2;
    }
  };
  cloud2.random = function(_) {
    if (arguments.length) {
      random2 = _;
      return cloud2;
    } else {
      return random2;
    }
  };
  return cloud2;
}
function cloudSprite(contextAndRatio, d, data3, di) {
  if (d.sprite)
    return;
  var c2 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c2.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x5 = 0, y5 = 0, maxh = 0, n = data3.length, w2, w32, h2, i, j;
  --di;
  while (++di < n) {
    d = data3[di];
    c2.save();
    c2.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    w2 = c2.measureText(d.text + "m").width * ratio;
    h2 = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr2 = Math.cos(d.rotate * cloudRadians), wcr = w2 * cr2, wsr = w2 * sr, hcr = h2 * cr2, hsr = h2 * sr;
      w2 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w2 = w2 + 31 >> 5 << 5;
    }
    if (h2 > maxh)
      maxh = h2;
    if (x5 + w2 >= cw << 5) {
      x5 = 0;
      y5 += maxh;
      maxh = 0;
    }
    if (y5 + h2 >= ch)
      break;
    c2.translate((x5 + (w2 >> 1)) / ratio, (y5 + (h2 >> 1)) / ratio);
    if (d.rotate)
      c2.rotate(d.rotate * cloudRadians);
    c2.fillText(d.text, 0, 0);
    if (d.padding) {
      c2.lineWidth = 2 * d.padding;
      c2.strokeText(d.text, 0, 0);
    }
    c2.restore();
    d.width = w2;
    d.height = h2;
    d.xoff = x5;
    d.yoff = y5;
    d.x1 = w2 >> 1;
    d.y1 = h2 >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x5 += w2;
  }
  var pixels = c2.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data3[di];
    if (!d.hasText)
      continue;
    w2 = d.width;
    w32 = w2 >> 5;
    h2 = d.y1 - d.y0;
    for (i = 0; i < h2 * w32; i++)
      sprite[i] = 0;
    x5 = d.xoff;
    if (x5 == null)
      return;
    y5 = d.yoff;
    var seen = 0, seenRow = -1;
    for (j = 0; j < h2; j++) {
      for (i = 0; i < w2; i++) {
        var k = w32 * j + (i >> 5), m2 = pixels[(y5 + j) * (cw << 5) + (x5 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m2;
        seen |= m2;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h2--;
        j--;
        y5++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w2 = tag.width >> 5, lx2 = tag.x - (w2 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x5 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
  for (var j = 0; j < h2; j++) {
    last = 0;
    for (var i = 0; i <= w2; i++) {
      if ((last << msx | (i < w2 ? (last = sprite[j * w2 + i]) >>> sx : 0)) & board[x5 + i])
        return true;
    }
    x5 += sw;
  }
  return false;
}
function cloudBounds(bounds2, d) {
  var b0 = bounds2[0], b1 = bounds2[1];
  if (d.x + d.x0 < b0.x)
    b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y)
    b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x)
    b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y)
    b1.y = d.y + d.y1;
}
function collideRects(a2, b2) {
  return a2.x + a2.x1 > b2[0].x && a2.x + a2.x0 < b2[1].x && a2.y + a2.y1 > b2[0].y && a2.y + a2.y0 < b2[1].y;
}
function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x5 = 0, y5 = 0;
  return function(t) {
    var sign3 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
      case 0:
        x5 += dx;
        break;
      case 1:
        y5 += dy;
        break;
      case 2:
        x5 -= dx;
        break;
      default:
        y5 -= dy;
        break;
    }
    return [x5, y5];
  };
}
function zeroArray(n) {
  var a2 = [], i = -1;
  while (++i < n)
    a2[i] = 0;
  return a2;
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
var Output4 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"];
var Params2 = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function Wordcloud(params2) {
  Transform.call(this, cloud(), params2);
}
Wordcloud.Definition = {
  "type": "Wordcloud",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "font",
    "type": "string",
    "expr": true,
    "default": "sans-serif"
  }, {
    "name": "fontStyle",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontWeight",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontSize",
    "type": "number",
    "expr": true,
    "default": 14
  }, {
    "name": "fontSizeRange",
    "type": "number",
    "array": "nullable",
    "default": [10, 50]
  }, {
    "name": "rotate",
    "type": "number",
    "expr": true,
    "default": 0
  }, {
    "name": "text",
    "type": "field"
  }, {
    "name": "spiral",
    "type": "string",
    "values": ["archimedean", "rectangular"]
  }, {
    "name": "padding",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 7,
    "default": Output4
  }]
};
inherits(Wordcloud, Transform, {
  transform(_, pulse2) {
    if (_.size && !(_.size[0] && _.size[1])) {
      error("Wordcloud size dimensions must be non-zero.");
    }
    function modp(param2) {
      const p = _[param2];
      return isFunction(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || Params2.some(modp)))
      return;
    const data3 = pulse2.materialize(pulse2.SOURCE).source, layout = this.value, as = _.as || Output4;
    let fontSize2 = _.fontSize || 14, range4;
    isFunction(fontSize2) ? range4 = _.fontSizeRange : fontSize2 = constant(fontSize2);
    if (range4) {
      const fsize = fontSize2, sizeScale = scale("sqrt")().domain(extent(data3, fsize)).range(range4);
      fontSize2 = (x5) => sizeScale(fsize(x5));
    }
    data3.forEach((t) => {
      t[as[0]] = NaN;
      t[as[1]] = NaN;
      t[as[3]] = 0;
    });
    const words = layout.words(data3).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || "archimedean").rotate(_.rotate || 0).font(_.font || "sans-serif").fontStyle(_.fontStyle || "normal").fontWeight(_.fontWeight || "normal").fontSize(fontSize2).random(random).layout();
    const size = layout.size(), dx = size[0] >> 1, dy = size[1] >> 1, n = words.length;
    for (let i = 0, w2, t; i < n; ++i) {
      w2 = words[i];
      t = w2.datum;
      t[as[0]] = w2.x + dx;
      t[as[1]] = w2.y + dy;
      t[as[2]] = w2.font;
      t[as[3]] = w2.size;
      t[as[4]] = w2.style;
      t[as[5]] = w2.weight;
      t[as[6]] = w2.rotate;
    }
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-crossfilter/build/vega-crossfilter.module.js
var vega_crossfilter_module_exports = {};
__export(vega_crossfilter_module_exports, {
  crossfilter: () => CrossFilter,
  resolvefilter: () => ResolveFilter
});
var array8 = (n) => new Uint8Array(n);
var array16 = (n) => new Uint16Array(n);
var array32 = (n) => new Uint32Array(n);
function Bitmaps() {
  let width2 = 8, data3 = [], seen = array32(0), curr = array2(0, width2), prev = array2(0, width2);
  return {
    data: () => data3,
    seen: () => seen = lengthen(seen, data3.length),
    add(array4) {
      for (let i = 0, j = data3.length, n = array4.length, t; i < n; ++i) {
        t = array4[i];
        t._index = j++;
        data3.push(t);
      }
    },
    remove(num, map3) {
      const n = data3.length, copy4 = Array(n - num), reindex = data3;
      let t, i, j;
      for (i = 0; !map3[i] && i < n; ++i) {
        copy4[i] = data3[i];
        reindex[i] = i;
      }
      for (j = i; i < n; ++i) {
        t = data3[i];
        if (!map3[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy4[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }
        curr[i] = 0;
      }
      data3 = copy4;
      return reindex;
    },
    size: () => data3.length,
    curr: () => curr,
    prev: () => prev,
    reset: (k) => prev[k] = curr[k],
    all: () => width2 < 257 ? 255 : width2 < 65537 ? 65535 : 4294967295,
    set(k, one5) {
      curr[k] |= one5;
    },
    clear(k, one5) {
      curr[k] &= ~one5;
    },
    resize(n, m2) {
      const k = curr.length;
      if (n > k || m2 > width2) {
        width2 = Math.max(m2, width2);
        curr = array2(n, width2, curr);
        prev = array2(n, width2);
      }
    }
  };
}
function lengthen(array4, length2, copy4) {
  if (array4.length >= length2)
    return array4;
  copy4 = copy4 || new array4.constructor(length2);
  copy4.set(array4);
  return copy4;
}
function array2(n, m2, array4) {
  const copy4 = (m2 < 257 ? array8 : m2 < 65537 ? array16 : array32)(n);
  if (array4)
    copy4.set(array4);
  return copy4;
}
function Dimension(index3, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index3.bisect,
    index: index3.index,
    size: index3.size,
    onAdd(added, curr) {
      const dim = this, range4 = dim.bisect(dim.range, added.value), idx = added.index, lo = range4[0], hi = range4[1], n1 = idx.length;
      let i2;
      for (i2 = 0; i2 < lo; ++i2)
        curr[idx[i2]] |= bit;
      for (i2 = hi; i2 < n1; ++i2)
        curr[idx[i2]] |= bit;
      return dim;
    }
  };
}
function SortedIndex() {
  let index3 = array32(0), value3 = [], size = 0;
  function insert2(key2, data3, base2) {
    if (!data3.length)
      return [];
    const n0 = size, n1 = data3.length, addi = array32(n1);
    let addv = Array(n1), oldv, oldi, i;
    for (i = 0; i < n1; ++i) {
      addv[i] = key2(data3[i]);
      addi[i] = i;
    }
    addv = sort(addv, addi);
    if (n0) {
      oldv = value3;
      oldi = index3;
      value3 = Array(n0 + n1);
      index3 = array32(n0 + n1);
      merge3(base2, oldv, oldi, n0, addv, addi, n1, value3, index3);
    } else {
      if (base2 > 0)
        for (i = 0; i < n1; ++i) {
          addi[i] += base2;
        }
      value3 = addv;
      index3 = addi;
    }
    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }
  function remove2(num, map3) {
    const n = size;
    let idx, i, j;
    for (i = 0; !map3[index3[i]] && i < n; ++i)
      ;
    for (j = i; i < n; ++i) {
      if (!map3[idx = index3[i]]) {
        index3[j] = idx;
        value3[j] = value3[i];
        ++j;
      }
    }
    size = n - num;
  }
  function reindex(map3) {
    for (let i = 0, n = size; i < n; ++i) {
      index3[i] = map3[index3[i]];
    }
  }
  function bisect2(range4, array4) {
    let n;
    if (array4) {
      n = array4.length;
    } else {
      array4 = value3;
      n = size;
    }
    return [bisectLeft(array4, range4[0], 0, n), bisectRight(array4, range4[1], 0, n)];
  }
  return {
    insert: insert2,
    remove: remove2,
    bisect: bisect2,
    reindex,
    index: () => index3,
    size: () => size
  };
}
function sort(values2, index3) {
  values2.sort.call(index3, (a2, b2) => {
    const x5 = values2[a2], y5 = values2[b2];
    return x5 < y5 ? -1 : x5 > y5 ? 1 : 0;
  });
  return permute_default(values2, index3);
}
function merge3(base2, value0, index0, n0, value1, index1, n1, value3, index3) {
  let i0 = 0, i1 = 0, i;
  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value3[i] = value0[i0];
      index3[i] = index0[i0++];
    } else {
      value3[i] = value1[i1];
      index3[i] = index1[i1++] + base2;
    }
  }
  for (; i0 < n0; ++i0, ++i) {
    value3[i] = value0[i0];
    index3[i] = index0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    value3[i] = value1[i1];
    index3[i] = index1[i1] + base2;
  }
}
function CrossFilter(params2) {
  Transform.call(this, Bitmaps(), params2);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  "type": "CrossFilter",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "query",
    "type": "array",
    "array": true,
    "required": true,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }]
};
inherits(CrossFilter, Transform, {
  transform(_, pulse2) {
    if (!this._dims) {
      return this.init(_, pulse2);
    } else {
      var init2 = _.modified("fields") || _.fields.some((f) => pulse2.modified(f.fields));
      return init2 ? this.reinit(_, pulse2) : this.eval(_, pulse2);
    }
  },
  init(_, pulse2) {
    const fields = _.fields, query = _.query, indices = this._indices = {}, dims = this._dims = [], m2 = query.length;
    let i = 0, key2, index3;
    for (; i < m2; ++i) {
      key2 = fields[i].fname;
      index3 = indices[key2] || (indices[key2] = SortedIndex());
      dims.push(Dimension(index3, i, query[i]));
    }
    return this.eval(_, pulse2);
  },
  reinit(_, pulse2) {
    const output3 = pulse2.materialize().fork(), fields = _.fields, query = _.query, indices = this._indices, dims = this._dims, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), out = output3.rem = output3.add, mod = output3.mod, m2 = query.length, adds = {};
    let add5, index3, key2, mods, remMap, modMap, i, n, f;
    prev.set(curr);
    if (pulse2.rem.length) {
      remMap = this.remove(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      bits.add(pulse2.add);
    }
    if (pulse2.mod.length) {
      modMap = {};
      for (mods = pulse2.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    }
    for (i = 0; i < m2; ++i) {
      f = fields[i];
      if (!dims[i] || _.modified("fields", i) || pulse2.modified(f.fields)) {
        key2 = f.fname;
        if (!(add5 = adds[key2])) {
          indices[key2] = index3 = SortedIndex();
          adds[key2] = add5 = index3.insert(f, pulse2.source, 0);
        }
        dims[i] = Dimension(index3, i, query[i]).onAdd(add5, curr);
      }
    }
    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        continue;
      } else if (prev[i] !== curr[i]) {
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        mod.push(i);
      }
    }
    bits.mask = (1 << m2) - 1;
    return output3;
  },
  eval(_, pulse2) {
    const output3 = pulse2.materialize().fork(), m2 = this._dims.length;
    let mask = 0;
    if (pulse2.rem.length) {
      this.remove(_, pulse2, output3);
      mask |= (1 << m2) - 1;
    }
    if (_.modified("query") && !_.modified("fields")) {
      mask |= this.update(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      this.insert(_, pulse2, output3);
      mask |= (1 << m2) - 1;
    }
    if (pulse2.mod.length) {
      this.modify(pulse2, output3);
      mask |= (1 << m2) - 1;
    }
    this.value.mask = mask;
    return output3;
  },
  insert(_, pulse2, output3) {
    const tuples = pulse2.add, bits = this.value, dims = this._dims, indices = this._indices, fields = _.fields, adds = {}, out = output3.add, n = bits.size() + tuples.length, m2 = dims.length;
    let k = bits.size(), j, key2, add5;
    bits.resize(n, m2);
    bits.add(tuples);
    const curr = bits.curr(), prev = bits.prev(), all = bits.all();
    for (j = 0; j < m2; ++j) {
      key2 = fields[j].fname;
      add5 = adds[key2] || (adds[key2] = indices[key2].insert(fields[j], tuples, k));
      dims[j].onAdd(add5, curr);
    }
    for (; k < n; ++k) {
      prev[k] = all;
      if (curr[k] !== all)
        out.push(k);
    }
  },
  modify(pulse2, output3) {
    const out = output3.mod, bits = this.value, curr = bits.curr(), all = bits.all(), tuples = pulse2.mod;
    let i, n, k;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      if (curr[k] !== all)
        out.push(k);
    }
  },
  remove(_, pulse2, output3) {
    const indices = this._indices, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), map3 = {}, out = output3.rem, tuples = pulse2.rem;
    let i, n, k, f;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      map3[k] = 1;
      prev[k] = f = curr[k];
      curr[k] = all;
      if (f !== all)
        out.push(k);
    }
    for (k in indices) {
      indices[k].remove(n, map3);
    }
    this.reindex(pulse2, n, map3);
    return map3;
  },
  reindex(pulse2, num, map3) {
    const indices = this._indices, bits = this.value;
    pulse2.runAfter(() => {
      const indexMap = bits.remove(num, map3);
      for (const key2 in indices)
        indices[key2].reindex(indexMap);
    });
  },
  update(_, pulse2, output3) {
    const dims = this._dims, query = _.query, stamp = pulse2.stamp, m2 = dims.length;
    let mask = 0, i, q;
    output3.filters = 0;
    for (q = 0; q < m2; ++q) {
      if (_.modified("query", q)) {
        i = q;
        ++mask;
      }
    }
    if (mask === 1) {
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output3.add, output3.rem);
    } else {
      for (q = 0, mask = 0; q < m2; ++q) {
        if (!_.modified("query", q))
          continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output3.add);
        output3.rem = output3.add;
      }
    }
    return mask;
  },
  incrementAll(dim, query, stamp, out) {
    const bits = this.value, seen = bits.seen(), curr = bits.curr(), prev = bits.prev(), index3 = dim.index(), old = dim.bisect(dim.range), range4 = dim.bisect(query), lo1 = range4[0], hi1 = range4[1], lo0 = old[0], hi0 = old[1], one5 = dim.one;
    let i, j, k;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index3[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one5;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index3[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one5;
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index3[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one5;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index3[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one5;
      }
    }
    dim.range = query.slice();
  },
  incrementOne(dim, query, add5, rem2) {
    const bits = this.value, curr = bits.curr(), index3 = dim.index(), old = dim.bisect(dim.range), range4 = dim.bisect(query), lo1 = range4[0], hi1 = range4[1], lo0 = old[0], hi0 = old[1], one5 = dim.one;
    let i, j, k;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index3[i];
        curr[k] ^= one5;
        add5.push(k);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index3[i];
        curr[k] ^= one5;
        rem2.push(k);
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index3[i];
        curr[k] ^= one5;
        add5.push(k);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index3[i];
        curr[k] ^= one5;
        rem2.push(k);
      }
    }
    dim.range = query.slice();
  }
});
function ResolveFilter(params2) {
  Transform.call(this, null, params2);
}
ResolveFilter.Definition = {
  "type": "ResolveFilter",
  "metadata": {},
  "params": [{
    "name": "ignore",
    "type": "number",
    "required": true,
    "description": "A bit mask indicating which filters to ignore."
  }, {
    "name": "filter",
    "type": "object",
    "required": true,
    "description": "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
inherits(ResolveFilter, Transform, {
  transform(_, pulse2) {
    const ignore = ~(_.ignore || 0), bitmap = _.filter, mask = bitmap.mask;
    if ((mask & ignore) === 0)
      return pulse2.StopPropagation;
    const output3 = pulse2.fork(pulse2.ALL), data3 = bitmap.data(), curr = bitmap.curr(), prev = bitmap.prev(), pass = (k) => !(curr[k] & ignore) ? data3[k] : null;
    output3.filter(output3.MOD, pass);
    if (!(mask & mask - 1)) {
      output3.filter(output3.ADD, pass);
      output3.filter(output3.REM, (k) => (curr[k] & ignore) === mask ? data3[k] : null);
    } else {
      output3.filter(output3.ADD, (k) => {
        const c2 = curr[k] & ignore, f = !c2 && c2 ^ prev[k] & ignore;
        return f ? data3[k] : null;
      });
      output3.filter(output3.REM, (k) => {
        const c2 = curr[k] & ignore, f = c2 && !(c2 ^ (c2 ^ prev[k] & ignore));
        return f ? data3[k] : null;
      });
    }
    return output3.filter(output3.SOURCE, (t) => pass(t._index));
  }
});

// node_modules/vega-expression/build/vega-expression.module.js
var RawCode = "RawCode";
var Literal = "Literal";
var Property = "Property";
var Identifier2 = "Identifier";
var ArrayExpression = "ArrayExpression";
var BinaryExpression = "BinaryExpression";
var CallExpression = "CallExpression";
var ConditionalExpression = "ConditionalExpression";
var LogicalExpression = "LogicalExpression";
var MemberExpression = "MemberExpression";
var ObjectExpression = "ObjectExpression";
var UnaryExpression = "UnaryExpression";
function ASTNode(type2) {
  this.type = type2;
}
ASTNode.prototype.visit = function(visitor) {
  let c2, i, n;
  if (visitor(this))
    return 1;
  for (c2 = children2(this), i = 0, n = c2.length; i < n; ++i) {
    if (c2[i].visit(visitor))
      return 1;
  }
};
function children2(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];
    case CallExpression:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression:
      return [node.object, node.property];
    case ObjectExpression:
      return node.properties;
    case Property:
      return [node.key, node.value];
    case UnaryExpression:
      return [node.argument];
    case Identifier2:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}
var TokenName;
var source2;
var index2;
var length;
var lookahead;
var TokenBooleanLiteral = 1;
var TokenEOF = 2;
var TokenIdentifier = 3;
var TokenKeyword = 4;
var TokenNullLiteral = 5;
var TokenNumericLiteral = 6;
var TokenPunctuator = 7;
var TokenStringLiteral = 8;
var TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = "Boolean";
TokenName[TokenEOF] = "<end>";
TokenName[TokenIdentifier] = "Identifier";
TokenName[TokenKeyword] = "Keyword";
TokenName[TokenNullLiteral] = "Null";
TokenName[TokenNumericLiteral] = "Numeric";
TokenName[TokenPunctuator] = "Punctuator";
TokenName[TokenStringLiteral] = "String";
TokenName[TokenRegularExpression] = "RegularExpression";
var SyntaxArrayExpression = "ArrayExpression";
var SyntaxBinaryExpression = "BinaryExpression";
var SyntaxCallExpression = "CallExpression";
var SyntaxConditionalExpression = "ConditionalExpression";
var SyntaxIdentifier = "Identifier";
var SyntaxLiteral = "Literal";
var SyntaxLogicalExpression = "LogicalExpression";
var SyntaxMemberExpression = "MemberExpression";
var SyntaxObjectExpression = "ObjectExpression";
var SyntaxProperty = "Property";
var SyntaxUnaryExpression = "UnaryExpression";
var MessageUnexpectedToken = "Unexpected token %0";
var MessageUnexpectedNumber = "Unexpected number";
var MessageUnexpectedString = "Unexpected string";
var MessageUnexpectedIdentifier = "Unexpected identifier";
var MessageUnexpectedReserved = "Unexpected reserved word";
var MessageUnexpectedEOS = "Unexpected end of input";
var MessageInvalidRegExp = "Invalid regular expression";
var MessageUnterminatedRegExp = "Invalid regular expression: missing /";
var MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.";
var MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL = "ILLEGAL";
var DISABLED = "Disabled.";
var RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
var RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch2));
}
function isIdentifierPart(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 >= 48 && ch2 <= 57 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch2));
}
var keywords = {
  "if": 1,
  "in": 1,
  "do": 1,
  "var": 1,
  "for": 1,
  "new": 1,
  "try": 1,
  "let": 1,
  "this": 1,
  "else": 1,
  "case": 1,
  "void": 1,
  "with": 1,
  "enum": 1,
  "while": 1,
  "break": 1,
  "catch": 1,
  "throw": 1,
  "const": 1,
  "yield": 1,
  "class": 1,
  "super": 1,
  "return": 1,
  "typeof": 1,
  "delete": 1,
  "switch": 1,
  "export": 1,
  "import": 1,
  "public": 1,
  "static": 1,
  "default": 1,
  "finally": 1,
  "extends": 1,
  "package": 1,
  "private": 1,
  "function": 1,
  "continue": 1,
  "debugger": 1,
  "interface": 1,
  "protected": 1,
  "instanceof": 1,
  "implements": 1
};
function skipComment() {
  while (index2 < length) {
    const ch2 = source2.charCodeAt(index2);
    if (isWhiteSpace(ch2) || isLineTerminator(ch2)) {
      ++index2;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index2 < length && isHexDigit(source2[index2])) {
      ch2 = source2[index2++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch2, code, cu1, cu2;
  ch2 = source2[index2];
  code = 0;
  if (ch2 === "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  while (index2 < length) {
    ch2 = source2[index2++];
    if (!isHexDigit(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch2, id2;
  ch2 = source2.charCodeAt(index2++);
  id2 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source2.charCodeAt(index2) !== 117) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    ++index2;
    ch2 = scanHexEscape("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart(ch2.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    id2 = ch2;
  }
  while (index2 < length) {
    ch2 = source2.charCodeAt(index2);
    if (!isIdentifierPart(ch2)) {
      break;
    }
    ++index2;
    id2 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id2 = id2.substr(0, id2.length - 1);
      if (source2.charCodeAt(index2) !== 117) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      ++index2;
      ch2 = scanHexEscape("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      id2 += ch2;
    }
  }
  return id2;
}
function getIdentifier() {
  var start, ch2;
  start = index2++;
  while (index2 < length) {
    ch2 = source2.charCodeAt(index2);
    if (ch2 === 92) {
      index2 = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch2)) {
      ++index2;
    } else {
      break;
    }
  }
  return source2.slice(start, index2);
}
function scanIdentifier() {
  var start, id2, type2;
  start = index2;
  id2 = source2.charCodeAt(index2) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id2.length === 1) {
    type2 = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id2)) {
    type2 = TokenKeyword;
  } else if (id2 === "null") {
    type2 = TokenNullLiteral;
  } else if (id2 === "true" || id2 === "false") {
    type2 = TokenBooleanLiteral;
  } else {
    type2 = TokenIdentifier;
  }
  return {
    type: type2,
    value: id2,
    start,
    end: index2
  };
}
function scanPunctuator() {
  var start = index2, code = source2.charCodeAt(index2), code2, ch1 = source2[index2], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index2;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start,
        end: index2
      };
    default:
      code2 = source2.charCodeAt(index2 + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index2 += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index2
            };
          case 33:
          case 61:
            index2 += 2;
            if (source2.charCodeAt(index2) === 61) {
              ++index2;
            }
            return {
              type: TokenPunctuator,
              value: source2.slice(start, index2),
              start,
              end: index2
            };
        }
      }
  }
  ch4 = source2.substr(index2, 4);
  if (ch4 === ">>>=") {
    index2 += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start,
      end: index2
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index2 += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start,
      end: index2
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index2 += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start,
      end: index2
    };
  }
  if (ch2 === "//") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index2;
    return {
      type: TokenPunctuator,
      value: ch1,
      start,
      end: index2
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL);
}
function scanHexLiteral(start) {
  let number7 = "";
  while (index2 < length) {
    if (!isHexDigit(source2[index2])) {
      break;
    }
    number7 += source2[index2++];
  }
  if (number7.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (isIdentifierStart(source2.charCodeAt(index2))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt("0x" + number7, 16),
    start,
    end: index2
  };
}
function scanOctalLiteral(start) {
  let number7 = "0" + source2[index2++];
  while (index2 < length) {
    if (!isOctalDigit(source2[index2])) {
      break;
    }
    number7 += source2[index2++];
  }
  if (isIdentifierStart(source2.charCodeAt(index2)) || isDecimalDigit(source2.charCodeAt(index2))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number7, 8),
    octal: true,
    start,
    end: index2
  };
}
function scanNumericLiteral() {
  var number7, start, ch2;
  ch2 = source2[index2];
  assert(isDecimalDigit(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index2;
  number7 = "";
  if (ch2 !== ".") {
    number7 = source2[index2++];
    ch2 = source2[index2];
    if (number7 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index2;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch2)) {
        return scanOctalLiteral(start);
      }
      if (ch2 && isDecimalDigit(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }
    while (isDecimalDigit(source2.charCodeAt(index2))) {
      number7 += source2[index2++];
    }
    ch2 = source2[index2];
  }
  if (ch2 === ".") {
    number7 += source2[index2++];
    while (isDecimalDigit(source2.charCodeAt(index2))) {
      number7 += source2[index2++];
    }
    ch2 = source2[index2];
  }
  if (ch2 === "e" || ch2 === "E") {
    number7 += source2[index2++];
    ch2 = source2[index2];
    if (ch2 === "+" || ch2 === "-") {
      number7 += source2[index2++];
    }
    if (isDecimalDigit(source2.charCodeAt(index2))) {
      while (isDecimalDigit(source2.charCodeAt(index2))) {
        number7 += source2[index2++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  if (isIdentifierStart(source2.charCodeAt(index2))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number7),
    start,
    end: index2
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source2[index2];
  assert(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index2;
  ++index2;
  while (index2 < length) {
    ch2 = source2[index2++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source2[index2++];
      if (!ch2 || !isLineTerminator(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source2[index2] === "{") {
              ++index2;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index2 < length && isOctalDigit(source2[index2])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source2[index2++]);
                if ("0123".indexOf(ch2) >= 0 && index2 < length && isOctalDigit(source2[index2])) {
                  code = code * 8 + "01234567".indexOf(source2[index2++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source2[index2] === "\n") {
          ++index2;
        }
      }
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal,
    start,
    end: index2
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e) {
    throwError({}, MessageInvalidRegExp);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source2[index2];
  assert(ch2 === "/", "Regular expression literal must start with a slash");
  str = source2[index2++];
  classMarker = false;
  terminated = false;
  while (index2 < length) {
    ch2 = source2[index2++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source2[index2++];
      if (isLineTerminator(ch2.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch2;
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index2 < length) {
    ch2 = source2[index2];
    if (!isIdentifierPart(ch2.charCodeAt(0))) {
      break;
    }
    ++index2;
    if (ch2 === "\\" && index2 < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value3;
  lookahead = null;
  skipComment();
  start = index2;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value3 = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value3,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index2
  };
}
function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index2 >= length) {
    return {
      type: TokenEOF,
      start: index2,
      end: index2
    };
  }
  const ch2 = source2.charCodeAt(index2);
  if (isIdentifierStart(ch2)) {
    return scanIdentifier();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral();
  }
  if (ch2 === 46) {
    if (isDecimalDigit(source2.charCodeAt(index2 + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch2)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token = lookahead;
  index2 = token.end;
  lookahead = advance();
  index2 = token.end;
  return token;
}
function peek2() {
  const pos = index2;
  lookahead = advance();
  index2 = pos;
}
function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}
function finishBinaryExpression(operator2, left, right) {
  const node = new ASTNode(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression(test2, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier(name2) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name2;
  return node;
}
function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source2.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression(accessor2, object2, property2) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor2 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed)
    property2.member = true;
  return node;
}
function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}
function finishProperty(kind, key2, value3) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key2;
  node.value = value3;
  node.kind = kind;
  return node;
}
function finishUnaryExpression(operator2, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError(token, messageFormat) {
  var error2, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index3) => {
    assert(index3 < args.length, "Message reference must be in range");
    return args[index3];
  });
  error2 = new Error(msg);
  error2.index = index2;
  error2.description = msg;
  throw error2;
}
function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }
  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }
  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }
  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }
  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  }
  throwError(token, MessageUnexpectedToken, token.value);
}
function expect(value3) {
  const token = lex();
  if (token.type !== TokenPunctuator || token.value !== value3) {
    throwUnexpected(token);
  }
}
function match(value3) {
  return lookahead.type === TokenPunctuator && lookahead.value === value3;
}
function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}
function parseArrayInitialiser() {
  const elements = [];
  index2 = lookahead.start;
  expect("[");
  while (!match("]")) {
    if (match(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match("]")) {
        expect(",");
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}
function parseObjectPropertyKey() {
  index2 = lookahead.start;
  const token = lex();
  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }
    return finishLiteral(token);
  }
  return finishIdentifier(token.value);
}
function parseObjectProperty() {
  var token, key2, id2, value3;
  index2 = lookahead.start;
  token = lookahead;
  if (token.type === TokenIdentifier) {
    id2 = parseObjectPropertyKey();
    expect(":");
    value3 = parseConditionalExpression();
    return finishProperty("init", id2, value3);
  }
  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key2 = parseObjectPropertyKey();
    expect(":");
    value3 = parseConditionalExpression();
    return finishProperty("init", key2, value3);
  }
}
function parseObjectInitialiser() {
  var properties = [], property2, name2, key2, map3 = {}, toString2 = String;
  index2 = lookahead.start;
  expect("{");
  while (!match("}")) {
    property2 = parseObjectProperty();
    if (property2.key.type === SyntaxIdentifier) {
      name2 = property2.key.name;
    } else {
      name2 = toString2(property2.key.value);
    }
    key2 = "$" + name2;
    if (Object.prototype.hasOwnProperty.call(map3, key2)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map3[key2] = true;
    }
    properties.push(property2);
    if (!match("}")) {
      expect(",");
    }
  }
  expect("}");
  return finishObjectExpression(properties);
}
function parseGroupExpression() {
  expect("(");
  const expr2 = parseExpression();
  expect(")");
  return expr2;
}
var legalKeywords = {
  "if": 1
};
function parsePrimaryExpression() {
  var type2, token, expr2;
  if (match("(")) {
    return parseGroupExpression();
  }
  if (match("[")) {
    return parseArrayInitialiser();
  }
  if (match("{")) {
    return parseObjectInitialiser();
  }
  type2 = lookahead.type;
  index2 = lookahead.start;
  if (type2 === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr2 = finishIdentifier(lex().value);
  } else if (type2 === TokenStringLiteral || type2 === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr2 = finishLiteral(lex());
  } else if (type2 === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type2 === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === "true";
    expr2 = finishLiteral(token);
  } else if (type2 === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr2 = finishLiteral(token);
  } else if (match("/") || match("/=")) {
    expr2 = finishLiteral(scanRegExp());
    peek2();
  } else {
    throwUnexpected(lex());
  }
  return expr2;
}
function parseArguments() {
  const args = [];
  expect("(");
  if (!match(")")) {
    while (index2 < length) {
      args.push(parseConditionalExpression());
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  index2 = lookahead.start;
  const token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return finishIdentifier(token.value);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect("[");
  const expr2 = parseExpression();
  expect("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression();
  for (; ; ) {
    if (match(".")) {
      property2 = parseNonComputedMember();
      expr2 = finishMemberExpression(".", expr2, property2);
    } else if (match("(")) {
      args = parseArguments();
      expr2 = finishCallExpression(expr2, args);
    } else if (match("[")) {
      property2 = parseComputedMember();
      expr2 = finishMemberExpression("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression() {
  const expr2 = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match("++") || match("--")) {
      throw new Error(DISABLED);
    }
  }
  return expr2;
}
function parseUnaryExpression() {
  var token, expr2;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr2 = parsePostfixExpression();
  } else if (match("++") || match("--")) {
    throw new Error(DISABLED);
  } else if (match("+") || match("-") || match("~") || match("!")) {
    token = lex();
    expr2 = parseUnaryExpression();
    expr2 = finishUnaryExpression(token.value, expr2);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    throw new Error(DISABLED);
  } else {
    expr2 = parsePostfixExpression();
  }
  return expr2;
}
function binaryPrecedence(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr2, token, prec, stack, right, operator2, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack = [left, token, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
      right = stack.pop();
      operator2 = stack.pop().value;
      left = stack.pop();
      markers.pop();
      expr2 = finishBinaryExpression(operator2, left, right);
      stack.push(expr2);
    }
    token = lex();
    token.prec = prec;
    stack.push(token);
    markers.push(lookahead);
    expr2 = parseUnaryExpression();
    stack.push(expr2);
  }
  i = stack.length - 1;
  expr2 = stack[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression();
  if (match("?")) {
    lex();
    consequent = parseConditionalExpression();
    expect(":");
    alternate = parseConditionalExpression();
    expr2 = finishConditionalExpression(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression() {
  const expr2 = parseConditionalExpression();
  if (match(",")) {
    throw new Error(DISABLED);
  }
  return expr2;
}
function parser(code) {
  source2 = code;
  index2 = 0;
  length = source2.length;
  lookahead = null;
  peek2();
  const expr2 = parseExpression();
  if (lookahead.type !== TokenEOF) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
var Constants = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function Functions(codegen2) {
  function fncall(name2, args, cast, type2) {
    let obj = codegen2(args[0]);
    if (cast) {
      obj = cast + "(" + obj + ")";
      if (cast.lastIndexOf("new ", 0) === 0)
        obj = "(" + obj + ")";
    }
    return obj + "." + name2 + (type2 < 0 ? "" : type2 === 0 ? "()" : "(" + args.slice(1).map(codegen2).join(",") + ")");
  }
  function fn(name2, cast, type2) {
    return (args) => fncall(name2, args, cast, type2);
  }
  const DATE2 = "new Date", STRING = "String", REGEXP = "RegExp";
  return {
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(args) {
      if (args.length < 3)
        error("Missing arguments to clamp function.");
      if (args.length > 3)
        error("Too many arguments to clamp function.");
      const a2 = args.map(codegen2);
      return "Math.max(" + a2[1] + ", Math.min(" + a2[2] + "," + a2[0] + "))";
    },
    now: "Date.now",
    utc: "Date.UTC",
    datetime: DATE2,
    date: fn("getDate", DATE2, 0),
    day: fn("getDay", DATE2, 0),
    year: fn("getFullYear", DATE2, 0),
    month: fn("getMonth", DATE2, 0),
    hours: fn("getHours", DATE2, 0),
    minutes: fn("getMinutes", DATE2, 0),
    seconds: fn("getSeconds", DATE2, 0),
    milliseconds: fn("getMilliseconds", DATE2, 0),
    time: fn("getTime", DATE2, 0),
    timezoneoffset: fn("getTimezoneOffset", DATE2, 0),
    utcdate: fn("getUTCDate", DATE2, 0),
    utcday: fn("getUTCDay", DATE2, 0),
    utcyear: fn("getUTCFullYear", DATE2, 0),
    utcmonth: fn("getUTCMonth", DATE2, 0),
    utchours: fn("getUTCHours", DATE2, 0),
    utcminutes: fn("getUTCMinutes", DATE2, 0),
    utcseconds: fn("getUTCSeconds", DATE2, 0),
    utcmilliseconds: fn("getUTCMilliseconds", DATE2, 0),
    length: fn("length", null, -1),
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: fn("toUpperCase", STRING, 0),
    lower: fn("toLowerCase", STRING, 0),
    substring: fn("substring", STRING),
    split: fn("split", STRING),
    trim: fn("trim", STRING, 0),
    regexp: REGEXP,
    test: fn("test", REGEXP),
    if: function(args) {
      if (args.length < 3)
        error("Missing arguments to if function.");
      if (args.length > 3)
        error("Too many arguments to if function.");
      const a2 = args.map(codegen2);
      return "(" + a2[0] + "?" + a2[1] + ":" + a2[2] + ")";
    }
  };
}
function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === "'" && s[n] === "'") ? s.slice(1, -1) : s;
}
function codegen(opt) {
  opt = opt || {};
  const allowed = opt.allowed ? toSet(opt.allowed) : {}, forbidden = opt.forbidden ? toSet(opt.forbidden) : {}, constants2 = opt.constants || Constants, functions = (opt.functions || Functions)(visit2), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction(globalvar) ? globalvar : (id2) => "".concat(globalvar, '["').concat(id2, '"]');
  let globals = {}, fields = {}, memberDepth = 0;
  function visit2(ast) {
    if (isString(ast))
      return ast;
    const generator = Generators[ast.type];
    if (generator == null)
      error("Unsupported type: " + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: (n) => n.raw,
    Identifier: (n) => {
      const id2 = n.name;
      if (memberDepth > 0) {
        return id2;
      } else if (has(forbidden, id2)) {
        return error("Illegal identifier: " + id2);
      } else if (has(constants2, id2)) {
        return constants2[id2];
      } else if (has(allowed, id2)) {
        return id2;
      } else {
        globals[id2] = 1;
        return outputGlobal(id2);
      }
    },
    MemberExpression: (n) => {
      const d = !n.computed, o = visit2(n.object);
      if (d)
        memberDepth += 1;
      const p = visit2(n.property);
      if (o === fieldvar) {
        fields[stripQuotes(p)] = 1;
      }
      if (d)
        memberDepth -= 1;
      return o + (d ? "." + p : "[" + p + "]");
    },
    CallExpression: (n) => {
      if (n.callee.type !== "Identifier") {
        error("Illegal callee type: " + n.callee.type);
      }
      const callee = n.callee.name, args = n.arguments, fn = has(functions, callee) && functions[callee];
      if (!fn)
        error("Unrecognized function: " + callee);
      return isFunction(fn) ? fn(args) : fn + "(" + args.map(visit2).join(",") + ")";
    },
    ArrayExpression: (n) => "[" + n.elements.map(visit2).join(",") + "]",
    BinaryExpression: (n) => "(" + visit2(n.left) + " " + n.operator + " " + visit2(n.right) + ")",
    UnaryExpression: (n) => "(" + n.operator + visit2(n.argument) + ")",
    ConditionalExpression: (n) => "(" + visit2(n.test) + "?" + visit2(n.consequent) + ":" + visit2(n.alternate) + ")",
    LogicalExpression: (n) => "(" + visit2(n.left) + n.operator + visit2(n.right) + ")",
    ObjectExpression: (n) => "{" + n.properties.map(visit2).join(",") + "}",
    Property: (n) => {
      memberDepth += 1;
      const k = visit2(n.key);
      memberDepth -= 1;
      return k + ":" + visit2(n.value);
    }
  };
  function codegen2(ast) {
    const result = {
      code: visit2(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen2.functions = functions;
  codegen2.constants = constants2;
  return codegen2;
}

// node_modules/vega-functions/node_modules/d3-color/src/define.js
function define_default4(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend5(parent, definition3) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition3)
    prototype2[key2] = definition3[key2];
  return prototype2;
}

// node_modules/vega-functions/node_modules/d3-color/src/color.js
function Color4() {
}
var darker4 = 0.7;
var brighter4 = 1 / darker4;
var reI4 = "\\s*([+-]?\\d+)\\s*";
var reN4 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP4 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex4 = /^#([0-9a-f]{3,8})$/;
var reRgbInteger4 = new RegExp("^rgb\\(" + [reI4, reI4, reI4] + "\\)$");
var reRgbPercent4 = new RegExp("^rgb\\(" + [reP4, reP4, reP4] + "\\)$");
var reRgbaInteger4 = new RegExp("^rgba\\(" + [reI4, reI4, reI4, reN4] + "\\)$");
var reRgbaPercent4 = new RegExp("^rgba\\(" + [reP4, reP4, reP4, reN4] + "\\)$");
var reHslPercent4 = new RegExp("^hsl\\(" + [reN4, reP4, reP4] + "\\)$");
var reHslaPercent4 = new RegExp("^hsla\\(" + [reN4, reP4, reP4, reN4] + "\\)$");
var named4 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default4(Color4, color5, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex4,
  formatHex: color_formatHex4,
  formatHsl: color_formatHsl4,
  formatRgb: color_formatRgb4,
  toString: color_formatRgb4
});
function color_formatHex4() {
  return this.rgb().formatHex();
}
function color_formatHsl4() {
  return hslConvert4(this).formatHsl();
}
function color_formatRgb4() {
  return this.rgb().formatRgb();
}
function color5(format5) {
  var m2, l;
  format5 = (format5 + "").trim().toLowerCase();
  return (m2 = reHex4.exec(format5)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn4(m2) : l === 3 ? new Rgb4(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba4(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba4(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger4.exec(format5)) ? new Rgb4(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent4.exec(format5)) ? new Rgb4(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger4.exec(format5)) ? rgba4(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent4.exec(format5)) ? rgba4(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent4.exec(format5)) ? hsla4(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent4.exec(format5)) ? hsla4(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named4.hasOwnProperty(format5) ? rgbn4(named4[format5]) : format5 === "transparent" ? new Rgb4(NaN, NaN, NaN, 0) : null;
}
function rgbn4(n) {
  return new Rgb4(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba4(r, g, b2, a2) {
  if (a2 <= 0)
    r = g = b2 = NaN;
  return new Rgb4(r, g, b2, a2);
}
function rgbConvert4(o) {
  if (!(o instanceof Color4))
    o = color5(o);
  if (!o)
    return new Rgb4();
  o = o.rgb();
  return new Rgb4(o.r, o.g, o.b, o.opacity);
}
function rgb4(r, g, b2, opacity) {
  return arguments.length === 1 ? rgbConvert4(r) : new Rgb4(r, g, b2, opacity == null ? 1 : opacity);
}
function Rgb4(r, g, b2, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default4(Rgb4, rgb4, extend5(Color4, {
  brighter: function(k) {
    k = k == null ? brighter4 : Math.pow(brighter4, k);
    return new Rgb4(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker4 : Math.pow(darker4, k);
    return new Rgb4(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex4,
  formatHex: rgb_formatHex4,
  formatRgb: rgb_formatRgb4,
  toString: rgb_formatRgb4
}));
function rgb_formatHex4() {
  return "#" + hex4(this.r) + hex4(this.g) + hex4(this.b);
}
function rgb_formatRgb4() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex4(value3) {
  value3 = Math.max(0, Math.min(255, Math.round(value3) || 0));
  return (value3 < 16 ? "0" : "") + value3.toString(16);
}
function hsla4(h2, s, l, a2) {
  if (a2 <= 0)
    h2 = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s = NaN;
  else if (s <= 0)
    h2 = NaN;
  return new Hsl4(h2, s, l, a2);
}
function hslConvert4(o) {
  if (o instanceof Hsl4)
    return new Hsl4(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color4))
    o = color5(o);
  if (!o)
    return new Hsl4();
  if (o instanceof Hsl4)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b2 = o.b / 255, min4 = Math.min(r, g, b2), max4 = Math.max(r, g, b2), h2 = NaN, s = max4 - min4, l = (max4 + min4) / 2;
  if (s) {
    if (r === max4)
      h2 = (g - b2) / s + (g < b2) * 6;
    else if (g === max4)
      h2 = (b2 - r) / s + 2;
    else
      h2 = (r - g) / s + 4;
    s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl4(h2, s, l, o.opacity);
}
function hsl5(h2, s, l, opacity) {
  return arguments.length === 1 ? hslConvert4(h2) : new Hsl4(h2, s, l, opacity == null ? 1 : opacity);
}
function Hsl4(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default4(Hsl4, hsl5, extend5(Color4, {
  brighter: function(k) {
    k = k == null ? brighter4 : Math.pow(brighter4, k);
    return new Hsl4(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker4 : Math.pow(darker4, k);
    return new Hsl4(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb4(hsl2rgb4(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb4(h2, m1, m2), hsl2rgb4(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb4(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/vega-functions/node_modules/d3-color/src/math.js
var radians4 = Math.PI / 180;
var degrees5 = 180 / Math.PI;

// node_modules/vega-functions/node_modules/d3-color/src/lab.js
var K2 = 18;
var Xn2 = 0.96422;
var Yn2 = 1;
var Zn2 = 0.82521;
var t04 = 4 / 29;
var t13 = 6 / 29;
var t22 = 3 * t13 * t13;
var t32 = t13 * t13 * t13;
function labConvert2(o) {
  if (o instanceof Lab2)
    return new Lab2(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl2)
    return hcl2lab2(o);
  if (!(o instanceof Rgb4))
    o = rgbConvert4(o);
  var r = rgb2lrgb2(o.r), g = rgb2lrgb2(o.g), b2 = rgb2lrgb2(o.b), y5 = xyz2lab2((0.2225045 * r + 0.7168786 * g + 0.0606169 * b2) / Yn2), x5, z;
  if (r === g && g === b2)
    x5 = z = y5;
  else {
    x5 = xyz2lab2((0.4360747 * r + 0.3850649 * g + 0.1430804 * b2) / Xn2);
    z = xyz2lab2((0.0139322 * r + 0.0971045 * g + 0.7141733 * b2) / Zn2);
  }
  return new Lab2(116 * y5 - 16, 500 * (x5 - y5), 200 * (y5 - z), o.opacity);
}
function lab3(l, a2, b2, opacity) {
  return arguments.length === 1 ? labConvert2(l) : new Lab2(l, a2, b2, opacity == null ? 1 : opacity);
}
function Lab2(l, a2, b2, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default4(Lab2, lab3, extend5(Color4, {
  brighter: function(k) {
    return new Lab2(this.l + K2 * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab2(this.l - K2 * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y5 = (this.l + 16) / 116, x5 = isNaN(this.a) ? y5 : y5 + this.a / 500, z = isNaN(this.b) ? y5 : y5 - this.b / 200;
    x5 = Xn2 * lab2xyz2(x5);
    y5 = Yn2 * lab2xyz2(y5);
    z = Zn2 * lab2xyz2(z);
    return new Rgb4(lrgb2rgb2(3.1338561 * x5 - 1.6168667 * y5 - 0.4906146 * z), lrgb2rgb2(-0.9787684 * x5 + 1.9161415 * y5 + 0.033454 * z), lrgb2rgb2(0.0719453 * x5 - 0.2289914 * y5 + 1.4052427 * z), this.opacity);
  }
}));
function xyz2lab2(t) {
  return t > t32 ? Math.pow(t, 1 / 3) : t / t22 + t04;
}
function lab2xyz2(t) {
  return t > t13 ? t * t * t : t22 * (t - t04);
}
function lrgb2rgb2(x5) {
  return 255 * (x5 <= 31308e-7 ? 12.92 * x5 : 1.055 * Math.pow(x5, 1 / 2.4) - 0.055);
}
function rgb2lrgb2(x5) {
  return (x5 /= 255) <= 0.04045 ? x5 / 12.92 : Math.pow((x5 + 0.055) / 1.055, 2.4);
}
function hclConvert2(o) {
  if (o instanceof Hcl2)
    return new Hcl2(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab2))
    o = labConvert2(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl2(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * degrees5;
  return new Hcl2(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl3(h2, c2, l, opacity) {
  return arguments.length === 1 ? hclConvert2(h2) : new Hcl2(h2, c2, l, opacity == null ? 1 : opacity);
}
function Hcl2(h2, c2, l, opacity) {
  this.h = +h2;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab2(o) {
  if (isNaN(o.h))
    return new Lab2(o.l, 0, 0, o.opacity);
  var h2 = o.h * radians4;
  return new Lab2(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
define_default4(Hcl2, hcl3, extend5(Color4, {
  brighter: function(k) {
    return new Hcl2(this.h, this.c, this.l + K2 * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl2(this.h, this.c, this.l - K2 * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab2(this).rgb();
  }
}));

// node_modules/vega-selections/build/vega-selection.module.js
function ascending3(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function bisector(f) {
  let delta = f;
  let compare3 = f;
  if (f.length === 1) {
    delta = (d, x5) => f(d) - x5;
    compare3 = ascendingComparator2(f);
  }
  function left(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare3(a2[mid], x5) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare3(a2[mid], x5) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    const i = left(a2, x5, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x5) > -delta(a2[i], x5) ? i - 1 : i;
  }
  return {
    left,
    center,
    right
  };
}
function ascendingComparator2(f) {
  return (d, x5) => ascending3(f(d), x5);
}
var Intersect = "intersect";
var Union = "union";
var VlMulti = "vlMulti";
var VlPoint = "vlPoint";
var Or = "or";
var And = "and";
var SELECTION_ID = "_vgsid_";
var TYPE_ENUM = "E";
var TYPE_RANGE_INC = "R";
var TYPE_RANGE_EXC = "R-E";
var TYPE_RANGE_LE = "R-LE";
var TYPE_RANGE_RE = "R-RE";
var UNIT_INDEX = "index:unit";
function testPoint(datum2, entry2) {
  var fields = entry2.fields, values2 = entry2.values, n = fields.length, i = 0, dval, f;
  for (; i < n; ++i) {
    f = fields[i];
    f.getter = field.getter || field(f.field);
    dval = f.getter(datum2);
    if (isDate(dval))
      dval = toNumber(dval);
    if (isDate(values2[i]))
      values2[i] = toNumber(values2[i]);
    if (isDate(values2[i][0]))
      values2[i] = values2[i].map(toNumber);
    if (f.type === TYPE_ENUM) {
      if (isArray(values2[i]) ? values2[i].indexOf(dval) < 0 : dval !== values2[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!inrange(dval, values2[i]))
          return false;
      } else if (f.type === TYPE_RANGE_RE) {
        if (!inrange(dval, values2[i], true, false))
          return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        if (!inrange(dval, values2[i], false, false))
          return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!inrange(dval, values2[i], false, true))
          return false;
      }
    }
  }
  return true;
}
function selectionTest(name2, datum2, op) {
  var data3 = this.context.data[name2], entries = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect5 = op === Intersect, n = entries.length, i = 0, entry2, miss, count2, unit2, b2;
  for (; i < n; ++i) {
    entry2 = entries[i];
    if (unitIdx && intersect5) {
      miss = miss || {};
      count2 = miss[unit2 = entry2.unit] || 0;
      if (count2 === -1)
        continue;
      b2 = testPoint(datum2, entry2);
      miss[unit2] = b2 ? -1 : ++count2;
      if (b2 && unitIdx.size === 1)
        return true;
      if (!b2 && count2 === unitIdx.get(unit2).count)
        return false;
    } else {
      b2 = testPoint(datum2, entry2);
      if (intersect5 ^ b2)
        return b2;
    }
  }
  return n && intersect5;
}
var selectionId = field(SELECTION_ID);
var bisect = bisector(selectionId);
var bisectLeft2 = bisect.left;
var bisectRight2 = bisect.right;
function selectionIdTest(name2, datum2, op) {
  const data3 = this.context.data[name2], entries = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect5 = op === Intersect, value3 = selectionId(datum2), index3 = bisectLeft2(entries, value3);
  if (index3 === entries.length)
    return false;
  if (selectionId(entries[index3]) !== value3)
    return false;
  if (unitIdx && intersect5) {
    if (unitIdx.size === 1)
      return true;
    if (bisectRight2(entries, value3) - index3 < unitIdx.size)
      return false;
  }
  return true;
}
function selectionTuples(array4, base2) {
  return array4.map((x5) => extend({
    values: base2.fields.map((f) => (f.getter || (f.getter = field(f.field)))(x5.datum))
  }, base2));
}
function selectionResolve(name2, op, isMulti, vl5) {
  var data3 = this.context.data[name2], entries = data3 ? data3.values.value : [], resolved = {}, multiRes = {}, types2 = {}, entry2, fields, values2, unit2, field3, res, resUnit, type2, union, n = entries.length, i = 0, j, m2;
  for (; i < n; ++i) {
    entry2 = entries[i];
    unit2 = entry2.unit;
    fields = entry2.fields;
    values2 = entry2.values;
    for (j = 0, m2 = fields.length; j < m2; ++j) {
      field3 = fields[j];
      res = resolved[field3.field] || (resolved[field3.field] = {});
      resUnit = res[unit2] || (res[unit2] = []);
      types2[field3.field] = type2 = field3.type.charAt(0);
      union = ops[type2 + "_union"];
      res[unit2] = union(resUnit, array(values2[j]));
    }
    if (isMulti) {
      resUnit = multiRes[unit2] || (multiRes[unit2] = []);
      resUnit.push(array(values2).reduce((obj, curr, j2) => (obj[fields[j2].field] = curr, obj), {}));
    }
  }
  op = op || Union;
  Object.keys(resolved).forEach((field4) => {
    resolved[field4] = Object.keys(resolved[field4]).map((unit3) => resolved[field4][unit3]).reduce((acc, curr) => acc === void 0 ? curr : ops[types2[field4] + "_" + op](acc, curr));
  });
  entries = Object.keys(multiRes);
  if (isMulti && entries.length) {
    const key2 = vl5 ? VlPoint : VlMulti;
    resolved[key2] = op === Union ? {
      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])
    } : {
      [And]: entries.map((k) => ({
        [Or]: multiRes[k]
      }))
    };
  }
  return resolved;
}
var ops = {
  E_union: function(base2, value3) {
    if (!base2.length)
      return value3;
    var i = 0, n = value3.length;
    for (; i < n; ++i)
      if (base2.indexOf(value3[i]) < 0)
        base2.push(value3[i]);
    return base2;
  },
  E_intersect: function(base2, value3) {
    return !base2.length ? value3 : base2.filter((v) => value3.indexOf(v) >= 0);
  },
  R_union: function(base2, value3) {
    var lo = toNumber(value3[0]), hi = toNumber(value3[1]);
    if (lo > hi) {
      lo = value3[1];
      hi = value3[0];
    }
    if (!base2.length)
      return [lo, hi];
    if (base2[0] > lo)
      base2[0] = lo;
    if (base2[1] < hi)
      base2[1] = hi;
    return base2;
  },
  R_intersect: function(base2, value3) {
    var lo = toNumber(value3[0]), hi = toNumber(value3[1]);
    if (lo > hi) {
      lo = value3[1];
      hi = value3[0];
    }
    if (!base2.length)
      return [lo, hi];
    if (hi < base2[0] || base2[1] < lo) {
      return [];
    } else {
      if (base2[0] < lo)
        base2[0] = lo;
      if (base2[1] > hi)
        base2[1] = hi;
    }
    return base2;
  }
};
var DataPrefix = ":";
var IndexPrefix = "@";
function selectionVisitor(name2, args, scope, params2) {
  if (args[0].type !== Literal)
    error("First argument to selection functions must be a string literal.");
  const data3 = args[0].value, op = args.length >= 2 && peek(args).value, field3 = "unit", indexName = IndexPrefix + field3, dataName = DataPrefix + data3;
  if (op === Intersect && !has(params2, indexName)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field3);
  }
  if (!has(params2, dataName)) {
    params2[dataName] = scope.getData(data3).tuplesRef();
  }
}

// node_modules/vega-functions/build/vega-functions.module.js
function data(name2) {
  const data3 = this.context.data[name2];
  return data3 ? data3.values.value : [];
}
function indata(name2, field3, value3) {
  const index3 = this.context.data[name2]["index:" + field3], entry2 = index3 ? index3.value.get(value3) : void 0;
  return entry2 ? entry2.count : entry2;
}
function setdata(name2, tuples) {
  const df = this.context.dataflow, data3 = this.context.data[name2], input = data3.input;
  df.pulse(input, df.changeset().remove(truthy).insert(tuples));
  return 1;
}
function encode(item, name2, retval) {
  if (item) {
    const df = this.context.dataflow, target2 = item.mark.source;
    df.pulse(target2, df.changeset().encode(item, name2));
  }
  return retval !== void 0 ? retval : item;
}
var wrap = (method2) => function(value3, spec) {
  const locale4 = this.context.dataflow.locale();
  return locale4[method2](spec)(value3);
};
var format4 = wrap("format");
var timeFormat2 = wrap("timeFormat");
var utcFormat2 = wrap("utcFormat");
var timeParse2 = wrap("timeParse");
var utcParse2 = wrap("utcParse");
var dateObj = new Date(2e3, 0, 1);
function time2(month2, day2, specifier) {
  if (!Number.isInteger(month2) || !Number.isInteger(day2))
    return "";
  dateObj.setYear(2e3);
  dateObj.setMonth(month2);
  dateObj.setDate(day2);
  return timeFormat2.call(this, dateObj, specifier);
}
function monthFormat(month2) {
  return time2.call(this, month2, 1, "%B");
}
function monthAbbrevFormat(month2) {
  return time2.call(this, month2, 1, "%b");
}
function dayFormat(day2) {
  return time2.call(this, 0, 2 + day2, "%A");
}
function dayAbbrevFormat(day2) {
  return time2.call(this, 0, 2 + day2, "%a");
}
var DataPrefix2 = ":";
var IndexPrefix2 = "@";
var ScalePrefix = "%";
var SignalPrefix = "$";
function dataVisitor(name2, args, scope, params2) {
  if (args[0].type !== Literal) {
    error("First argument to data functions must be a string literal.");
  }
  const data3 = args[0].value, dataName = DataPrefix2 + data3;
  if (!has(dataName, params2)) {
    try {
      params2[dataName] = scope.getData(data3).tuplesRef();
    } catch (err) {
    }
  }
}
function indataVisitor(name2, args, scope, params2) {
  if (args[0].type !== Literal)
    error("First argument to indata must be a string literal.");
  if (args[1].type !== Literal)
    error("Second argument to indata must be a string literal.");
  const data3 = args[0].value, field3 = args[1].value, indexName = IndexPrefix2 + field3;
  if (!has(indexName, params2)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field3);
  }
}
function scaleVisitor(name2, args, scope, params2) {
  if (args[0].type === Literal) {
    addScaleDependency(scope, params2, args[0].value);
  } else {
    for (name2 in scope.scales) {
      addScaleDependency(scope, params2, name2);
    }
  }
}
function addScaleDependency(scope, params2, name2) {
  const scaleName = ScalePrefix + name2;
  if (!has(params2, scaleName)) {
    try {
      params2[scaleName] = scope.scaleRef(name2);
    } catch (err) {
    }
  }
}
function getScale(name2, ctx) {
  let s;
  return isFunction(name2) ? name2 : isString(name2) ? (s = ctx.scales[name2]) && s.value : void 0;
}
function internalScaleFunctions(codegen2, fnctx, visitors) {
  fnctx.__bandwidth = (s) => s && s.bandwidth ? s.bandwidth() : 0;
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;
  const ref2 = (arg) => "_[" + (arg.type === Literal ? $(ScalePrefix + arg.value) : $(ScalePrefix) + "+" + codegen2(arg)) + "]";
  return {
    _bandwidth: (args) => "this.__bandwidth(".concat(ref2(args[0]), ")"),
    _range: (args) => "".concat(ref2(args[0]), ".range()"),
    _scale: (args) => "".concat(ref2(args[0]), "(").concat(codegen2(args[1]), ")")
  };
}
function geoMethod(methodName, globalMethod) {
  return function(projection3, geojson, group2) {
    if (projection3) {
      const p = getScale(projection3, (group2 || this).context);
      return p && p.path[methodName](geojson);
    } else {
      return globalMethod(geojson);
    }
  };
}
var geoArea = geoMethod("area", area_default2);
var geoBounds = geoMethod("bounds", bounds_default);
var geoCentroid = geoMethod("centroid", centroid_default);
function inScope(item) {
  const group2 = this.context.group;
  let value3 = false;
  if (group2)
    while (item) {
      if (item === group2) {
        value3 = true;
        break;
      }
      item = item.mark.group;
    }
  return value3;
}
function log5(df, method2, args) {
  try {
    df[method2].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn() {
  return log5(this.context.dataflow, "warn", arguments);
}
function info() {
  return log5(this.context.dataflow, "info", arguments);
}
function debug() {
  return log5(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance(color7) {
  const c2 = rgb4(color7), r = channel_luminance_value(c2.r), g = channel_luminance_value(c2.g), b2 = channel_luminance_value(c2.b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b2;
}
function contrast(color1, color22) {
  const lum1 = luminance(color1), lum2 = luminance(color22), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}
function merge4() {
  const args = [].slice.call(arguments);
  args.unshift({});
  return extend(...args);
}
function equal(a2, b2) {
  return a2 === b2 || a2 !== a2 && b2 !== b2 ? true : isArray(a2) ? isArray(b2) && a2.length === b2.length ? equalArray(a2, b2) : false : isObject(a2) && isObject(b2) ? equalObject(a2, b2) : false;
}
function equalArray(a2, b2) {
  for (let i = 0, n = a2.length; i < n; ++i) {
    if (!equal(a2[i], b2[i]))
      return false;
  }
  return true;
}
function equalObject(a2, b2) {
  for (const key2 in a2) {
    if (!equal(a2[key2], b2[key2]))
      return false;
  }
  return true;
}
function removePredicate(props) {
  return (_) => equalObject(props, _);
}
function modify(name2, insert2, remove2, toggle, modify2, values2) {
  const df = this.context.dataflow, data3 = this.context.data[name2], input = data3.input, stamp = df.stamp();
  let changes = data3.changes, predicate, key2;
  if (df._trigger === false || !(input.value.length || insert2 || toggle)) {
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data3.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data3.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove2) {
    predicate = remove2 === true ? truthy : isArray(remove2) || isTuple(remove2) ? remove2 : removePredicate(remove2);
    changes.remove(predicate);
  }
  if (insert2) {
    changes.insert(insert2);
  }
  if (toggle) {
    predicate = removePredicate(toggle);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle);
    }
  }
  if (modify2) {
    for (key2 in values2) {
      changes.modify(modify2, key2, values2[key2]);
    }
  }
  return 1;
}
function pinchDistance(event2) {
  const t = event2.touches, dx = t[0].clientX - t[1].clientX, dy = t[0].clientY - t[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchAngle(event2) {
  const t = event2.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
var accessors = {};
function pluck(data3, name2) {
  const accessor2 = accessors[name2] || (accessors[name2] = field(name2));
  return isArray(data3) ? data3.map(accessor2) : accessor2(data3);
}
function array3(seq) {
  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence2(seq) {
  return array3(seq) || (isString(seq) ? seq : null);
}
function join2(seq, ...args) {
  return array3(seq).join(...args);
}
function indexof(seq, ...args) {
  return sequence2(seq).indexOf(...args);
}
function lastindexof(seq, ...args) {
  return sequence2(seq).lastIndexOf(...args);
}
function slice3(seq, ...args) {
  return sequence2(seq).slice(...args);
}
function replace2(str, pattern, repl) {
  if (isFunction(repl))
    error("Function argument passed to replace.");
  return String(str).replace(pattern, repl);
}
function reverse(seq) {
  return array3(seq).slice().reverse();
}
function bandspace(count2, paddingInner, paddingOuter) {
  return bandSpace(count2 || 0, paddingInner || 0, paddingOuter || 0);
}
function bandwidth(name2, group2) {
  const s = getScale(name2, (group2 || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy3(name2, group2) {
  const s = getScale(name2, (group2 || this).context);
  return s ? s.copy() : void 0;
}
function domain(name2, group2) {
  const s = getScale(name2, (group2 || this).context);
  return s ? s.domain() : [];
}
function invert(name2, range4, group2) {
  const s = getScale(name2, (group2 || this).context);
  return !s ? void 0 : isArray(range4) ? (s.invertRange || s.invert)(range4) : (s.invert || s.invertExtent)(range4);
}
function range2(name2, group2) {
  const s = getScale(name2, (group2 || this).context);
  return s && s.range ? s.range() : [];
}
function scale3(name2, value3, group2) {
  const s = getScale(name2, (group2 || this).context);
  return s ? s(value3) : void 0;
}
function scaleGradient(scale6, p02, p1, count2, group2) {
  scale6 = getScale(scale6, (group2 || this).context);
  const gradient3 = Gradient(p02, p1);
  let stops = scale6.domain(), min4 = stops[0], max4 = peek(stops), fraction = identity;
  if (!(max4 - min4)) {
    scale6 = (scale6.interpolator ? scale("sequential")().interpolator(scale6.interpolator()) : scale("linear")().interpolate(scale6.interpolate()).range(scale6.range())).domain([min4 = 0, max4 = 1]);
  } else {
    fraction = scaleFraction(scale6, min4, max4);
  }
  if (scale6.ticks) {
    stops = scale6.ticks(+count2 || 15);
    if (min4 !== stops[0])
      stops.unshift(min4);
    if (max4 !== peek(stops))
      stops.push(max4);
  }
  stops.forEach((_) => gradient3.stop(fraction(_), scale6(_)));
  return gradient3;
}
function geoShape(projection3, geojson, group2) {
  const p = getScale(projection3, (group2 || this).context);
  return function(context3) {
    return p ? p.path.context(context3)(geojson) : "";
  };
}
function pathShape(path3) {
  let p = null;
  return function(context3) {
    return context3 ? pathRender(context3, p = p || pathParse(path3)) : path3;
  };
}
var datum = (d) => d.data;
function treeNodes(name2, context3) {
  const tree = data.call(context3, name2);
  return tree.root && tree.root.lookup || {};
}
function treePath(name2, source3, target2) {
  const nodes = treeNodes(name2, this), s = nodes[source3], t = nodes[target2];
  return s && t ? s.path(t).map(datum) : void 0;
}
function treeAncestors(name2, node) {
  const n = treeNodes(name2, this)[node];
  return n ? n.ancestors().map(datum) : void 0;
}
var _window = () => typeof window !== "undefined" && window || null;
function screen() {
  const w2 = _window();
  return w2 ? w2.screen : {};
}
function windowSize() {
  const w2 = _window();
  return w2 ? [w2.innerWidth, w2.innerHeight] : [void 0, void 0];
}
function containerSize() {
  const view = this.context.dataflow, el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
}
function intersect4(b2, opt, group2) {
  if (!b2)
    return [];
  const [u, v] = b2, box = new Bounds().set(u[0], u[1], v[0], v[1]), scene = group2 || this.context.dataflow.scenegraph().root;
  return intersect2(scene, box, filter2(opt));
}
function filter2(opt) {
  let p = null;
  if (opt) {
    const types2 = array(opt.marktype), names = array(opt.markname);
    p = (_) => (!types2.length || types2.some((t) => _.marktype === t)) && (!names.length || names.some((s) => _.name === s));
  }
  return p;
}
var functionContext = {
  random() {
    return random();
  },
  cumulativeNormal,
  cumulativeLogNormal,
  cumulativeUniform,
  densityNormal,
  densityLogNormal,
  densityUniform,
  quantileNormal,
  quantileLogNormal,
  quantileUniform,
  sampleNormal,
  sampleLogNormal,
  sampleUniform,
  isArray,
  isBoolean,
  isDate,
  isDefined(_) {
    return _ !== void 0;
  },
  isNumber,
  isObject,
  isRegExp,
  isString,
  isTuple,
  isValid(_) {
    return _ != null && _ === _;
  },
  toBoolean,
  toDate,
  toNumber,
  toString,
  indexof,
  join: join2,
  lastindexof,
  replace: replace2,
  reverse,
  slice: slice3,
  flush,
  lerp,
  merge: merge4,
  pad,
  peek,
  pluck,
  span,
  inrange,
  truncate,
  rgb: rgb4,
  lab: lab3,
  hcl: hcl3,
  hsl: hsl5,
  luminance,
  contrast,
  sequence: range_default,
  format: format4,
  utcFormat: utcFormat2,
  utcParse: utcParse2,
  utcOffset,
  utcSequence,
  timeFormat: timeFormat2,
  timeParse: timeParse2,
  timeOffset,
  timeSequence,
  timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter,
  utcquarter,
  week,
  utcweek,
  dayofyear,
  utcdayofyear,
  warn,
  info,
  debug,
  extent,
  inScope,
  intersect: intersect4,
  clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  encode,
  modify
};
var eventFunctions = ["view", "item", "group", "xy", "x", "y"];
var eventPrefix = "event.vega.";
var thisPrefix = "this.";
var astVisitors = {};
var codegenParams = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (id2) => "_[".concat($(SignalPrefix + id2), "]"),
  functions: buildFunctions,
  constants: Constants,
  visitors: astVisitors
};
var codeGenerator = codegen(codegenParams);
function buildFunctions(codegen2) {
  const fn = Functions(codegen2);
  eventFunctions.forEach((name2) => fn[name2] = eventPrefix + name2);
  for (const name2 in functionContext) {
    fn[name2] = thisPrefix + name2;
  }
  extend(fn, internalScaleFunctions(codegen2, functionContext, astVisitors));
  return fn;
}
function expressionFunction(name2, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name2];
  }
  functionContext[name2] = fn;
  if (visitor)
    astVisitors[name2] = visitor;
  if (codeGenerator)
    codeGenerator.functions[name2] = thisPrefix + name2;
  return this;
}
expressionFunction("bandwidth", bandwidth, scaleVisitor);
expressionFunction("copy", copy3, scaleVisitor);
expressionFunction("domain", domain, scaleVisitor);
expressionFunction("range", range2, scaleVisitor);
expressionFunction("invert", invert, scaleVisitor);
expressionFunction("scale", scale3, scaleVisitor);
expressionFunction("gradient", scaleGradient, scaleVisitor);
expressionFunction("geoArea", geoArea, scaleVisitor);
expressionFunction("geoBounds", geoBounds, scaleVisitor);
expressionFunction("geoCentroid", geoCentroid, scaleVisitor);
expressionFunction("geoShape", geoShape, scaleVisitor);
expressionFunction("indata", indata, indataVisitor);
expressionFunction("data", data, dataVisitor);
expressionFunction("treePath", treePath, dataVisitor);
expressionFunction("treeAncestors", treeAncestors, dataVisitor);
expressionFunction("vlSelectionTest", selectionTest, selectionVisitor);
expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor);
expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor);
expressionFunction("vlSelectionTuples", selectionTuples);
function parser2(expr2, scope) {
  const params2 = {};
  let ast;
  try {
    expr2 = isString(expr2) ? expr2 : $(expr2) + "";
    ast = parser(expr2);
  } catch (err) {
    error("Expression parse error: " + expr2);
  }
  ast.visit((node) => {
    if (node.type !== CallExpression)
      return;
    const name2 = node.callee.name, visit2 = codegenParams.visitors[name2];
    if (visit2)
      visit2(name2, node.arguments, scope, params2);
  });
  const gen = codeGenerator(ast);
  gen.globals.forEach((name2) => {
    const signalName = SignalPrefix + name2;
    if (!has(params2, signalName) && scope.getSignal(name2)) {
      params2[signalName] = scope.signalRef(name2);
    }
  });
  return {
    $expr: extend({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params2
  };
}

// node_modules/vega-runtime/build/vega-runtime.module.js
function parse4(spec) {
  const ctx = this, operators = spec.operators || [];
  if (spec.background) {
    ctx.background = spec.background;
  }
  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  }
  if (spec.locale) {
    ctx.locale = spec.locale;
  }
  operators.forEach((entry2) => ctx.parseOperator(entry2));
  operators.forEach((entry2) => ctx.parseOperatorParameters(entry2));
  (spec.streams || []).forEach((entry2) => ctx.parseStream(entry2));
  (spec.updates || []).forEach((entry2) => ctx.parseUpdate(entry2));
  return ctx.resolve();
}
var Skip = toSet(["rule"]);
var Swap = toSet(["group", "image", "rect"]);
function adjustSpatial(encode2, marktype) {
  let code = "";
  if (Skip[marktype])
    return code;
  if (encode2.x2) {
    if (encode2.x) {
      if (Swap[marktype]) {
        code += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;";
      }
      code += "o.width=o.x2-o.x;";
    } else {
      code += "o.x=o.x2-(o.width||0);";
    }
  }
  if (encode2.xc) {
    code += "o.x=o.xc-(o.width||0)/2;";
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (Swap[marktype]) {
        code += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;";
      }
      code += "o.height=o.y2-o.y;";
    } else {
      code += "o.y=o.y2-(o.height||0);";
    }
  }
  if (encode2.yc) {
    code += "o.y=o.yc-(o.height||0)/2;";
  }
  return code;
}
function canonicalType(type2) {
  return (type2 + "").toLowerCase();
}
function isOperator(type2) {
  return canonicalType(type2) === "operator";
}
function isCollect(type2) {
  return canonicalType(type2) === "collect";
}
function expression(ctx, args, code) {
  if (code[code.length - 1] !== ";") {
    code = "return(" + code + ");";
  }
  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
}
function _compare(u, v, lt, gt) {
  return "((u = ".concat(u, ") < (v = ").concat(v, ") || u == null) && v != null ? ").concat(lt, "\n  : (u > v || v == null) && u != null ? ").concat(gt, "\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ").concat(lt, "\n  : v !== v && u === u ? ").concat(gt, " : ");
}
var expressionCodegen = {
  operator: (ctx, expr2) => expression(ctx, ["_"], expr2.code),
  parameter: (ctx, expr2) => expression(ctx, ["datum", "_"], expr2.code),
  event: (ctx, expr2) => expression(ctx, ["event"], expr2.code),
  handler: (ctx, expr2) => {
    const code = "var datum=event.item&&event.item.datum;return ".concat(expr2.code, ";");
    return expression(ctx, ["_", "event"], code);
  },
  encode: (ctx, encode2) => {
    const {
      marktype,
      channels
    } = encode2;
    let code = "var o=item,datum=o.datum,m=0,$;";
    for (const name2 in channels) {
      const o = "o[" + $(name2) + "]";
      code += "$=".concat(channels[name2].code, ";if(").concat(o, "!==$)").concat(o, "=$,m=1;");
    }
    code += adjustSpatial(channels, marktype);
    code += "return m;";
    return expression(ctx, ["item", "_"], code);
  },
  codegen: {
    get(path3) {
      const ref2 = "[".concat(path3.map($).join("]["), "]");
      const get6 = Function("_", "return _".concat(ref2, ";"));
      get6.path = ref2;
      return get6;
    },
    comparator(fields, orders) {
      let t;
      const map3 = (f, i) => {
        const o = orders[i];
        let u, v;
        if (f.path) {
          u = "a".concat(f.path);
          v = "b".concat(f.path);
        } else {
          (t = t || {})["f" + i] = f;
          u = "this.f".concat(i, "(a)");
          v = "this.f".concat(i, "(b)");
        }
        return _compare(u, v, -o, o);
      };
      const fn = Function("a", "b", "var u, v; return " + fields.map(map3).join("") + "0;");
      return t ? fn.bind(t) : fn;
    }
  }
};
function parseOperator(spec) {
  const ctx = this;
  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
function parseOperatorParameters(spec) {
  const ctx = this;
  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op)
      error("Invalid operator id: " + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}
function parseParameters(spec, params2) {
  params2 = params2 || {};
  const ctx = this;
  for (const key2 in spec) {
    const value3 = spec[key2];
    params2[key2] = isArray(value3) ? value3.map((v) => parseParameter(v, ctx, params2)) : parseParameter(value3, ctx, params2);
  }
  return params2;
}
function parseParameter(spec, ctx, params2) {
  if (!spec || !isObject(spec))
    return spec;
  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];
    if (has(spec, p.key)) {
      return p.parse(spec, ctx, params2);
    }
  }
  return spec;
}
var PARSERS = [{
  key: "$ref",
  parse: getOperator
}, {
  key: "$key",
  parse: getKey
}, {
  key: "$expr",
  parse: getExpression
}, {
  key: "$field",
  parse: getField2
}, {
  key: "$encode",
  parse: getEncode
}, {
  key: "$compare",
  parse: getCompare
}, {
  key: "$context",
  parse: getContext
}, {
  key: "$subflow",
  parse: getSubflow
}, {
  key: "$tupleid",
  parse: getTupleId
}];
function getOperator(_, ctx) {
  return ctx.get(_.$ref) || error("Operator not defined: " + _.$ref);
}
function getExpression(_, ctx, params2) {
  if (_.$params) {
    ctx.parseParameters(_.$params, params2);
  }
  const k = "e:" + _.$expr.code + "_" + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));
}
function getKey(_, ctx) {
  const k = "k:" + _.$key + "_" + !!_.$flat;
  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));
}
function getField2(_, ctx) {
  if (!_.$field)
    return null;
  const k = "f:" + _.$field + "_" + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));
}
function getCompare(_, ctx) {
  const k = "c:" + _.$compare + "_" + _.$order, c2 = array(_.$compare).map((_2) => _2 && _2.$tupleid ? tupleid : _2);
  return ctx.fn[k] || (ctx.fn[k] = compare(c2, _.$order, ctx.expr.codegen));
}
function getEncode(_, ctx) {
  const spec = _.$encode, encode2 = {};
  for (const name2 in spec) {
    const enc = spec[name2];
    encode2[name2] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode2[name2].output = enc.$output;
  }
  return encode2;
}
function getContext(_, ctx) {
  return ctx;
}
function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function(dataflow, key2, parent) {
    const subctx = ctx.fork().parse(spec), op = subctx.get(spec.operators[0].id), p = subctx.signals.parent;
    if (p)
      p.set(parent);
    op.detachSubflow = () => ctx.detach(subctx);
    return op;
  };
}
function getTupleId() {
  return tupleid;
}
function parseStream(spec) {
  var ctx = this, filter3 = spec.filter != null ? ctx.eventExpression(spec.filter) : void 0, stream2 = spec.stream != null ? ctx.get(spec.stream) : void 0, args;
  if (spec.source) {
    stream2 = ctx.events(spec.source, spec.type, filter3);
  } else if (spec.merge) {
    args = spec.merge.map((_) => ctx.get(_));
    stream2 = args[0].merge.apply(args[0], args.slice(1));
  }
  if (spec.between) {
    args = spec.between.map((_) => ctx.get(_));
    stream2 = stream2.between(args[0], args[1]);
  }
  if (spec.filter) {
    stream2 = stream2.filter(filter3);
  }
  if (spec.throttle != null) {
    stream2 = stream2.throttle(+spec.throttle);
  }
  if (spec.debounce != null) {
    stream2 = stream2.debounce(+spec.debounce);
  }
  if (stream2 == null) {
    error("Invalid stream definition: " + JSON.stringify(spec));
  }
  if (spec.consume)
    stream2.consume(true);
  ctx.stream(spec, stream2);
}
function parseUpdate(spec) {
  var ctx = this, srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid, source3 = ctx.get(srcid), target2 = null, update3 = spec.update, params2 = void 0;
  if (!source3)
    error("Source not defined: " + spec.source);
  target2 = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
  if (update3 && update3.$expr) {
    if (update3.$params) {
      params2 = ctx.parseParameters(update3.$params);
    }
    update3 = ctx.handlerExpression(update3.$expr);
  }
  ctx.update(spec, source3, target2, update3, params2);
}
var SKIP3 = {
  skip: true
};
function getState(options) {
  var ctx = this, state = {};
  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach((key2) => {
      const op = ctx.signals[key2];
      if (options.signals(key2, op)) {
        signals[key2] = op.value;
      }
    });
  }
  if (options.data) {
    var data3 = state.data = {};
    Object.keys(ctx.data).forEach((key2) => {
      const dataset = ctx.data[key2];
      if (options.data(key2, dataset)) {
        data3[key2] = dataset.input.value;
      }
    });
  }
  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map((ctx2) => ctx2.getState(options));
  }
  return state;
}
function setState(state) {
  var ctx = this, df = ctx.dataflow, data3 = state.data, signals = state.signals;
  Object.keys(signals || {}).forEach((key2) => {
    df.update(ctx.signals[key2], signals[key2], SKIP3);
  });
  Object.keys(data3 || {}).forEach((key2) => {
    df.pulse(ctx.data[key2].input, df.changeset().remove(truthy).insert(data3[key2]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx)
      subctx.setState(substate);
  });
}
function context2(df, transforms2, functions, expr2) {
  return new Context(df, transforms2, functions, expr2);
}
function Context(df, transforms2, functions, expr2) {
  this.dataflow = df;
  this.transforms = transforms2;
  this.events = df.events.bind(df);
  this.expr = expr2 || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};
  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}
function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);
  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}
Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },
  detach(ctx) {
    this.subcontext = this.subcontext.filter((c2) => c2 !== ctx);
    const keys3 = Object.keys(ctx.nodes);
    for (const key2 of keys3)
      ctx.nodes[key2]._targets = null;
    for (const key2 of keys3)
      ctx.nodes[key2].detach();
    ctx.nodes = null;
  },
  get(id2) {
    return this.nodes[id2];
  },
  set(id2, node) {
    return this.nodes[id2] = node;
  },
  add(spec, op) {
    const ctx = this, df = ctx.dataflow, data3 = spec.value;
    ctx.set(spec.id, op);
    if (isCollect(spec.type) && data3) {
      if (data3.$ingest) {
        df.ingest(op, data3.$ingest, data3.$format);
      } else if (data3.$request) {
        df.preload(op, data3.$request, data3.$format);
      } else {
        df.pulse(op, df.changeset().insert(data3));
      }
    }
    if (spec.root) {
      ctx.root = op;
    }
    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);
      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }
    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }
    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }
    if (spec.data) {
      for (const name2 in spec.data) {
        const data4 = ctx.data[name2] || (ctx.data[name2] = {});
        spec.data[name2].forEach((role) => data4[role] = op);
      }
    }
  },
  resolve() {
    (this.unresolved || []).forEach((fn) => fn());
    delete this.unresolved;
    return this;
  },
  operator(spec, update3) {
    this.add(spec, this.dataflow.add(spec.value, update3));
  },
  transform(spec, type2) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type2)]));
  },
  stream(spec, stream2) {
    this.set(spec.id, stream2);
  },
  update(spec, stream2, target2, update3, params2) {
    this.dataflow.on(stream2, target2, update3, params2, spec.options);
  },
  operatorExpression(expr2) {
    return this.expr.operator(this, expr2);
  },
  parameterExpression(expr2) {
    return this.expr.parameter(this, expr2);
  },
  eventExpression(expr2) {
    return this.expr.event(this, expr2);
  },
  handlerExpression(expr2) {
    return this.expr.handler(this, expr2);
  },
  encodeExpression(encode2) {
    return this.expr.encode(this, encode2);
  },
  parse: parse4,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  getState,
  setState
};

// node_modules/vega-view/node_modules/d3-timer/src/timer.js
var frame2 = 0;
var timeout2 = 0;
var interval2 = 0;
var pokeDelay2 = 1e3;
var taskHead2;
var taskTail2;
var clockLast2 = 0;
var clockNow2 = 0;
var clockSkew2 = 0;
var clock2 = typeof performance === "object" && performance.now ? performance : Date;
var setFrame2 = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now2() {
  return clockNow2 || (setFrame2(clearNow2), clockNow2 = clock2.now() + clockSkew2);
}
function clearNow2() {
  clockNow2 = 0;
}
function Timer2() {
  this._call = this._time = this._next = null;
}
Timer2.prototype = timer2.prototype = {
  constructor: Timer2,
  restart: function(callback, delay, time3) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time3 = (time3 == null ? now2() : +time3) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail2 !== this) {
      if (taskTail2)
        taskTail2._next = this;
      else
        taskHead2 = this;
      taskTail2 = this;
    }
    this._call = callback;
    this._time = time3;
    sleep2();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep2();
    }
  }
};
function timer2(callback, delay, time3) {
  var t = new Timer2();
  t.restart(callback, delay, time3);
  return t;
}
function timerFlush2() {
  now2();
  ++frame2;
  var t = taskHead2, e;
  while (t) {
    if ((e = clockNow2 - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame2;
}
function wake2() {
  clockNow2 = (clockLast2 = clock2.now()) + clockSkew2;
  frame2 = timeout2 = 0;
  try {
    timerFlush2();
  } finally {
    frame2 = 0;
    nap2();
    clockNow2 = 0;
  }
}
function poke2() {
  var now3 = clock2.now(), delay = now3 - clockLast2;
  if (delay > pokeDelay2)
    clockSkew2 -= delay, clockLast2 = now3;
}
function nap2() {
  var t05, t14 = taskHead2, t23, time3 = Infinity;
  while (t14) {
    if (t14._call) {
      if (time3 > t14._time)
        time3 = t14._time;
      t05 = t14, t14 = t14._next;
    } else {
      t23 = t14._next, t14._next = null;
      t14 = t05 ? t05._next = t23 : taskHead2 = t23;
    }
  }
  taskTail2 = t05;
  sleep2(time3);
}
function sleep2(time3) {
  if (frame2)
    return;
  if (timeout2)
    timeout2 = clearTimeout(timeout2);
  var delay = time3 - clockNow2;
  if (delay > 24) {
    if (time3 < Infinity)
      timeout2 = setTimeout(wake2, time3 - clock2.now() - clockSkew2);
    if (interval2)
      interval2 = clearInterval(interval2);
  } else {
    if (!interval2)
      clockLast2 = clock2.now(), interval2 = setInterval(poke2, pokeDelay2);
    frame2 = 1, setFrame2(wake2);
  }
}

// node_modules/vega-view/node_modules/d3-timer/src/interval.js
function interval_default(callback, delay, time3) {
  var t = new Timer2(), total = delay;
  if (delay == null)
    return t.restart(callback, delay, time3), t;
  t._restart = t.restart;
  t.restart = function(callback2, delay2, time4) {
    delay2 = +delay2, time4 = time4 == null ? now2() : +time4;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay2, time4);
      callback2(elapsed);
    }, delay2, time4);
  };
  t.restart(callback, delay, time3);
  return t;
}

// node_modules/vega-view/build/vega-view.module.js
function initializeAria(view) {
  const el = view.container();
  if (el) {
    el.setAttribute("role", "graphics-document");
    el.setAttribute("aria-roleDescription", "visualization");
    ariaLabel(el, view.description());
  }
}
function ariaLabel(el, desc) {
  if (el)
    desc == null ? el.removeAttribute("aria-label") : el.setAttribute("aria-label", desc);
}
function background2(view) {
  view.add(null, (_) => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}
var Default = "default";
function cursor(view) {
  const cursor2 = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  }));
  view.on(view.events("view", "mousemove"), cursor2, (_, event2) => {
    const value3 = cursor2.value, user = value3 ? isString(value3) ? value3 : value3.user : Default, item = event2.item && event2.item.cursor || null;
    return value3 && user === value3.user && item == value3.item ? value3 : {
      user,
      item
    };
  });
  view.add(null, function(_) {
    let user = _.cursor, item = this.value;
    if (!isString(user)) {
      item = user.item;
      user = user.user;
    }
    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor2
  });
}
function setCursor(view, cursor2) {
  const el = view.globalCursor() ? typeof document !== "undefined" && document.body : view.container();
  if (el) {
    return cursor2 == null ? el.style.removeProperty("cursor") : el.style.cursor = cursor2;
  }
}
function dataref(view, name2) {
  var data3 = view._runtime.data;
  if (!has(data3, name2)) {
    error("Unrecognized data set: " + name2);
  }
  return data3[name2];
}
function data2(name2, values2) {
  return arguments.length < 2 ? dataref(this, name2).values.value : change.call(this, name2, changeset().remove(truthy).insert(values2));
}
function change(name2, changes) {
  if (!isChangeSet(changes)) {
    error("Second argument to changes must be a changeset.");
  }
  const dataset = dataref(this, name2);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name2, _) {
  return change.call(this, name2, changeset().insert(_));
}
function remove(name2, _) {
  return change.call(this, name2, changeset().remove(_));
}
function width(view) {
  var padding2 = view.padding();
  return Math.max(0, view._viewWidth + padding2.left + padding2.right);
}
function height(view) {
  var padding2 = view.padding();
  return Math.max(0, view._viewHeight + padding2.top + padding2.bottom);
}
function offset3(view) {
  var padding2 = view.padding(), origin = view._origin;
  return [padding2.left + origin[0], padding2.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset3(view), w2 = width(view), h2 = height(view);
  view._renderer.background(view.background());
  view._renderer.resize(w2, h2, origin);
  view._handler.origin(origin);
  view._resizeListeners.forEach((handler) => {
    try {
      handler(w2, h2);
    } catch (error2) {
      view.error(error2);
    }
  });
}
function eventExtend(view, event2, item) {
  var r = view._renderer, el = r && r.canvas(), p, e, translate3;
  if (el) {
    translate3 = offset3(view);
    e = event2.changedTouches ? event2.changedTouches[0] : event2;
    p = point6(e, el);
    p[0] -= translate3[0];
    p[1] -= translate3[1];
  }
  event2.dataflow = view;
  event2.item = item;
  event2.vega = extension(view, item, p);
  return event2;
}
function extension(view, item, point7) {
  const itemGroup = item ? item.mark.marktype === "group" ? item : item.mark.group : null;
  function group2(name2) {
    var g = itemGroup, i;
    if (name2)
      for (i = item; i; i = i.mark.group) {
        if (i.mark.name === name2) {
          g = i;
          break;
        }
      }
    return g && g.mark && g.mark.interactive ? g : {};
  }
  function xy(item2) {
    if (!item2)
      return point7;
    if (isString(item2))
      item2 = group2(item2);
    const p = point7.slice();
    while (item2) {
      p[0] -= item2.x || 0;
      p[1] -= item2.y || 0;
      item2 = item2.mark && item2.mark.group;
    }
    return p;
  }
  return {
    view: constant(view),
    item: constant(item || {}),
    group: group2,
    xy,
    x: (item2) => xy(item2)[0],
    y: (item2) => xy(item2)[1]
  };
}
var VIEW = "view";
var TIMER = "timer";
var WINDOW = "window";
var NO_TRAP = {
  trap: false
};
function initializeEventConfig(config) {
  const events3 = extend({
    defaults: {}
  }, config);
  const unpack = (obj, keys3) => {
    keys3.forEach((k) => {
      if (isArray(obj[k]))
        obj[k] = toSet(obj[k]);
    });
  };
  unpack(events3.defaults, ["prevent", "allow"]);
  unpack(events3, ["view", "window", "selector"]);
  return events3;
}
function trackEventListener(view, sources, type2, handler) {
  view._eventListeners.push({
    type: type2,
    sources: array(sources),
    handler
  });
}
function prevent(view, type2) {
  var def2 = view._eventConfig.defaults, prevent2 = def2.prevent, allow = def2.allow;
  return prevent2 === false || allow === true ? false : prevent2 === true || allow === false ? true : prevent2 ? prevent2[type2] : allow ? !allow[type2] : view.preventDefault();
}
function permit(view, key2, type2) {
  const rule3 = view._eventConfig && view._eventConfig[key2];
  if (rule3 === false || isObject(rule3) && !rule3[type2]) {
    view.warn(`Blocked ${key2} ${type2} event listener.`);
    return false;
  }
  return true;
}
function events2(source3, type2, filter3) {
  var view = this, s = new EventStream(filter3), send = function(e, item) {
    view.runAsync(null, () => {
      if (source3 === VIEW && prevent(view, type2)) {
        e.preventDefault();
      }
      s.receive(eventExtend(view, e, item));
    });
  }, sources;
  if (source3 === TIMER) {
    if (permit(view, "timer", type2)) {
      view.timer(send, type2);
    }
  } else if (source3 === VIEW) {
    if (permit(view, "view", type2)) {
      view.addEventListener(type2, send, NO_TRAP);
    }
  } else {
    if (source3 === WINDOW) {
      if (permit(view, "window", type2) && typeof window !== "undefined") {
        sources = [window];
      }
    } else if (typeof document !== "undefined") {
      if (permit(view, "selector", type2)) {
        sources = document.querySelectorAll(source3);
      }
    }
    if (!sources) {
      view.warn("Can not resolve event source: " + source3);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type2, send);
      }
      trackEventListener(view, sources, type2, send);
    }
  }
  return s;
}
function itemFilter(event2) {
  return event2.item;
}
function markTarget(event2) {
  return event2.item.mark.source;
}
function invoke(name2) {
  return function(_, event2) {
    return event2.vega.view().changeset().encode(event2.item, name2);
  };
}
function hover(hoverSet, leaveSet) {
  hoverSet = [hoverSet || "hover"];
  leaveSet = [leaveSet || "update", hoverSet[0]];
  this.on(this.events("view", "mouseover", itemFilter), markTarget, invoke(hoverSet));
  this.on(this.events("view", "mouseout", itemFilter), markTarget, invoke(leaveSet));
  return this;
}
function finalize() {
  var tooltip = this._tooltip, timers = this._timers, listeners = this._eventListeners, n, m2, e;
  n = timers.length;
  while (--n >= 0) {
    timers[n].stop();
  }
  n = listeners.length;
  while (--n >= 0) {
    e = listeners[n];
    m2 = e.sources.length;
    while (--m2 >= 0) {
      e.sources[m2].removeEventListener(e.type, e.handler);
    }
  }
  if (tooltip) {
    tooltip.call(this, this._handler, null, null, null);
  }
  return this;
}
function element2(tag, attr2, text2) {
  const el = document.createElement(tag);
  for (const key2 in attr2)
    el.setAttribute(key2, attr2[key2]);
  if (text2 != null)
    el.textContent = text2;
  return el;
}
var BindClass = "vega-bind";
var NameClass = "vega-bind-name";
var RadioClass = "vega-bind-radio";
function bind2(view, el, binding) {
  if (!el)
    return;
  const param2 = binding.param;
  let bind3 = binding.state;
  if (!bind3) {
    bind3 = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: (value3) => {
        if (value3 != view.signal(param2.signal)) {
          view.runAsync(null, () => {
            bind3.source = true;
            view.signal(param2.signal, value3);
          });
        }
      }
    };
    if (param2.debounce) {
      bind3.update = debounce(param2.debounce, bind3.update);
    }
  }
  const create4 = param2.input == null && param2.element ? target : generate;
  create4(bind3, el, param2, view);
  if (!bind3.active) {
    view.on(view._signals[param2.signal], null, () => {
      bind3.source ? bind3.source = false : bind3.set(view.signal(param2.signal));
    });
    bind3.active = true;
  }
  return bind3;
}
function target(bind3, node, param2, view) {
  const type2 = param2.event || "input";
  const handler = () => bind3.update(node.value);
  view.signal(param2.signal, node.value);
  node.addEventListener(type2, handler);
  trackEventListener(view, node, type2, handler);
  bind3.set = (value3) => {
    node.value = value3;
    node.dispatchEvent(event(type2));
  };
}
function event(type2) {
  return typeof Event !== "undefined" ? new Event(type2) : {
    type: type2
  };
}
function generate(bind3, el, param2, view) {
  const value3 = view.signal(param2.signal);
  const div = element2("div", {
    "class": BindClass
  });
  const wrapper = param2.input === "radio" ? div : div.appendChild(element2("label"));
  wrapper.appendChild(element2("span", {
    "class": NameClass
  }, param2.name || param2.signal));
  el.appendChild(div);
  let input = form;
  switch (param2.input) {
    case "checkbox":
      input = checkbox;
      break;
    case "select":
      input = select;
      break;
    case "radio":
      input = radio;
      break;
    case "range":
      input = range3;
      break;
  }
  input(bind3, wrapper, param2, value3);
}
function form(bind3, el, param2, value3) {
  const node = element2("input");
  for (const key2 in param2) {
    if (key2 !== "signal" && key2 !== "element") {
      node.setAttribute(key2 === "input" ? "type" : key2, param2[key2]);
    }
  }
  node.setAttribute("name", param2.signal);
  node.value = value3;
  el.appendChild(node);
  node.addEventListener("input", () => bind3.update(node.value));
  bind3.elements = [node];
  bind3.set = (value4) => node.value = value4;
}
function checkbox(bind3, el, param2, value3) {
  const attr2 = {
    type: "checkbox",
    name: param2.signal
  };
  if (value3)
    attr2.checked = true;
  const node = element2("input", attr2);
  el.appendChild(node);
  node.addEventListener("change", () => bind3.update(node.checked));
  bind3.elements = [node];
  bind3.set = (value4) => node.checked = !!value4 || null;
}
function select(bind3, el, param2, value3) {
  const node = element2("select", {
    name: param2.signal
  }), labels = param2.labels || [];
  param2.options.forEach((option, i) => {
    const attr2 = {
      value: option
    };
    if (valuesEqual(option, value3))
      attr2.selected = true;
    node.appendChild(element2("option", attr2, (labels[i] || option) + ""));
  });
  el.appendChild(node);
  node.addEventListener("change", () => {
    bind3.update(param2.options[node.selectedIndex]);
  });
  bind3.elements = [node];
  bind3.set = (value4) => {
    for (let i = 0, n = param2.options.length; i < n; ++i) {
      if (valuesEqual(param2.options[i], value4)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
function radio(bind3, el, param2, value3) {
  const group2 = element2("span", {
    "class": RadioClass
  }), labels = param2.labels || [];
  el.appendChild(group2);
  bind3.elements = param2.options.map((option, i) => {
    const attr2 = {
      type: "radio",
      name: param2.signal,
      value: option
    };
    if (valuesEqual(option, value3))
      attr2.checked = true;
    const input = element2("input", attr2);
    input.addEventListener("change", () => bind3.update(option));
    const label = element2("label", {}, (labels[i] || option) + "");
    label.prepend(input);
    group2.appendChild(label);
    return input;
  });
  bind3.set = (value4) => {
    const nodes = bind3.elements, n = nodes.length;
    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value4))
        nodes[i].checked = true;
    }
  };
}
function range3(bind3, el, param2, value3) {
  value3 = value3 !== void 0 ? value3 : (+param2.max + +param2.min) / 2;
  const max4 = param2.max != null ? param2.max : Math.max(100, +value3) || 100, min4 = param2.min || Math.min(0, max4, +value3) || 0, step = param2.step || tickStep(min4, max4, 100);
  const node = element2("input", {
    type: "range",
    name: param2.signal,
    min: min4,
    max: max4,
    step
  });
  node.value = value3;
  const span2 = element2("span", {}, +value3);
  el.appendChild(node);
  el.appendChild(span2);
  const update3 = () => {
    span2.textContent = node.value;
    bind3.update(+node.value);
  };
  node.addEventListener("input", update3);
  node.addEventListener("change", update3);
  bind3.elements = [node];
  bind3.set = (value4) => {
    node.value = value4;
    span2.textContent = value4;
  };
}
function valuesEqual(a2, b2) {
  return a2 === b2 || a2 + "" === b2 + "";
}
function initializeRenderer(view, r, el, constructor, scaleFactor, opt) {
  r = r || new constructor(view.loader());
  return r.initialize(el, width(view), height(view), offset3(view), scaleFactor, opt).background(view.background());
}
function trap(view, fn) {
  return !fn ? null : function() {
    try {
      fn.apply(this, arguments);
    } catch (error2) {
      view.error(error2);
    }
  };
}
function initializeHandler(view, prevHandler, el, constructor) {
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset3(view), view);
  if (prevHandler) {
    prevHandler.handlers().forEach((h2) => {
      handler.on(h2.type, h2.handler);
    });
  }
  return handler;
}
function initialize2(el, elBind) {
  const view = this, type2 = view._renderType, config = view._eventConfig.bind, module2 = renderModule(type2);
  el = view._el = el ? lookup4(view, el, true) : null;
  initializeAria(view);
  if (!module2)
    view.error("Unrecognized renderer type: " + type2);
  const Handler2 = module2.handler || CanvasHandler, Renderer2 = el ? module2.renderer : module2.headless;
  view._renderer = !Renderer2 ? null : initializeRenderer(view, view._renderer, el, Renderer2);
  view._handler = initializeHandler(view, view._handler, el, Handler2);
  view._redraw = true;
  if (el && config !== "none") {
    elBind = elBind ? view._elBind = lookup4(view, elBind, true) : el.appendChild(element2("form", {
      "class": "vega-bindings"
    }));
    view._bind.forEach((_) => {
      if (_.param.element && config !== "container") {
        _.element = lookup4(view, _.param.element, !!_.param.input);
      }
    });
    view._bind.forEach((_) => {
      bind2(view, _.element || elBind, _);
    });
  }
  return view;
}
function lookup4(view, el, clear) {
  if (typeof el === "string") {
    if (typeof document !== "undefined") {
      el = document.querySelector(el);
      if (!el) {
        view.error("Signal bind element not found: " + el);
        return null;
      }
    } else {
      view.error("DOM document instance not found.");
      return null;
    }
  }
  if (el && clear) {
    try {
      el.innerHTML = "";
    } catch (e) {
      el = null;
      view.error(e);
    }
  }
  return el;
}
var number5 = (_) => +_ || 0;
var paddingObject = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function padding(_) {
  return isObject(_) ? {
    top: number5(_.top),
    bottom: number5(_.bottom),
    left: number5(_.left),
    right: number5(_.right)
  } : paddingObject(number5(_));
}
async function renderHeadless(view, type2, scaleFactor, opt) {
  const module2 = renderModule(type2), ctr = module2 && module2.headless;
  if (!ctr)
    error("Unrecognized renderer type: " + type2);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}
async function renderToImageURL(type2, scaleFactor) {
  if (type2 !== RenderType.Canvas && type2 !== RenderType.SVG && type2 !== RenderType.PNG) {
    error("Unrecognized image type: " + type2);
  }
  const r = await renderHeadless(this, type2, scaleFactor);
  return type2 === RenderType.SVG ? toBlobURL(r.svg(), "image/svg+xml") : r.canvas().toDataURL("image/png");
}
function toBlobURL(data3, mime) {
  const blob = new Blob([data3], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}
async function renderToCanvas(scaleFactor, opt) {
  const r = await renderHeadless(this, RenderType.Canvas, scaleFactor, opt);
  return r.canvas();
}
async function renderToSVG(scaleFactor) {
  const r = await renderHeadless(this, RenderType.SVG, scaleFactor);
  return r.svg();
}
function runtime(view, spec, expr2) {
  return context2(view, transforms, functionContext, expr2).parse(spec);
}
function scale4(name2) {
  var scales2 = this._runtime.scales;
  if (!has(scales2, name2)) {
    error("Unrecognized scale or projection: " + name2);
  }
  return scales2[name2].value;
}
var Width = "width";
var Height = "height";
var Padding2 = "padding";
var Skip2 = {
  skip: true
};
function viewWidth(view, width2) {
  var a2 = view.autosize(), p = view.padding();
  return width2 - (a2 && a2.contains === Padding2 ? p.left + p.right : 0);
}
function viewHeight(view, height2) {
  var a2 = view.autosize(), p = view.padding();
  return height2 - (a2 && a2.contains === Padding2 ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals, w2 = s[Width], h2 = s[Height], p = s[Padding2];
  function resetSize() {
    view._autosize = view._resize = 1;
  }
  view._resizeWidth = view.add(null, (_) => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w2
  });
  view._resizeHeight = view.add(null, (_) => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h2
  });
  const resizePadding = view.add(null, resetSize, {
    pad: p
  });
  view._resizeWidth.rank = w2.rank + 1;
  view._resizeHeight.rank = h2.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth2, viewHeight2, width2, height2, origin, auto) {
  this.runAfter((view) => {
    let rerun2 = 0;
    view._autosize = 0;
    if (view.width() !== width2) {
      rerun2 = 1;
      view.signal(Width, width2, Skip2);
      view._resizeWidth.skip(true);
    }
    if (view.height() !== height2) {
      rerun2 = 1;
      view.signal(Height, height2, Skip2);
      view._resizeHeight.skip(true);
    }
    if (view._viewWidth !== viewWidth2) {
      view._resize = 1;
      view._viewWidth = viewWidth2;
    }
    if (view._viewHeight !== viewHeight2) {
      view._resize = 1;
      view._viewHeight = viewHeight2;
    }
    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    }
    if (rerun2)
      view.run("enter");
    if (auto)
      view.runAfter((v) => v.resize());
  }, false, 1);
}
function getState2(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}
function dataTest(name2, data3) {
  return data3.modified && isArray(data3.input.value) && name2.indexOf("_:vega:_");
}
function signalTest(name2, op) {
  return !(name2 === "parent" || op instanceof transforms.proxy);
}
function setState2(state) {
  this.runAsync(null, (v) => {
    v._trigger = false;
    v._runtime.setState(state);
  }, (v) => {
    v._trigger = true;
  });
  return this;
}
function timer3(callback, delay) {
  function tick(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed
    });
  }
  this._timers.push(interval_default(tick, delay));
}
function defaultTooltip2(handler, event2, item, value3) {
  const el = handler.element();
  if (el)
    el.setAttribute("title", formatTooltip(value3));
}
function formatTooltip(value3) {
  return value3 == null ? "" : isArray(value3) ? formatArray(value3) : isObject(value3) && !isDate(value3) ? formatObject(value3) : value3 + "";
}
function formatObject(obj) {
  return Object.keys(obj).map((key2) => {
    const v = obj[key2];
    return key2 + ": " + (isArray(v) ? formatArray(v) : formatValue2(v));
  }).join("\n");
}
function formatArray(value3) {
  return "[" + value3.map(formatValue2).join(", ") + "]";
}
function formatValue2(value3) {
  return isArray(value3) ? "[\u2026]" : isObject(value3) && !isDate(value3) ? "{\u2026}" : value3;
}
function View(spec, options) {
  const view = this;
  options = options || {};
  Dataflow.call(view);
  if (options.loader)
    view.loader(options.loader);
  if (options.logger)
    view.logger(options.logger);
  if (options.logLevel != null)
    view.logLevel(options.logLevel);
  if (options.locale || spec.locale) {
    const loc = extend({}, spec.locale, options.locale);
    view.locale(locale3(loc.number, loc.time));
  }
  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || RenderType.Canvas;
  view._scenegraph = new Scenegraph();
  const root = view._scenegraph.root;
  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip2, view._redraw = true;
  view._handler = new CanvasHandler().scene(root);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = [];
  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor);
  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map((_) => ({
    state: null,
    param: extend({}, _)
  }));
  if (ctx.root)
    ctx.root.set(root);
  root.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root.items));
  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view);
  background2(view);
  cursor(view);
  view.description(spec.description);
  if (options.hover)
    view.hover();
  if (options.container)
    view.initialize(options.container, options.bind);
}
function lookupSignal(view, name2) {
  return has(view._signals, name2) ? view._signals[name2] : error("Unrecognized signal name: " + $(name2));
}
function findOperatorHandler(op, handler) {
  const h2 = (op._targets || []).filter((op2) => op2._update && op2._update.handler === handler);
  return h2.length ? h2[0] : null;
}
function addOperatorListener(view, name2, op, handler) {
  let h2 = findOperatorHandler(op, handler);
  if (!h2) {
    h2 = trap(view, () => handler(name2, op.value));
    h2.handler = handler;
    view.on(op, null, h2);
  }
  return view;
}
function removeOperatorListener(view, op, handler) {
  const h2 = findOperatorHandler(op, handler);
  if (h2)
    op._targets.remove(h2);
  return view;
}
inherits(View, Dataflow, {
  async evaluate(encode2, prerun, postrun) {
    await Dataflow.prototype.evaluate.call(this, encode2, prerun);
    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }
          await this._renderer.renderAsync(this._scenegraph.root);
        }
        this._redraw = false;
      } catch (e) {
        this.error(e);
      }
    }
    if (postrun)
      asyncCallback(this, postrun);
    return this;
  },
  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },
  description(text2) {
    if (arguments.length) {
      const desc = text2 != null ? text2 + "" : null;
      if (desc !== this._desc)
        ariaLabel(this._el, this._desc = desc);
      return this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(name2, value3, options) {
    const op = lookupSignal(this, name2);
    return arguments.length === 1 ? op.value : this.update(op, value3, options);
  },
  width(_) {
    return arguments.length ? this.signal("width", _) : this.signal("width");
  },
  height(_) {
    return arguments.length ? this.signal("height", _) : this.signal("height");
  },
  padding(_) {
    return arguments.length ? this.signal("padding", padding(_)) : padding(this.signal("padding"));
  },
  autosize(_) {
    return arguments.length ? this.signal("autosize", _) : this.signal("autosize");
  },
  background(_) {
    return arguments.length ? this.signal("background", _) : this.signal("background");
  },
  renderer(type2) {
    if (!arguments.length)
      return this._renderType;
    if (!renderModule(type2))
      error("Unrecognized renderer type: " + type2);
    if (type2 !== this._renderType) {
      this._renderType = type2;
      this._resetRenderer();
    }
    return this;
  },
  tooltip(handler) {
    if (!arguments.length)
      return this._tooltip;
    if (handler !== this._tooltip) {
      this._tooltip = handler;
      this._resetRenderer();
    }
    return this;
  },
  loader(loader2) {
    if (!arguments.length)
      return this._loader;
    if (loader2 !== this._loader) {
      Dataflow.prototype.loader.call(this, loader2);
      this._resetRenderer();
    }
    return this;
  },
  resize() {
    this._autosize = 1;
    return this.touch(lookupSignal(this, "autosize"));
  },
  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },
  _resizeView: resizeView,
  addEventListener(type2, handler, options) {
    let callback = handler;
    if (!(options && options.trap === false)) {
      callback = trap(this, handler);
      callback.raw = handler;
    }
    this._handler.on(type2, callback);
    return this;
  },
  removeEventListener(type2, handler) {
    var handlers = this._handler.handlers(type2), i = handlers.length, h2, t;
    while (--i >= 0) {
      t = handlers[i].type;
      h2 = handlers[i].handler;
      if (type2 === t && (handler === h2 || handler === h2.raw)) {
        this._handler.off(t, h2);
        break;
      }
    }
    return this;
  },
  addResizeListener(handler) {
    const l = this._resizeListeners;
    if (l.indexOf(handler) < 0) {
      l.push(handler);
    }
    return this;
  },
  removeResizeListener(handler) {
    var l = this._resizeListeners, i = l.indexOf(handler);
    if (i >= 0) {
      l.splice(i, 1);
    }
    return this;
  },
  addSignalListener(name2, handler) {
    return addOperatorListener(this, name2, lookupSignal(this, name2), handler);
  },
  removeSignalListener(name2, handler) {
    return removeOperatorListener(this, lookupSignal(this, name2), handler);
  },
  addDataListener(name2, handler) {
    return addOperatorListener(this, name2, dataref(this, name2).values, handler);
  },
  removeDataListener(name2, handler) {
    return removeOperatorListener(this, dataref(this, name2).values, handler);
  },
  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null);
        this._globalCursor = !!_;
        if (prev)
          setCursor(this, prev);
      }
      return this;
    } else {
      return this._globalCursor;
    }
  },
  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },
  timer: timer3,
  events: events2,
  finalize,
  hover,
  data: data2,
  change,
  insert,
  remove,
  scale: scale4,
  initialize: initialize2,
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  getState: getState2,
  setState: setState2
});

// node_modules/vega-event-selector/build/vega-event-selector.module.js
var VIEW2 = "view";
var LBRACK = "[";
var RBRACK = "]";
var LBRACE = "{";
var RBRACE = "}";
var COLON = ":";
var COMMA = ",";
var NAME = "@";
var GT = ">";
var ILLEGAL2 = /[[\]{}]/;
var DEFAULT_MARKS = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var DEFAULT_SOURCE;
var MARKS;
function eventSelector(selector, source3, marks) {
  DEFAULT_SOURCE = source3 || VIEW2;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type2) {
  return MARKS[type2];
}
function find3(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count2 = 0, c2;
  for (; i < n; ++i) {
    c2 = s[i];
    if (!count2 && c2 === endChar)
      return i;
    else if (popChar && popChar.indexOf(c2) >= 0)
      --count2;
    else if (pushChar && pushChar.indexOf(c2) >= 0)
      ++count2;
  }
  return i;
}
function parseMerge(s) {
  const output3 = [], n = s.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find3(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output3.push(s.substring(start, i).trim());
    start = ++i;
  }
  if (output3.length === 0) {
    throw "Empty event selector: " + s;
  }
  return output3;
}
function parseSelector(s) {
  return s[0] === "[" ? parseBetween(s) : parseStream2(s);
}
function parseBetween(s) {
  const n = s.length;
  let i = 1, b2;
  i = find3(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw "Empty between selector: " + s;
  }
  b2 = parseMerge(s.substring(1, i));
  if (b2.length !== 2) {
    throw "Between selector must have two elements: " + s;
  }
  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw "Expected '>' after between selector: " + s;
  }
  b2 = b2.map(parseSelector);
  const stream2 = parseSelector(s.slice(1).trim());
  if (stream2.between) {
    return {
      between: b2,
      stream: stream2
    };
  } else {
    stream2.between = b2;
  }
  return stream2;
}
function parseStream2(s) {
  const stream2 = {
    source: DEFAULT_SOURCE
  }, source3 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s.length, i = 0, j, filter3;
  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e) {
        throw "Invalid throttle specification: " + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else
      throw "Unmatched right brace: " + s;
    i = 0;
  }
  if (!n)
    throw s;
  if (s[0] === NAME)
    markname = ++i;
  j = find3(s, i, COLON);
  if (j < n) {
    source3.push(s.substring(start, j).trim());
    start = i = ++j;
  }
  i = find3(s, i, LBRACK);
  if (i === n) {
    source3.push(s.substring(start, n).trim());
  } else {
    source3.push(s.substring(start, i).trim());
    filter3 = [];
    start = ++i;
    if (start === n)
      throw "Unmatched left bracket: " + s;
  }
  while (i < n) {
    i = find3(s, i, RBRACK);
    if (i === n)
      throw "Unmatched left bracket: " + s;
    filter3.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK)
      throw "Expected left bracket: " + s;
    start = ++i;
  }
  if (!(n = source3.length) || ILLEGAL2.test(source3[n - 1])) {
    throw "Invalid event selector: " + s;
  }
  if (n > 1) {
    stream2.type = source3[1];
    if (markname) {
      stream2.markname = source3[0].slice(1);
    } else if (isMarkType(source3[0])) {
      stream2.marktype = source3[0];
    } else {
      stream2.source = source3[0];
    }
  } else {
    stream2.type = source3[0];
  }
  if (stream2.type.slice(-1) === "!") {
    stream2.consume = true;
    stream2.type = stream2.type.slice(0, -1);
  }
  if (filter3 != null)
    stream2.filter = filter3;
  if (throttle[0])
    stream2.throttle = throttle[0];
  if (throttle[1])
    stream2.debounce = throttle[1];
  return stream2;
}
function parseThrottle(s) {
  const a2 = s.split(COMMA);
  if (!s.length || a2.length > 2)
    throw s;
  return a2.map((_) => {
    const x5 = +_;
    if (x5 !== x5)
      throw s;
    return x5;
  });
}

// node_modules/vega-parser/build/vega-parser.module.js
function parseAutosize(spec) {
  return isObject(spec) ? spec : {
    type: spec || "pad"
  };
}
var number6 = (_) => +_ || 0;
var paddingObject2 = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function parsePadding(spec) {
  return !isObject(spec) ? paddingObject2(number6(spec)) : spec.signal ? spec : {
    top: number6(spec.top),
    bottom: number6(spec.bottom),
    left: number6(spec.left),
    right: number6(spec.right)
  };
}
var encoder = (_) => isObject(_) && !isArray(_) ? extend({}, _) : {
  value: _
};
function addEncode(object2, name2, value3, set5) {
  if (value3 != null) {
    const isEncoder = isObject(value3) && !isArray(value3) || isArray(value3) && value3.length && isObject(value3[0]);
    if (isEncoder) {
      object2.update[name2] = value3;
    } else {
      object2[set5 || "enter"][name2] = {
        value: value3
      };
    }
    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object2, enter, update3) {
  for (const name2 in enter) {
    addEncode(object2, name2, enter[name2]);
  }
  for (const name2 in update3) {
    addEncode(object2, name2, update3[name2], "update");
  }
}
function extendEncode(encode2, extra, skip) {
  for (const name2 in extra) {
    if (skip && has(skip, name2))
      continue;
    encode2[name2] = extend(encode2[name2] || {}, extra[name2]);
  }
  return encode2;
}
function has2(key2, encode2) {
  return encode2 && (encode2.enter && encode2.enter[key2] || encode2.update && encode2.update[key2]);
}
var MarkRole = "mark";
var FrameRole2 = "frame";
var ScopeRole2 = "scope";
var AxisRole2 = "axis";
var AxisDomainRole = "axis-domain";
var AxisGridRole = "axis-grid";
var AxisLabelRole = "axis-label";
var AxisTickRole = "axis-tick";
var AxisTitleRole = "axis-title";
var LegendRole2 = "legend";
var LegendBandRole = "legend-band";
var LegendEntryRole = "legend-entry";
var LegendGradientRole = "legend-gradient";
var LegendLabelRole = "legend-label";
var LegendSymbolRole = "legend-symbol";
var LegendTitleRole = "legend-title";
var TitleRole2 = "title";
var TitleTextRole = "title-text";
var TitleSubtitleRole = "title-subtitle";
function applyDefaults(encode2, type2, role, style2, config) {
  const defaults2 = {}, enter = {};
  let update3, key2, skip, props;
  key2 = "lineBreak";
  if (type2 === "text" && config[key2] != null && !has2(key2, encode2)) {
    applyDefault(defaults2, key2, config[key2]);
  }
  if (role == "legend" || String(role).startsWith("axis")) {
    role = null;
  }
  props = role === FrameRole2 ? config.group : role === MarkRole ? extend({}, config.mark, config[type2]) : null;
  for (key2 in props) {
    skip = has2(key2, encode2) || (key2 === "fill" || key2 === "stroke") && (has2("fill", encode2) || has2("stroke", encode2));
    if (!skip)
      applyDefault(defaults2, key2, props[key2]);
  }
  array(style2).forEach((name2) => {
    const props2 = config.style && config.style[name2];
    for (const key3 in props2) {
      if (!has2(key3, encode2)) {
        applyDefault(defaults2, key3, props2[key3]);
      }
    }
  });
  encode2 = extend({}, encode2);
  for (key2 in defaults2) {
    props = defaults2[key2];
    if (props.signal) {
      (update3 = update3 || {})[key2] = props;
    } else {
      enter[key2] = props;
    }
  }
  encode2.enter = extend(enter, encode2.enter);
  if (update3)
    encode2.update = extend(update3, encode2.update);
  return encode2;
}
function applyDefault(defaults2, key2, value3) {
  defaults2[key2] = value3 && value3.signal ? {
    signal: value3.signal
  } : {
    value: value3
  };
}
var scaleRef = (scale6) => isString(scale6) ? $(scale6) : scale6.signal ? "(".concat(scale6.signal, ")") : field2(scale6);
function entry(enc) {
  if (enc.gradient != null) {
    return gradient2(enc);
  }
  let value3 = enc.signal ? "(".concat(enc.signal, ")") : enc.color ? color6(enc.color) : enc.field != null ? field2(enc.field) : enc.value !== void 0 ? $(enc.value) : void 0;
  if (enc.scale != null) {
    value3 = scale5(enc, value3);
  }
  if (value3 === void 0) {
    value3 = null;
  }
  if (enc.exponent != null) {
    value3 = "pow(".concat(value3, ",").concat(property(enc.exponent), ")");
  }
  if (enc.mult != null) {
    value3 += "*".concat(property(enc.mult));
  }
  if (enc.offset != null) {
    value3 += "+".concat(property(enc.offset));
  }
  if (enc.round) {
    value3 = "round(".concat(value3, ")");
  }
  return value3;
}
var _color = (type2, x5, y5, z) => "(".concat(type2, "(").concat([x5, y5, z].map(entry).join(","), ")+'')");
function color6(enc) {
  return enc.c ? _color("hcl", enc.h, enc.c, enc.l) : enc.h || enc.s ? _color("hsl", enc.h, enc.s, enc.l) : enc.l || enc.a ? _color("lab", enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color("rgb", enc.r, enc.g, enc.b) : null;
}
function gradient2(enc) {
  const args = [enc.start, enc.stop, enc.count].map((_) => _ == null ? null : $(_));
  while (args.length && peek(args) == null)
    args.pop();
  args.unshift(scaleRef(enc.gradient));
  return "gradient(".concat(args.join(","), ")");
}
function property(property2) {
  return isObject(property2) ? "(" + entry(property2) + ")" : property2;
}
function field2(ref2) {
  return resolveField(isObject(ref2) ? ref2 : {
    datum: ref2
  });
}
function resolveField(ref2) {
  let object2, level, field3;
  if (ref2.signal) {
    object2 = "datum";
    field3 = ref2.signal;
  } else if (ref2.group || ref2.parent) {
    level = Math.max(1, ref2.level || 1);
    object2 = "item";
    while (level-- > 0) {
      object2 += ".mark.group";
    }
    if (ref2.parent) {
      field3 = ref2.parent;
      object2 += ".datum";
    } else {
      field3 = ref2.group;
    }
  } else if (ref2.datum) {
    object2 = "datum";
    field3 = ref2.datum;
  } else {
    error("Invalid field reference: " + $(ref2));
  }
  if (!ref2.signal) {
    field3 = isString(field3) ? splitAccessPath(field3).map($).join("][") : resolveField(field3);
  }
  return object2 + "[" + field3 + "]";
}
function scale5(enc, value3) {
  const scale6 = scaleRef(enc.scale);
  if (enc.range != null) {
    value3 = "lerp(_range(".concat(scale6, "), ").concat(+enc.range, ")");
  } else {
    if (value3 !== void 0)
      value3 = "_scale(".concat(scale6, ", ").concat(value3, ")");
    if (enc.band) {
      value3 = (value3 ? value3 + "+" : "") + "_bandwidth(".concat(scale6, ")") + (+enc.band === 1 ? "" : "*" + property(enc.band));
      if (enc.extra) {
        value3 = "(datum.extra ? _scale(".concat(scale6, ", datum.extra.value) : ").concat(value3, ")");
      }
    }
    if (value3 == null)
      value3 = "0";
  }
  return value3;
}
function rule2(enc) {
  let code = "";
  enc.forEach((rule3) => {
    const value3 = entry(rule3);
    code += rule3.test ? "(".concat(rule3.test, ")?").concat(value3, ":") : value3;
  });
  if (peek(code) === ":") {
    code += "null";
  }
  return code;
}
function parseEncode(encode2, type2, role, style2, scope, params2) {
  const enc = {};
  params2 = params2 || {};
  params2.encoders = {
    $encode: enc
  };
  encode2 = applyDefaults(encode2, type2, role, style2, scope.config);
  for (const key2 in encode2) {
    enc[key2] = parseBlock(encode2[key2], type2, params2, scope);
  }
  return params2;
}
function parseBlock(block, marktype, params2, scope) {
  const channels = {}, fields = {};
  for (const name2 in block) {
    if (block[name2] != null) {
      channels[name2] = parse5(expr(block[name2]), scope, params2, fields);
    }
  }
  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}
function expr(enc) {
  return isArray(enc) ? rule2(enc) : entry(enc);
}
function parse5(code, scope, params2, fields) {
  const expr2 = parser2(code, scope);
  expr2.$fields.forEach((name2) => fields[name2] = 1);
  extend(params2, expr2.$params);
  return expr2.$expr;
}
var OUTER = "outer";
var OUTER_INVALID = ["value", "update", "init", "react", "bind"];
function outerError(prefix, name2) {
  error(prefix + ' for "outer" push: ' + $(name2));
}
function parseSignal(signal, scope) {
  const name2 = signal.name;
  if (signal.push === OUTER) {
    if (!scope.signals[name2])
      outerError("No prior signal definition", name2);
    OUTER_INVALID.forEach((prop) => {
      if (signal[prop] !== void 0)
        outerError("Invalid property ", prop);
    });
  } else {
    const op = scope.addSignal(name2, signal.value);
    if (signal.react === false)
      op.react = false;
    if (signal.bind)
      scope.addBinding(name2, signal.bind);
  }
}
function Entry(type2, value3, params2, parent) {
  this.id = -1;
  this.type = type2;
  this.value = value3;
  this.params = params2;
  if (parent)
    this.parent = parent;
}
function entry$1(type2, value3, params2, parent) {
  return new Entry(type2, value3, params2, parent);
}
function operator(value3, params2) {
  return entry$1("operator", value3, params2);
}
function ref(op) {
  const ref2 = {
    $ref: op.id
  };
  if (op.id < 0)
    (op.refs = op.refs || []).push(ref2);
  return ref2;
}
function fieldRef(field3, name2) {
  return name2 ? {
    $field: field3,
    $name: name2
  } : {
    $field: field3
  };
}
var keyFieldRef = fieldRef("key");
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref2 = {
    $key: fields
  };
  if (flat)
    ref2.$flat = true;
  return ref2;
}
var Ascending = "ascending";
var Descending = "descending";
function sortKey(sort2) {
  return !isObject(sort2) ? "" : (sort2.order === Descending ? "-" : "+") + aggrField(sort2.op, sort2.field);
}
function aggrField(op, field3) {
  return (op && op.signal ? "$" + op.signal : op || "") + (op && field3 ? "_" : "") + (field3 && field3.signal ? "$" + field3.signal : field3 || "");
}
var Scope = "scope";
var View2 = "view";
function isSignal(_) {
  return _ && _.signal;
}
function isExpr(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_))
    return true;
  if (isObject(_))
    for (const key2 in _) {
      if (hasSignal(_[key2]))
        return true;
    }
  return false;
}
function value2(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}
var Timer3 = "timer";
function parseStream3(stream2, scope) {
  const method2 = stream2.merge ? mergeStream : stream2.stream ? nestedStream : stream2.type ? eventStream : error("Invalid stream specification: " + $(stream2));
  return method2(stream2, scope);
}
function eventSource(source3) {
  return source3 === Scope ? View2 : source3 || View2;
}
function mergeStream(stream2, scope) {
  const list = stream2.merge.map((s) => parseStream3(s, scope)), entry2 = streamParameters({
    merge: list
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function nestedStream(stream2, scope) {
  const id2 = parseStream3(stream2.stream, scope), entry2 = streamParameters({
    stream: id2
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function eventStream(stream2, scope) {
  let id2;
  if (stream2.type === Timer3) {
    id2 = scope.event(Timer3, stream2.throttle);
    stream2 = {
      between: stream2.between,
      filter: stream2.filter
    };
  } else {
    id2 = scope.event(eventSource(stream2.source), stream2.type);
  }
  const entry2 = streamParameters({
    stream: id2
  }, stream2, scope);
  return Object.keys(entry2).length === 1 ? id2 : scope.addStream(entry2).id;
}
function streamParameters(entry2, stream2, scope) {
  let param2 = stream2.between;
  if (param2) {
    if (param2.length !== 2) {
      error('Stream "between" parameter must have 2 entries: ' + $(stream2));
    }
    entry2.between = [parseStream3(param2[0], scope), parseStream3(param2[1], scope)];
  }
  param2 = stream2.filter ? [].concat(stream2.filter) : [];
  if (stream2.marktype || stream2.markname || stream2.markrole) {
    param2.push(filterMark(stream2.marktype, stream2.markname, stream2.markrole));
  }
  if (stream2.source === Scope) {
    param2.push("inScope(event.item)");
  }
  if (param2.length) {
    entry2.filter = parser2("(" + param2.join(")&&(") + ")", scope).$expr;
  }
  if ((param2 = stream2.throttle) != null) {
    entry2.throttle = +param2;
  }
  if ((param2 = stream2.debounce) != null) {
    entry2.debounce = +param2;
  }
  if (stream2.consume) {
    entry2.consume = true;
  }
  return entry2;
}
function filterMark(type2, name2, role) {
  const item = "event.item";
  return item + (type2 && type2 !== "*" ? "&&" + item + ".mark.marktype==='" + type2 + "'" : "") + (role ? "&&" + item + ".mark.role==='" + role + "'" : "") + (name2 ? "&&" + item + ".mark.name==='" + name2 + "'" : "");
}
var OP_VALUE_EXPR = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function parseUpdate2(spec, scope, target2) {
  const encode2 = spec.encode, entry2 = {
    target: target2
  };
  let events3 = spec.events, update3 = spec.update, sources = [];
  if (!events3) {
    error("Signal update missing events specification.");
  }
  if (isString(events3)) {
    events3 = eventSelector(events3, scope.isSubscope() ? Scope : View2);
  }
  events3 = array(events3).filter((s) => s.signal || s.scale ? (sources.push(s), 0) : 1);
  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  }
  if (events3.length) {
    sources.push(events3.length > 1 ? {
      merge: events3
    } : events3[0]);
  }
  if (encode2 != null) {
    if (update3)
      error("Signal encode and update are mutually exclusive.");
    update3 = "encode(item()," + $(encode2) + ")";
  }
  entry2.update = isString(update3) ? parser2(update3, scope) : update3.expr != null ? parser2(update3.expr, scope) : update3.value != null ? update3.value : update3.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update3.signal)
    }
  } : error("Invalid signal update specification.");
  if (spec.force) {
    entry2.options = {
      force: true
    };
  }
  sources.forEach((source3) => scope.addUpdate(extend(streamSource(source3, scope), entry2)));
}
function streamSource(stream2, scope) {
  return {
    source: stream2.signal ? scope.signalRef(stream2.signal) : stream2.scale ? scope.scaleRef(stream2.scale) : parseStream3(stream2, scope)
  };
}
function mergeSources(sources) {
  return {
    signal: "[" + sources.map((s) => s.scale ? 'scale("' + s.scale + '")' : s.signal) + "]"
  };
}
function parseSignalUpdates(signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr2 = signal.update;
  if (signal.init) {
    if (expr2) {
      error("Signals can not include both init and update expressions.");
    } else {
      expr2 = signal.init;
      op.initonly = true;
    }
  }
  if (expr2) {
    expr2 = parser2(expr2, scope);
    op.update = expr2.$expr;
    op.params = expr2.$params;
  }
  if (signal.on) {
    signal.on.forEach((_) => parseUpdate2(_, scope, op.id));
  }
}
var transform3 = (name2) => (params2, value3, parent) => entry$1(name2, value3, params2 || void 0, parent);
var Aggregate2 = transform3("aggregate");
var AxisTicks2 = transform3("axisticks");
var Bound2 = transform3("bound");
var Collect2 = transform3("collect");
var Compare2 = transform3("compare");
var DataJoin2 = transform3("datajoin");
var Encode2 = transform3("encode");
var Expression2 = transform3("expression");
var Facet2 = transform3("facet");
var Field2 = transform3("field");
var Key2 = transform3("key");
var LegendEntries2 = transform3("legendentries");
var Load2 = transform3("load");
var Mark2 = transform3("mark");
var MultiExtent2 = transform3("multiextent");
var MultiValues2 = transform3("multivalues");
var Overlap2 = transform3("overlap");
var Params3 = transform3("params");
var PreFacet2 = transform3("prefacet");
var Projection2 = transform3("projection");
var Proxy2 = transform3("proxy");
var Relay2 = transform3("relay");
var Render2 = transform3("render");
var Scale2 = transform3("scale");
var Sieve2 = transform3("sieve");
var SortItems2 = transform3("sortitems");
var ViewLayout2 = transform3("viewlayout");
var Values2 = transform3("values");
var FIELD_REF_ID = 0;
var MULTIDOMAIN_SORT_OPS = {
  min: "min",
  max: "max",
  count: "sum"
};
function initScale(spec, scope) {
  const type2 = spec.type || "linear";
  if (!isValidScaleType(type2)) {
    error("Unrecognized scale type: " + $(type2));
  }
  scope.addScale(spec.name, {
    type: type2,
    domain: void 0
  });
}
function parseScale(spec, scope) {
  const params2 = scope.getScale(spec.name).params;
  let key2;
  params2.domain = parseScaleDomain(spec.domain, spec, scope);
  if (spec.range != null) {
    params2.range = parseScaleRange(spec, scope, params2);
  }
  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params2);
  }
  if (spec.nice != null) {
    params2.nice = parseScaleNice(spec.nice);
  }
  if (spec.bins != null) {
    params2.bins = parseScaleBins(spec.bins, scope);
  }
  for (key2 in spec) {
    if (has(params2, key2) || key2 === "name")
      continue;
    params2[key2] = parseLiteral(spec[key2], scope);
  }
}
function parseLiteral(v, scope) {
  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error("Unsupported object: " + $(v));
}
function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map((v2) => parseLiteral(v2, scope));
}
function dataLookupError(name2) {
  error("Can not find data set: " + $(name2));
}
function parseScaleDomain(domain2, spec, scope) {
  if (!domain2) {
    if (spec.domainMin != null || spec.domainMax != null) {
      error("No scale domain defined for domainMin/domainMax to override.");
    }
    return;
  }
  return domain2.signal ? scope.signalRef(domain2.signal) : (isArray(domain2) ? explicitDomain : domain2.fields ? multipleDomain : singularDomain)(domain2, spec, scope);
}
function explicitDomain(domain2, spec, scope) {
  return domain2.map((v) => parseLiteral(v, scope));
}
function singularDomain(domain2, spec, scope) {
  const data3 = scope.getData(domain2.data);
  if (!data3)
    dataLookupError(domain2.data);
  return isDiscrete(spec.type) ? data3.valuesRef(scope, domain2.field, parseSort(domain2.sort, false)) : isQuantile(spec.type) ? data3.domainRef(scope, domain2.field) : data3.extentRef(scope, domain2.field);
}
function multipleDomain(domain2, spec, scope) {
  const data3 = domain2.data, fields = domain2.fields.reduce((dom, d) => {
    d = isString(d) ? {
      data: data3,
      field: d
    } : isArray(d) || d.signal ? fieldRef$1(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain2, scope, fields);
}
function fieldRef$1(data3, scope) {
  const name2 = "_:vega:_" + FIELD_REF_ID++, coll = Collect2({});
  if (isArray(data3)) {
    coll.value = {
      $ingest: data3
    };
  } else if (data3.signal) {
    const code = "setdata(" + $(name2) + "," + data3.signal + ")";
    coll.params.input = scope.signalRef(code);
  }
  scope.addDataPipeline(name2, [coll, Sieve2({})]);
  return {
    data: name2,
    field: "data"
  };
}
function ordinalMultipleDomain(domain2, scope, fields) {
  const sort2 = parseSort(domain2.sort, true);
  let a2, v;
  const counts = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.countsRef(scope, f.field, sort2);
  });
  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };
  if (sort2) {
    a2 = sort2.op || "count";
    v = sort2.field ? aggrField(a2, sort2.field) : "count";
    p.ops = [MULTIDOMAIN_SORT_OPS[a2]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }
  a2 = scope.add(Aggregate2(p));
  const c2 = scope.add(Collect2({
    pulse: ref(a2)
  }));
  v = scope.add(Values2({
    field: keyFieldRef,
    sort: scope.sortRef(sort2),
    pulse: ref(c2)
  }));
  return ref(v);
}
function parseSort(sort2, multidomain) {
  if (sort2) {
    if (!sort2.field && !sort2.op) {
      if (isObject(sort2))
        sort2.field = "key";
      else
        sort2 = {
          field: "key"
        };
    } else if (!sort2.field && sort2.op !== "count") {
      error("No field provided for sort aggregate op: " + sort2.op);
    } else if (multidomain && sort2.field) {
      if (sort2.op && !MULTIDOMAIN_SORT_OPS[sort2.op]) {
        error("Multiple domain scales can not be sorted using " + sort2.op);
      }
    }
  }
  return sort2;
}
function quantileMultipleDomain(domain2, scope, fields) {
  const values2 = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.domainRef(scope, f.field);
  });
  return ref(scope.add(MultiValues2({
    values: values2
  })));
}
function numericMultipleDomain(domain2, scope, fields) {
  const extents = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.extentRef(scope, f.field);
  });
  return ref(scope.add(MultiExtent2({
    extents
  })));
}
function parseScaleBins(v, scope) {
  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);
}
function parseScaleNice(nice2) {
  return isObject(nice2) ? {
    interval: parseLiteral(nice2.interval),
    step: parseLiteral(nice2.step)
  } : parseLiteral(nice2);
}
function parseScaleInterpolate(interpolate2, params2) {
  params2.interpolate = parseLiteral(interpolate2.type || interpolate2);
  if (interpolate2.gamma != null) {
    params2.interpolateGamma = parseLiteral(interpolate2.gamma);
  }
}
function parseScaleRange(spec, scope, params2) {
  const config = scope.config.range;
  let range4 = spec.range;
  if (range4.signal) {
    return scope.signalRef(range4.signal);
  } else if (isString(range4)) {
    if (config && has(config, range4)) {
      spec = extend({}, spec, {
        range: config[range4]
      });
      return parseScaleRange(spec, scope, params2);
    } else if (range4 === "width") {
      range4 = [0, {
        signal: "width"
      }];
    } else if (range4 === "height") {
      range4 = isDiscrete(spec.type) ? [0, {
        signal: "height"
      }] : [{
        signal: "height"
      }, 0];
    } else {
      error("Unrecognized scale range value: " + $(range4));
    }
  } else if (range4.scheme) {
    params2.scheme = isArray(range4.scheme) ? parseArray(range4.scheme, scope) : parseLiteral(range4.scheme, scope);
    if (range4.extent)
      params2.schemeExtent = parseArray(range4.extent, scope);
    if (range4.count)
      params2.schemeCount = parseLiteral(range4.count, scope);
    return;
  } else if (range4.step) {
    params2.rangeStep = parseLiteral(range4.step, scope);
    return;
  } else if (isDiscrete(spec.type) && !isArray(range4)) {
    return parseScaleDomain(range4, spec, scope);
  } else if (!isArray(range4)) {
    error("Unsupported range type: " + $(range4));
  }
  return range4.map((v) => (isArray(v) ? parseArray : parseLiteral)(v, scope));
}
function parseProjection(proj, scope) {
  const config = scope.config.projection || {}, params2 = {};
  for (const name2 in proj) {
    if (name2 === "name")
      continue;
    params2[name2] = parseParameter2(proj[name2], name2, scope);
  }
  for (const name2 in config) {
    if (params2[name2] == null) {
      params2[name2] = parseParameter2(config[name2], name2, scope);
    }
  }
  scope.addProjection(proj.name, params2);
}
function parseParameter2(_, name2, scope) {
  return isArray(_) ? _.map((_2) => parseParameter2(_2, name2, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name2 === "fit" ? _ : error("Unsupported parameter object: " + $(_));
}
var Top2 = "top";
var Left2 = "left";
var Right2 = "right";
var Bottom2 = "bottom";
var Center2 = "center";
var Vertical = "vertical";
var Start2 = "start";
var Middle2 = "middle";
var End2 = "end";
var Index = "index";
var Label2 = "label";
var Offset = "offset";
var Perc = "perc";
var Perc2 = "perc2";
var Value = "value";
var GuideLabelStyle = "guide-label";
var GuideTitleStyle = "guide-title";
var GroupTitleStyle = "group-title";
var GroupSubtitleStyle = "group-subtitle";
var Symbols2 = "symbol";
var Gradient2 = "gradient";
var Discrete2 = "discrete";
var Size = "size";
var Shape = "shape";
var Fill = "fill";
var Stroke = "stroke";
var StrokeWidth = "strokeWidth";
var StrokeDash = "strokeDash";
var Opacity = "opacity";
var LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
var Skip3 = {
  name: 1,
  style: 1,
  interactive: 1
};
var zero4 = {
  value: 0
};
var one4 = {
  value: 1
};
var GroupMark = "group";
var RectMark = "rect";
var RuleMark = "rule";
var SymbolMark = "symbol";
var TextMark = "text";
function guideGroup(mark) {
  mark.type = GroupMark;
  mark.interactive = mark.interactive || false;
  return mark;
}
function lookup5(spec, config) {
  const _ = (name2, dflt) => value2(spec[name2], value2(config[name2], dflt));
  _.isVertical = (s) => Vertical === value2(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));
  _.gradientLength = () => value2(spec.gradientLength, config.gradientLength || config.gradientWidth);
  _.gradientThickness = () => value2(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
  _.entryColumns = () => value2(spec.columns, value2(config.columns, +_.isVertical(true)));
  return _;
}
function getEncoding(name2, encode2) {
  const v = encode2 && (encode2.update && encode2.update[name2] || encode2.enter && encode2.enter[name2]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name2, scope, style2) {
  const s = scope.config.style[style2];
  return s && s[name2];
}
function anchorExpr(s, e, m2) {
  return "item.anchor === '".concat(Start2, "' ? ").concat(s, " : item.anchor === '").concat(End2, "' ? ").concat(e, " : ").concat(m2);
}
var alignExpr = anchorExpr($(Left2), $(Right2), $(Center2));
function tickBand(_) {
  const v = _("tickBand");
  let offset4 = _("tickOffset"), band2, extra;
  if (!v) {
    band2 = _("bandPosition");
    extra = _("tickExtra");
  } else if (v.signal) {
    band2 = {
      signal: "(".concat(v.signal, ") === 'extent' ? 1 : 0.5")
    };
    extra = {
      signal: "(".concat(v.signal, ") === 'extent'")
    };
    if (!isObject(offset4)) {
      offset4 = {
        signal: "(".concat(v.signal, ") === 'extent' ? 0 : ").concat(offset4)
      };
    }
  } else if (v === "extent") {
    band2 = 1;
    extra = true;
    offset4 = 0;
  } else {
    band2 = 0.5;
    extra = false;
  }
  return {
    extra,
    band: band2,
    offset: offset4
  };
}
function extendOffset(value3, offset4) {
  return !offset4 ? value3 : !value3 ? offset4 : !isObject(value3) ? {
    value: value3,
    offset: offset4
  } : Object.assign({}, value3, {
    offset: extendOffset(value3.offset, offset4)
  });
}
function guideMark(mark, extras) {
  if (extras) {
    mark.name = extras.name;
    mark.style = extras.style || mark.style;
    mark.interactive = !!extras.interactive;
    mark.encode = extendEncode(mark.encode, extras, Skip3);
  } else {
    mark.interactive = false;
  }
  return mark;
}
function legendGradient(spec, scale6, config, userEncode) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
  let enter, start, stop2, width2, height2;
  if (vertical) {
    start = [0, 1];
    stop2 = [0, 0];
    width2 = thickness;
    height2 = length2;
  } else {
    start = [0, 0];
    stop2 = [1, 0];
    width2 = length2;
    height2 = thickness;
  }
  const encode2 = {
    enter: enter = {
      opacity: zero4,
      x: zero4,
      y: zero4,
      width: encoder(width2),
      height: encoder(height2)
    },
    update: extend({}, enter, {
      opacity: one4,
      fill: {
        gradient: scale6,
        start,
        stop: stop2
      }
    }),
    exit: {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode: encode2
  }, userEncode);
}
function legendGradientDiscrete(spec, scale6, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
  let u, v, uu, vv, adjust = "";
  vertical ? (u = "y", uu = "y2", v = "x", vv = "width", adjust = "1-") : (u = "x", uu = "x2", v = "y", vv = "height");
  const enter = {
    opacity: zero4,
    fill: {
      scale: scale6,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + "datum." + Perc,
    mult: length2
  };
  enter[v] = zero4;
  enter[uu] = {
    signal: adjust + "datum." + Perc2,
    mult: length2
  };
  enter[vv] = encoder(thickness);
  const encode2 = {
    enter,
    update: extend({}, enter, {
      opacity: one4
    }),
    exit: {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
var alignExpr$1 = "datum.".concat(Perc, '<=0?"').concat(Left2, '":datum.').concat(Perc, '>=1?"').concat(Right2, '":"').concat(Center2, '"');
var baselineExpr = "datum.".concat(Perc, '<=0?"').concat(Bottom2, '":datum.').concat(Perc, '>=1?"').concat(Top2, '":"').concat(Middle2, '"');
function legendGradientLabels(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = encoder(_.gradientThickness()), length2 = _.gradientLength();
  let overlap = _("labelOverlap"), enter, update3, u, v, adjust = "";
  const encode2 = {
    enter: enter = {
      opacity: zero4
    },
    update: update3 = {
      opacity: one4,
      text: {
        field: Label2
      }
    },
    exit: {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: value2(spec.labelLimit, config.gradientLabelLimit)
  });
  if (vertical) {
    enter.align = {
      value: "left"
    };
    enter.baseline = update3.baseline = {
      signal: baselineExpr
    };
    u = "y";
    v = "x";
    adjust = "1-";
  } else {
    enter.align = update3.align = {
      signal: alignExpr$1
    };
    enter.baseline = {
      value: "top"
    };
    u = "x";
    v = "y";
  }
  enter[u] = update3[u] = {
    signal: adjust + "datum." + Perc,
    mult: length2
  };
  enter[v] = update3[v] = thickness;
  thickness.offset = value2(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum." + Index
  } : void 0;
  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {
  const _ = lookup5(spec, config), entries = userEncode.entries, interactive2 = !!(entries && entries.interactive), name2 = entries ? entries.name : void 0, height2 = _("clipHeight"), symbolOffset = _("symbolOffset"), valueRef = {
    data: "value"
  }, xSignal = "(".concat(columns, ") ? datum.").concat(Offset, " : datum.").concat(Size), yEncode = height2 ? encoder(height2) : {
    field: Size
  }, index3 = "datum.".concat(Index), ncols = "max(1, ".concat(columns, ")");
  let encode2, enter, update3, nrows, sort2;
  yEncode.mult = 0.5;
  encode2 = {
    enter: enter = {
      opacity: zero4,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one4,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero4
    }
  };
  let baseFill = null, baseStroke = null;
  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }
  addEncoders(encode2, {
    fill: _("symbolFillColor", baseFill),
    shape: _("symbolType"),
    size: _("symbolSize"),
    stroke: _("symbolStrokeColor", baseStroke),
    strokeDash: _("symbolDash"),
    strokeDashOffset: _("symbolDashOffset"),
    strokeWidth: _("symbolStrokeWidth")
  }, {
    opacity: _("symbolOpacity")
  });
  LegendScales.forEach((scale6) => {
    if (spec[scale6]) {
      update3[scale6] = enter[scale6] = {
        scale: spec[scale6],
        field: Value
      };
    }
  });
  const symbols4 = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height2 ? true : void 0,
    encode: encode2
  }, userEncode.symbols);
  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _("labelOffset");
  encode2 = {
    enter: enter = {
      opacity: zero4,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one4,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    align: _("labelAlign"),
    baseline: _("labelBaseline"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: _("labelLimit")
  });
  const labels = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode: encode2
  }, userEncode.labels);
  encode2 = {
    enter: {
      noBound: {
        value: !height2
      },
      width: zero4,
      height: height2 ? encoder(height2) : zero4,
      opacity: zero4
    },
    exit: {
      opacity: zero4
    },
    update: update3 = {
      opacity: one4,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  };
  if (_.isVertical(true)) {
    nrows = "ceil(item.mark.items.length / ".concat(ncols, ")");
    update3.row.signal = "".concat(index3, "%").concat(nrows);
    update3.column.signal = "floor(".concat(index3, " / ").concat(nrows, ")");
    sort2 = {
      field: ["row", index3]
    };
  } else {
    update3.row.signal = "floor(".concat(index3, " / ").concat(ncols, ")");
    update3.column.signal = "".concat(index3, " % ").concat(ncols);
    sort2 = {
      field: index3
    };
  }
  update3.column.signal = "(".concat(columns, ")?").concat(update3.column.signal, ":").concat(index3);
  dataRef = {
    facet: {
      data: dataRef,
      name: "value",
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole2,
    from: dataRef,
    encode: extendEncode(encode2, entries, Skip3),
    marks: [symbols4, labels],
    name: name2,
    interactive: interactive2,
    sort: sort2
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup5(spec, config);
  return {
    align: _("gridAlign"),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _("rowPadding"),
      column: _("columnPadding")
    }
  };
}
var isL = 'item.orient === "left"';
var isR = 'item.orient === "right"';
var isLR = "(".concat(isL, " || ").concat(isR, ")");
var isVG = "datum.vgrad && ".concat(isLR);
var baseline = anchorExpr('"top"', '"bottom"', '"middle"');
var alignFlip = anchorExpr('"right"', '"left"', '"center"');
var exprAlign = "datum.vgrad && ".concat(isR, " ? (").concat(alignFlip, ") : (").concat(isLR, " && !(datum.vgrad && ").concat(isL, ')) ? "left" : ').concat(alignExpr);
var exprAnchor = "item._anchor || (".concat(isLR, ' ? "middle" : "start")');
var exprAngle = "".concat(isVG, " ? (").concat(isL, " ? -90 : 90) : 0");
var exprBaseline = "".concat(isLR, " ? (datum.vgrad ? (").concat(isR, ' ? "bottom" : "top") : ').concat(baseline, ') : "top"');
function legendTitle(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config);
  const encode2 = {
    enter: {
      opacity: zero4
    },
    update: {
      opacity: one4,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    orient: _("titleOrient"),
    _anchor: _("titleAnchor"),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    align: _("titleAlign"),
    baseline: _("titleBaseline")
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function clip2(clip3, scope) {
  let expr2;
  if (isObject(clip3)) {
    if (clip3.signal) {
      expr2 = clip3.signal;
    } else if (clip3.path) {
      expr2 = "pathShape(" + param(clip3.path) + ")";
    } else if (clip3.sphere) {
      expr2 = "geoShape(" + param(clip3.sphere) + ', {type: "Sphere"})';
    }
  }
  return expr2 ? scope.signalRef(expr2) : !!clip3;
}
function param(value3) {
  return isObject(value3) && value3.signal ? value3.signal : $(value3);
}
function getRole(spec) {
  const role = spec.role || "";
  return !role.indexOf("axis") || !role.indexOf("legend") || !role.indexOf("title") ? role : spec.type === GroupMark ? ScopeRole2 : role || MarkRole;
}
function definition2(spec) {
  return {
    marktype: spec.type,
    name: spec.name || void 0,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || void 0,
    aria: spec.aria,
    description: spec.description
  };
}
function interactive(spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}
function parseTransform(spec, scope) {
  const def2 = definition(spec.type);
  if (!def2)
    error("Unrecognized transform type: " + $(spec.type));
  const t = entry$1(def2.type.toLowerCase(), null, parseParameters2(def2, spec, scope));
  if (spec.signal)
    scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def2.metadata || {};
  return t;
}
function parseParameters2(def2, spec, scope) {
  const params2 = {}, n = def2.params.length;
  for (let i = 0; i < n; ++i) {
    const pdef = def2.params[i];
    params2[pdef.name] = parseParameter$1(pdef, spec, scope);
  }
  return params2;
}
function parseParameter$1(def2, spec, scope) {
  const type2 = def2.type, value3 = spec[def2.name];
  if (type2 === "index") {
    return parseIndexParameter(def2, spec, scope);
  } else if (value3 === void 0) {
    if (def2.required) {
      error("Missing required " + $(spec.type) + " parameter: " + $(def2.name));
    }
    return;
  } else if (type2 === "param") {
    return parseSubParameters(def2, spec, scope);
  } else if (type2 === "projection") {
    return scope.projectionRef(spec[def2.name]);
  }
  return def2.array && !isSignal(value3) ? value3.map((v) => parameterValue(def2, v, scope)) : parameterValue(def2, value3, scope);
}
function parameterValue(def2, value3, scope) {
  const type2 = def2.type;
  if (isSignal(value3)) {
    return isExpr$1(type2) ? error("Expression references can not be signals.") : isField(type2) ? scope.fieldRef(value3) : isCompare(type2) ? scope.compareRef(value3) : scope.signalRef(value3.signal);
  } else {
    const expr2 = def2.expr || isField(type2);
    return expr2 && outerExpr(value3) ? scope.exprRef(value3.expr, value3.as) : expr2 && outerField(value3) ? fieldRef(value3.field, value3.as) : isExpr$1(type2) ? parser2(value3, scope) : isData(type2) ? ref(scope.getData(value3).values) : isField(type2) ? fieldRef(value3) : isCompare(type2) ? scope.compareRef(value3) : value3;
  }
}
function parseIndexParameter(def2, spec, scope) {
  if (!isString(spec.from)) {
    error('Lookup "from" parameter must be a string literal.');
  }
  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
function parseSubParameters(def2, spec, scope) {
  const value3 = spec[def2.name];
  if (def2.array) {
    if (!isArray(value3)) {
      error("Expected an array of sub-parameters. Instead: " + $(value3));
    }
    return value3.map((v) => parseSubParameter(def2, v, scope));
  } else {
    return parseSubParameter(def2, value3, scope);
  }
}
function parseSubParameter(def2, value3, scope) {
  const n = def2.params.length;
  let pdef;
  for (let i = 0; i < n; ++i) {
    pdef = def2.params[i];
    for (const k in pdef.key) {
      if (pdef.key[k] !== value3[k]) {
        pdef = null;
        break;
      }
    }
    if (pdef)
      break;
  }
  if (!pdef)
    error("Unsupported parameter: " + $(value3));
  const params2 = extend(parseParameters2(pdef, value3, scope), pdef.key);
  return ref(scope.add(Params3(params2)));
}
var outerExpr = (_) => _ && _.expr;
var outerField = (_) => _ && _.field;
var isData = (_) => _ === "data";
var isExpr$1 = (_) => _ === "expr";
var isField = (_) => _ === "field";
var isCompare = (_) => _ === "compare";
function parseData(from, group2, scope) {
  let facet, key2, op, dataRef, parent;
  if (!from) {
    dataRef = ref(scope.add(Collect2(null, [{}])));
  } else if (facet = from.facet) {
    if (!group2)
      error("Only group marks can be faceted.");
    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      if (!from.data) {
        op = parseTransform(extend({
          type: "aggregate",
          groupby: array(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }
      key2 = scope.keyRef(facet.groupby, true);
    }
  }
  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }
  return {
    key: key2,
    pulse: dataRef,
    parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}
function DataScope(scope, input, output3, values2, aggr) {
  this.scope = scope;
  this.input = input;
  this.output = output3;
  this.values = values2;
  this.aggregate = aggr;
  this.index = {};
}
DataScope.fromEntries = function(scope, entries) {
  const n = entries.length, values2 = entries[n - 1], output3 = entries[n - 2];
  let input = entries[0], aggr = null, i = 1;
  if (input && input.type === "load") {
    input = entries[1];
  }
  scope.add(entries[0]);
  for (; i < n; ++i) {
    entries[i].params.pulse = ref(entries[i - 1]);
    scope.add(entries[i]);
    if (entries[i].type === "aggregate")
      aggr = entries[i];
  }
  return new DataScope(scope, input, output3, values2, aggr);
};
function fieldKey(field3) {
  return isString(field3) ? field3 : null;
}
function addSortField(scope, p, sort2) {
  const as = aggrField(sort2.op, sort2.field);
  let s;
  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as)
        return;
    }
  } else {
    p.ops = ["count"];
    p.fields = [null];
    p.as = ["count"];
  }
  if (sort2.op) {
    p.ops.push((s = sort2.op.signal) ? scope.signalRef(s) : sort2.op);
    p.fields.push(scope.fieldRef(sort2.field));
    p.as.push(as);
  }
}
function cache(scope, ds, name2, optype, field3, counts, index3) {
  const cache2 = ds[name2] || (ds[name2] = {}), sort2 = sortKey(counts);
  let k = fieldKey(field3), v, op;
  if (k != null) {
    scope = ds.scope;
    k = k + (sort2 ? "|" + sort2 : "");
    v = cache2[k];
  }
  if (!v) {
    const params2 = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field3, counts)
    } : {
      field: scope.fieldRef(field3),
      pulse: ref(ds.output)
    };
    if (sort2)
      params2.sort = scope.sortRef(counts);
    op = scope.add(entry$1(optype, void 0, params2));
    if (index3)
      ds.index[field3] = op;
    v = ref(op);
    if (k != null)
      cache2[k] = v;
  }
  return v;
}
DataScope.prototype = {
  countsRef(scope, field3, sort2) {
    const ds = this, cache2 = ds.counts || (ds.counts = {}), k = fieldKey(field3);
    let v, a2, p;
    if (k != null) {
      scope = ds.scope;
      v = cache2[k];
    }
    if (!v) {
      p = {
        groupby: scope.fieldRef(field3, "key"),
        pulse: ref(ds.output)
      };
      if (sort2 && sort2.field)
        addSortField(scope, p, sort2);
      a2 = scope.add(Aggregate2(p));
      v = scope.add(Collect2({
        pulse: ref(a2)
      }));
      v = {
        agg: a2,
        ref: ref(v)
      };
      if (k != null)
        cache2[k] = v;
    } else if (sort2 && sort2.field) {
      addSortField(scope, v.agg.params, sort2);
    }
    return v.ref;
  },
  tuplesRef() {
    return ref(this.values);
  },
  extentRef(scope, field3) {
    return cache(scope, this, "extent", "extent", field3, false);
  },
  domainRef(scope, field3) {
    return cache(scope, this, "domain", "values", field3, false);
  },
  valuesRef(scope, field3, sort2) {
    return cache(scope, this, "vals", "values", field3, sort2 || true);
  },
  lookupRef(scope, field3) {
    return cache(scope, this, "lookup", "tupleindex", field3, false);
  },
  indataRef(scope, field3) {
    return cache(scope, this, "indata", "tupleindex", field3, true, true);
  }
};
function parseFacet(spec, scope, group2) {
  const facet = spec.from.facet, name2 = facet.name, data3 = getDataRef(facet, scope);
  let op;
  if (!facet.name) {
    error("Facet must have a name: " + $(facet));
  }
  if (!facet.data) {
    error("Facet must reference a data set: " + $(facet));
  }
  if (facet.field) {
    op = scope.add(PreFacet2({
      field: scope.fieldRef(facet.field),
      pulse: data3
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet2({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group2.parent)),
      pulse: data3
    }));
  } else {
    error("Facet must specify groupby or field: " + $(facet));
  }
  const subscope = scope.fork(), source3 = subscope.add(Collect2()), values2 = subscope.add(Sieve2({
    pulse: ref(source3)
  }));
  subscope.addData(name2, new DataScope(subscope, source3, source3, values2));
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseSubflow(spec, scope, input) {
  const op = scope.add(PreFacet2({
    pulse: input.pulse
  })), subscope = scope.fork();
  subscope.add(Sieve2());
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseTrigger(spec, scope, name2) {
  const remove2 = spec.remove, insert2 = spec.insert, toggle = spec.toggle, modify2 = spec.modify, values2 = spec.values, op = scope.add(operator());
  const update3 = "if(" + spec.trigger + ',modify("' + name2 + '",' + [insert2, remove2, toggle, modify2, values2].map((_) => _ == null ? "null" : _).join(",") + "),0)";
  const expr2 = parser2(update3, scope);
  op.update = expr2.$expr;
  op.params = expr2.$params;
}
function parseMark(spec, scope) {
  const role = getRole(spec), group2 = spec.type === GroupMark, facet = spec.from && spec.from.facet, overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole2 || role === FrameRole2, ops2, op, store, enc, name2, layoutRef, boundRef;
  const nested = role === MarkRole || layout || facet;
  const input = parseData(spec.from, group2, scope);
  op = scope.add(DataJoin2({
    key: input.key || (spec.key ? fieldRef(spec.key) : void 0),
    pulse: input.pulse,
    clean: !group2
  }));
  const joinRef = ref(op);
  op = store = scope.add(Collect2({
    pulse: joinRef
  }));
  op = scope.add(Mark2({
    markdef: definition2(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip2(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef("parent") : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op);
  op = enc = scope.add(Encode2(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  })));
  op.params.parent = scope.encode();
  if (spec.transform) {
    spec.transform.forEach((_) => {
      const tx = parseTransform(_, scope), md2 = tx.metadata;
      if (md2.generates || md2.changes) {
        error("Mark transforms should not generate new data.");
      }
      if (!md2.nomod)
        enc.params.mod = true;
      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  }
  if (spec.sort) {
    op = scope.add(SortItems2({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }
  const encodeRef = ref(op);
  if (facet || layout) {
    layout = scope.add(ViewLayout2({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  }
  const bound2 = scope.add(Bound2({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound2);
  if (group2) {
    if (nested) {
      ops2 = scope.operators;
      ops2.pop();
      if (layout)
        ops2.pop();
    }
    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) : nested ? parseSubflow(spec, scope, input) : scope.parse(spec);
    scope.popState();
    if (nested) {
      if (layout)
        ops2.push(layout);
      ops2.push(bound2);
    }
  }
  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  }
  const render = scope.add(Render2({
    pulse: boundRef
  })), sieve = scope.add(Sieve2({
    pulse: ref(render)
  }, void 0, scope.parent()));
  if (spec.name != null) {
    name2 = spec.name;
    scope.addData(name2, new DataScope(scope, store, render, sieve));
    if (spec.on)
      spec.on.forEach((on2) => {
        if (on2.insert || on2.remove || on2.toggle) {
          error("Marks only support modify triggers.");
        }
        parseTrigger(on2, scope, name2);
      });
  }
}
function parseOverlap(overlap, source3, scope) {
  const method2 = overlap.method, bound2 = overlap.bound, sep = overlap.separation;
  const params2 = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method2) ? scope.signalRef(method2.signal) : method2,
    pulse: source3
  };
  if (overlap.order) {
    params2.sort = scope.compareRef({
      field: overlap.order
    });
  }
  if (bound2) {
    const tol = bound2.tolerance;
    params2.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params2.boundScale = scope.scaleRef(bound2.scale);
    params2.boundOrient = bound2.orient;
  }
  return ref(scope.add(Overlap2(params2)));
}
function parseLegend(spec, scope) {
  const config = scope.config.legend, encode2 = spec.encode || {}, _ = lookup5(spec, config), legendEncode = encode2.legend || {}, name2 = legendEncode.name || void 0, interactive2 = legendEncode.interactive, style2 = legendEncode.style, scales2 = {};
  let scale6 = 0, entryLayout, params2, children3;
  LegendScales.forEach((s) => spec[s] ? (scales2[s] = spec[s], scale6 = scale6 || spec[s]) : 0);
  if (!scale6)
    error("Missing valid scale for legend.");
  const type2 = legendType(spec, scope.scaleType(scale6));
  const datum2 = {
    title: spec.title != null,
    scales: scales2,
    type: type2,
    vgrad: type2 !== "symbol" && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect2(null, [datum2])));
  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  };
  const entryRef = ref(scope.add(LegendEntries2(params2 = {
    type: type2,
    scale: scope.scaleRef(scale6),
    count: scope.objectProperty(_("tickCount")),
    limit: scope.property(_("symbolLimit")),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  if (type2 === Gradient2) {
    children3 = [legendGradient(spec, scale6, config, encode2.gradient), legendGradientLabels(spec, config, encode2.labels, entryRef)];
    params2.count = params2.count || scope.signalRef("max(2,2*floor((".concat(deref(_.gradientLength()), ")/100))"));
  } else if (type2 === Discrete2) {
    children3 = [legendGradientDiscrete(spec, scale6, config, encode2.gradient, entryRef), legendGradientLabels(spec, config, encode2.labels, entryRef)];
  } else {
    entryLayout = legendSymbolLayout(spec, config);
    children3 = [legendSymbolGroups(spec, config, encode2, entryRef, deref(entryLayout.columns))];
    params2.size = sizeExpression(spec, scope, children3[0].marks);
  }
  children3 = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children3,
    layout: entryLayout,
    interactive: interactive2
  })];
  if (datum2.title) {
    children3.push(legendTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: LegendRole2,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip3),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name2,
    interactive: interactive2,
    style: style2
  }), scope);
}
function legendType(spec, scaleType) {
  let type2 = spec.type || Symbols2;
  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type2 = isContinuous(scaleType) ? Gradient2 : isDiscretizing(scaleType) ? Discrete2 : Symbols2;
  }
  return type2 !== Gradient2 ? type2 : isDiscretizing(scaleType) ? Discrete2 : Gradient2;
}
function scaleCount(spec) {
  return LegendScales.reduce((count2, type2) => count2 + (spec[type2] ? 1 : 0), 0);
}
function buildLegendEncode(_, spec, config) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset"),
    padding: _("padding"),
    titlePadding: _("titlePadding"),
    cornerRadius: _("cornerRadius"),
    fill: _("fillColor"),
    stroke: _("strokeColor"),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _("legendX"),
    y: _("legendY"),
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel("size", spec, marks)), strokeWidth = deref(getChannel("strokeWidth", spec, marks)), fontSize2 = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return parser2("max(ceil(sqrt(".concat(size, ")+").concat(strokeWidth, "),").concat(fontSize2, ")"), scope);
}
function getChannel(name2, spec, marks) {
  return spec[name2] ? 'scale("'.concat(spec[name2], '",datum)') : getEncoding(name2, marks[0].encode);
}
function getFontSize(encode2, scope, style2) {
  return getEncoding("fontSize", encode2) || getStyle("fontSize", scope, style2);
}
var angleExpr = 'item.orient==="'.concat(Left2, '"?-90:item.orient==="').concat(Right2, '"?90:0');
function parseTitle(spec, scope) {
  spec = isString(spec) ? {
    text: spec
  } : spec;
  const _ = lookup5(spec, scope.config.title), encode2 = spec.encode || {}, userEncode = encode2.group || {}, name2 = userEncode.name || void 0, interactive2 = userEncode.interactive, style2 = userEncode.style, children3 = [];
  const datum2 = {}, dataRef = ref(scope.add(Collect2(null, [datum2])));
  children3.push(buildTitle(spec, _, titleEncode(spec), dataRef));
  if (spec.subtitle) {
    children3.push(buildSubTitle(spec, _, encode2.subtitle, dataRef));
  }
  return parseMark(guideGroup({
    role: TitleRole2,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name2,
    interactive: interactive2,
    style: style2
  }), scope);
}
function titleEncode(spec) {
  const encode2 = spec.encode;
  return encode2 && encode2.title || extend({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode2);
}
function groupEncode(_, userEncode) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    anchor: _("anchor"),
    align: {
      signal: alignExpr
    },
    angle: {
      signal: angleExpr
    },
    limit: _("limit"),
    frame: _("frame"),
    offset: _("offset") || 0,
    padding: _("subtitlePadding")
  });
  return extendEncode(encode2, userEncode, Skip3);
}
function buildTitle(spec, _, userEncode, dataRef) {
  const zero5 = {
    value: 0
  }, text2 = spec.text, encode2 = {
    enter: {
      opacity: zero5
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero5
    }
  };
  addEncoders(encode2, {
    text: text2,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("color"),
    font: _("font"),
    fontSize: _("fontSize"),
    fontStyle: _("fontStyle"),
    fontWeight: _("fontWeight"),
    lineHeight: _("lineHeight")
  }, {
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero5 = {
    value: 0
  }, text2 = spec.subtitle, encode2 = {
    enter: {
      opacity: zero5
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero5
    }
  };
  addEncoders(encode2, {
    text: text2,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("subtitleColor"),
    font: _("subtitleFont"),
    fontSize: _("subtitleFontSize"),
    fontStyle: _("subtitleFontStyle"),
    fontWeight: _("subtitleFontWeight"),
    lineHeight: _("subtitleLineHeight")
  }, {
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function parseData$1(data3, scope) {
  const transforms2 = [];
  if (data3.transform) {
    data3.transform.forEach((tx) => {
      transforms2.push(parseTransform(tx, scope));
    });
  }
  if (data3.on) {
    data3.on.forEach((on2) => {
      parseTrigger(on2, scope, data3.name);
    });
  }
  scope.addDataPipeline(data3.name, analyze(data3, scope, transforms2));
}
function analyze(data3, scope, ops2) {
  const output3 = [];
  let source3 = null, modify2 = false, generate2 = false, upstream, i, n, t, m2;
  if (data3.values) {
    if (isSignal(data3.values) || hasSignal(data3.format)) {
      output3.push(load2(scope, data3));
      output3.push(source3 = collect());
    } else {
      output3.push(source3 = collect({
        $ingest: data3.values,
        $format: data3.format
      }));
    }
  } else if (data3.url) {
    if (hasSignal(data3.url) || hasSignal(data3.format)) {
      output3.push(load2(scope, data3));
      output3.push(source3 = collect());
    } else {
      output3.push(source3 = collect({
        $request: data3.url,
        $format: data3.format
      }));
    }
  } else if (data3.source) {
    source3 = upstream = array(data3.source).map((d) => ref(scope.getData(d).output));
    output3.push(null);
  }
  for (i = 0, n = ops2.length; i < n; ++i) {
    t = ops2[i];
    m2 = t.metadata;
    if (!source3 && !m2.source) {
      output3.push(source3 = collect());
    }
    output3.push(t);
    if (m2.generates)
      generate2 = true;
    if (m2.modifies && !generate2)
      modify2 = true;
    if (m2.source)
      source3 = t;
    else if (m2.changes)
      source3 = null;
  }
  if (upstream) {
    n = upstream.length - 1;
    output3[0] = Relay2({
      derive: modify2,
      pulse: n ? upstream : upstream[0]
    });
    if (modify2 || n) {
      output3.splice(1, 0, collect());
    }
  }
  if (!source3)
    output3.push(collect());
  output3.push(Sieve2({}));
  return output3;
}
function collect(values2) {
  const s = Collect2({}, values2);
  s.metadata = {
    source: true
  };
  return s;
}
function load2(scope, data3) {
  return Load2({
    url: data3.url ? scope.property(data3.url) : void 0,
    async: data3.async ? scope.property(data3.async) : void 0,
    values: data3.values ? scope.property(data3.values) : void 0,
    format: scope.objectProperty(data3.format)
  });
}
var isX = (orient2) => orient2 === Bottom2 || orient2 === Top2;
var getSign = (orient2, a2, b2) => isSignal(orient2) ? ifLeftTopExpr(orient2.signal, a2, b2) : orient2 === Left2 || orient2 === Top2 ? a2 : b2;
var ifX = (orient2, a2, b2) => isSignal(orient2) ? ifXEnc(orient2.signal, a2, b2) : isX(orient2) ? a2 : b2;
var ifY = (orient2, a2, b2) => isSignal(orient2) ? ifYEnc(orient2.signal, a2, b2) : isX(orient2) ? b2 : a2;
var ifTop = (orient2, a2, b2) => isSignal(orient2) ? ifTopExpr(orient2.signal, a2, b2) : orient2 === Top2 ? {
  value: a2
} : {
  value: b2
};
var ifRight = (orient2, a2, b2) => isSignal(orient2) ? ifRightExpr(orient2.signal, a2, b2) : orient2 === Right2 ? {
  value: a2
} : {
  value: b2
};
var ifXEnc = ($orient, a2, b2) => ifEnc("".concat($orient, " === '").concat(Top2, "' || ").concat($orient, " === '").concat(Bottom2, "'"), a2, b2);
var ifYEnc = ($orient, a2, b2) => ifEnc("".concat($orient, " !== '").concat(Top2, "' && ").concat($orient, " !== '").concat(Bottom2, "'"), a2, b2);
var ifLeftTopExpr = ($orient, a2, b2) => ifExpr("".concat($orient, " === '").concat(Left2, "' || ").concat($orient, " === '").concat(Top2, "'"), a2, b2);
var ifTopExpr = ($orient, a2, b2) => ifExpr("".concat($orient, " === '").concat(Top2, "'"), a2, b2);
var ifRightExpr = ($orient, a2, b2) => ifExpr("".concat($orient, " === '").concat(Right2, "'"), a2, b2);
var ifEnc = (test2, a2, b2) => {
  a2 = a2 != null ? encoder(a2) : a2;
  b2 = b2 != null ? encoder(b2) : b2;
  if (isSimple(a2) && isSimple(b2)) {
    a2 = a2 ? a2.signal || $(a2.value) : null;
    b2 = b2 ? b2.signal || $(b2.value) : null;
    return {
      signal: "".concat(test2, " ? (").concat(a2, ") : (").concat(b2, ")")
    };
  } else {
    return [extend({
      test: test2
    }, a2)].concat(b2 || []);
  }
};
var isSimple = (enc) => enc == null || Object.keys(enc).length === 1;
var ifExpr = (test2, a2, b2) => ({
  signal: "".concat(test2, " ? (").concat(toExpr(a2), ") : (").concat(toExpr(b2), ")")
});
var ifOrient = ($orient, t, b2, l, r) => ({
  signal: (l != null ? "".concat($orient, " === '").concat(Left2, "' ? (").concat(toExpr(l), ") : ") : "") + (b2 != null ? "".concat($orient, " === '").concat(Bottom2, "' ? (").concat(toExpr(b2), ") : ") : "") + (r != null ? "".concat($orient, " === '").concat(Right2, "' ? (").concat(toExpr(r), ") : ") : "") + (t != null ? "".concat($orient, " === '").concat(Top2, "' ? (").concat(toExpr(t), ") : ") : "") + "(null)"
});
var toExpr = (v) => isSignal(v) ? v.signal : v == null ? null : $(v);
var mult = (sign3, value3) => value3 === 0 ? 0 : isSignal(sign3) ? {
  signal: "(".concat(sign3.signal, ") * ").concat(value3)
} : {
  value: sign3 * value3
};
var patch = (value3, base2) => {
  const s = value3.signal;
  return s && s.endsWith("(null)") ? {
    signal: s.slice(0, -6) + base2.signal
  } : value3;
};
function fallback(prop, config, axisConfig2, style2) {
  let styleProp;
  if (config && has(config, prop)) {
    return config[prop];
  } else if (has(axisConfig2, prop)) {
    return axisConfig2[prop];
  } else if (prop.startsWith("title")) {
    switch (prop) {
      case "titleColor":
        styleProp = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideTitleStyle][styleProp];
  } else if (prop.startsWith("label")) {
    switch (prop) {
      case "labelColor":
        styleProp = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideLabelStyle][styleProp];
  }
  return null;
}
function keys2(objects) {
  const map3 = {};
  for (const obj of objects) {
    if (!obj)
      continue;
    for (const key2 in obj)
      map3[key2] = 1;
  }
  return Object.keys(map3);
}
function axisConfig(spec, scope) {
  var config = scope.config, style2 = config.style, axis = config.axis, band2 = scope.scaleType(spec.scale) === "band" && config.axisBand, orient2 = spec.orient, xy, or2, key2;
  if (isSignal(orient2)) {
    const xyKeys = keys2([config.axisX, config.axisY]), orientKeys = keys2([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};
    for (key2 of xyKeys) {
      xy[key2] = ifX(orient2, fallback(key2, config.axisX, axis, style2), fallback(key2, config.axisY, axis, style2));
    }
    or2 = {};
    for (key2 of orientKeys) {
      or2[key2] = ifOrient(orient2.signal, fallback(key2, config.axisTop, axis, style2), fallback(key2, config.axisBottom, axis, style2), fallback(key2, config.axisLeft, axis, style2), fallback(key2, config.axisRight, axis, style2));
    }
  } else {
    xy = orient2 === Top2 || orient2 === Bottom2 ? config.axisX : config.axisY;
    or2 = config["axis" + orient2[0].toUpperCase() + orient2.slice(1)];
  }
  const result = xy || or2 || band2 ? extend({}, axis, xy, or2, band2) : axis;
  return result;
}
function axisDomain(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), orient2 = spec.orient;
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero4
    },
    update: update3 = {
      opacity: one4
    },
    exit: {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    stroke: _("domainColor"),
    strokeCap: _("domainCap"),
    strokeDash: _("domainDash"),
    strokeDashOffset: _("domainDashOffset"),
    strokeWidth: _("domainWidth"),
    strokeOpacity: _("domainOpacity")
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update3.x = ifX(orient2, pos0, zero4);
  enter.x2 = update3.x2 = ifX(orient2, pos1);
  enter.y = update3.y = ifY(orient2, pos0, zero4);
  enter.y2 = update3.y2 = ifY(orient2, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}
function axisGrid(spec, config, userEncode, dataRef, band2) {
  const _ = lookup5(spec, config), orient2 = spec.orient, vscale = spec.gridScale, sign3 = getSign(orient2, 1, -1), offset4 = offsetValue2(spec.offset, sign3);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero4
    },
    update: update3 = {
      opacity: one4
    },
    exit: exit = {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    stroke: _("gridColor"),
    strokeCap: _("gridCap"),
    strokeDash: _("gridDash"),
    strokeDashOffset: _("gridDashOffset"),
    strokeOpacity: _("gridOpacity"),
    strokeWidth: _("gridWidth")
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  const sz2 = ifX(orient2, {
    signal: "height"
  }, {
    signal: "width"
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign3,
    offset: offset4
  } : {
    value: 0,
    offset: offset4
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign3,
    offset: offset4
  } : extend(sz2, {
    mult: sign3,
    offset: offset4
  });
  enter.x = update3.x = ifX(orient2, tickPos, gridStart);
  enter.y = update3.y = ifY(orient2, tickPos, gridStart);
  enter.x2 = update3.x2 = ifY(orient2, gridEnd);
  enter.y2 = update3.y2 = ifX(orient2, gridEnd);
  exit.x = ifX(orient2, tickPos);
  exit.y = ifY(orient2, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function offsetValue2(offset4, sign3) {
  if (sign3 === 1)
    ;
  else if (!isObject(offset4)) {
    offset4 = isSignal(sign3) ? {
      signal: "(".concat(sign3.signal, ") * (").concat(offset4 || 0, ")")
    } : sign3 * (offset4 || 0);
  } else {
    let entry2 = offset4 = extend({}, offset4);
    while (entry2.mult != null) {
      if (!isObject(entry2.mult)) {
        entry2.mult = isSignal(sign3) ? {
          signal: "(".concat(entry2.mult, ") * (").concat(sign3.signal, ")")
        } : entry2.mult * sign3;
        return offset4;
      } else {
        entry2 = entry2.mult = extend({}, entry2.mult);
      }
    }
    entry2.mult = sign3;
  }
  return offset4;
}
function axisTicks(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup5(spec, config), orient2 = spec.orient, sign3 = getSign(orient2, -1, 1);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero4
    },
    update: update3 = {
      opacity: one4
    },
    exit: exit = {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    stroke: _("tickColor"),
    strokeCap: _("tickCap"),
    strokeDash: _("tickDash"),
    strokeDashOffset: _("tickDashOffset"),
    strokeOpacity: _("tickOpacity"),
    strokeWidth: _("tickWidth")
  });
  const tickSize = encoder(size);
  tickSize.mult = sign3;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  update3.y = enter.y = ifX(orient2, zero4, tickPos);
  update3.y2 = enter.y2 = ifX(orient2, tickSize);
  exit.x = ifX(orient2, tickPos);
  update3.x = enter.x = ifY(orient2, zero4, tickPos);
  update3.x2 = enter.x2 = ifY(orient2, tickSize);
  exit.y = ifY(orient2, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function flushExpr(scale6, threshold2, a2, b2, c2) {
  return {
    signal: 'flush(range("' + scale6 + '"), scale("' + scale6 + '", datum.value), ' + threshold2 + "," + a2 + "," + b2 + "," + c2 + ")"
  };
}
function axisLabels(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup5(spec, config), orient2 = spec.orient, scale6 = spec.scale, sign3 = getSign(orient2, -1, 1), flush2 = deref(_("labelFlush")), flushOffset = deref(_("labelFlushOffset")), labelAlign = _("labelAlign"), labelBaseline = _("labelBaseline");
  let flushOn = flush2 === 0 || !!flush2, update3;
  const tickSize = encoder(size);
  tickSize.mult = sign3;
  tickSize.offset = encoder(_("labelPadding") || 0);
  tickSize.offset.mult = sign3;
  const tickPos = {
    scale: scale6,
    field: Value,
    band: 0.5,
    offset: extendOffset(band2.offset, _("labelOffset"))
  };
  const align = ifX(orient2, flushOn ? flushExpr(scale6, flush2, '"left"', '"right"', '"center"') : {
    value: "center"
  }, ifRight(orient2, "left", "right"));
  const baseline2 = ifX(orient2, ifTop(orient2, "bottom", "top"), flushOn ? flushExpr(scale6, flush2, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  });
  const offsetExpr = flushExpr(scale6, flush2, "-(".concat(flushOffset, ")"), flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero4,
    x: ifX(orient2, tickPos, tickSize),
    y: ifY(orient2, tickPos, tickSize)
  };
  const encode2 = {
    enter,
    update: update3 = {
      opacity: one4,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y,
      align,
      baseline: baseline2
    },
    exit: {
      opacity: zero4,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode2, {
    dx: !labelAlign && flushOn ? ifX(orient2, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient2, offsetExpr) : null
  });
  addEncoders(encode2, {
    angle: _("labelAngle"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontWeight: _("labelFontWeight"),
    fontStyle: _("labelFontStyle"),
    limit: _("labelLimit"),
    lineHeight: _("labelLineHeight")
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });
  const bound2 = _("labelBound");
  let overlap = _("labelOverlap");
  overlap = overlap || bound2 ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum.index",
    bound: bound2 ? {
      scale: scale6,
      orient: orient2,
      tolerance: bound2
    } : null
  } : void 0;
  if (update3.align !== align) {
    update3.align = patch(update3.align, align);
  }
  if (update3.baseline !== baseline2) {
    update3.baseline = patch(update3.baseline, baseline2);
  }
  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function axisTitle(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), orient2 = spec.orient, sign3 = getSign(orient2, -1, 1);
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero4,
      anchor: encoder(_("titleAnchor", null)),
      align: {
        signal: alignExpr
      }
    },
    update: update3 = extend({}, enter, {
      opacity: one4,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero4
    }
  };
  const titlePos = {
    signal: 'lerp(range("'.concat(spec.scale, '"), ').concat(anchorExpr(0, 1, 0.5), ")")
  };
  update3.x = ifX(orient2, titlePos);
  update3.y = ifY(orient2, titlePos);
  enter.angle = ifX(orient2, zero4, mult(sign3, 90));
  enter.baseline = ifX(orient2, ifTop(orient2, Bottom2, Top2), {
    value: Bottom2
  });
  update3.angle = enter.angle;
  update3.baseline = enter.baseline;
  addEncoders(encode2, {
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    align: _("titleAlign"),
    angle: _("titleAngle"),
    baseline: _("titleBaseline")
  });
  autoLayout(_, orient2, encode2, userEncode);
  encode2.update.align = patch(encode2.update.align, enter.align);
  encode2.update.angle = patch(encode2.update.angle, enter.angle);
  encode2.update.baseline = patch(encode2.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function autoLayout(_, orient2, encode2, userEncode) {
  const auto = (value3, dim) => value3 != null ? (encode2.update[dim] = patch(encoder(value3), encode2.update[dim]), false) : !has2(dim, userEncode) ? true : false;
  const autoY = auto(_("titleX"), "x"), autoX = auto(_("titleY"), "y");
  encode2.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient2, encoder(autoX), encoder(autoY));
}
function parseAxis(spec, scope) {
  const config = axisConfig(spec, scope), encode2 = spec.encode || {}, axisEncode = encode2.axis || {}, name2 = axisEncode.name || void 0, interactive2 = axisEncode.interactive, style2 = axisEncode.style, _ = lookup5(spec, config), band2 = tickBand(_);
  const datum2 = {
    scale: spec.scale,
    ticks: !!_("ticks"),
    labels: !!_("labels"),
    grid: !!_("grid"),
    domain: !!_("domain"),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect2({}, [datum2])));
  const ticksRef = ref(scope.add(AxisTicks2({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band2.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  const children3 = [];
  let size;
  if (datum2.grid) {
    children3.push(axisGrid(spec, config, encode2.grid, ticksRef, band2));
  }
  if (datum2.ticks) {
    size = _("tickSize");
    children3.push(axisTicks(spec, config, encode2.ticks, ticksRef, size, band2));
  }
  if (datum2.labels) {
    size = datum2.ticks ? size : 0;
    children3.push(axisLabels(spec, config, encode2.labels, ticksRef, size, band2));
  }
  if (datum2.domain) {
    children3.push(axisDomain(spec, config, encode2.domain, dataRef));
  }
  if (datum2.title) {
    children3.push(axisTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: AxisRole2,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip3),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name2,
    interactive: interactive2,
    style: style2
  }), scope);
}
function buildAxisEncode(_, spec) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset") || 0,
    position: value2(spec.position, 0),
    titlePadding: _("titlePadding"),
    minExtent: _("minExtent"),
    maxExtent: _("maxExtent"),
    range: {
      signal: 'abs(span(range("'.concat(spec.scale, '")))')
    },
    translate: _("translate"),
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function parseScope(spec, scope, preprocessed) {
  const signals = array(spec.signals), scales2 = array(spec.scales);
  if (!preprocessed)
    signals.forEach((_) => parseSignal(_, scope));
  array(spec.projections).forEach((_) => parseProjection(_, scope));
  scales2.forEach((_) => initScale(_, scope));
  array(spec.data).forEach((_) => parseData$1(_, scope));
  scales2.forEach((_) => parseScale(_, scope));
  (preprocessed || signals).forEach((_) => parseSignalUpdates(_, scope));
  array(spec.axes).forEach((_) => parseAxis(_, scope));
  array(spec.marks).forEach((_) => parseMark(_, scope));
  array(spec.legends).forEach((_) => parseLegend(_, scope));
  if (spec.title)
    parseTitle(spec.title, scope);
  scope.parseLambdas();
  return scope;
}
var rootEncode = (spec) => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, spec);
function parseView(spec, scope) {
  const config = scope.config;
  const root = ref(scope.root = scope.add(operator()));
  const signals = collectSignals(spec, config);
  signals.forEach((_) => parseSignal(_, scope));
  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale;
  const input = scope.add(Collect2());
  const encode2 = scope.add(Encode2(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole2, spec.style, scope, {
    pulse: ref(input)
  })));
  const parent = scope.add(ViewLayout2({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef("autosize"),
    mark: root,
    pulse: ref(encode2)
  }));
  scope.operators.pop();
  scope.pushState(ref(encode2), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent);
  let op = scope.add(Bound2({
    mark: root,
    pulse: ref(parent)
  }));
  op = scope.add(Render2({
    pulse: ref(op)
  }));
  op = scope.add(Sieve2({
    pulse: ref(op)
  }));
  scope.addData("root", new DataScope(scope, input, input, op));
  return scope;
}
function signalObject(name2, value3) {
  return value3 && value3.signal ? {
    name: name2,
    update: value3.signal
  } : {
    name: name2,
    value: value3
  };
}
function collectSignals(spec, config) {
  const _ = (name2) => value2(spec[name2], config[name2]), signals = [signalObject("background", _("background")), signalObject("autosize", parseAutosize(_("autosize"))), signalObject("padding", parsePadding(_("padding"))), signalObject("width", _("width") || 0), signalObject("height", _("height") || 0)], pre = signals.reduce((p, s) => (p[s.name] = s, p), {}), map3 = {};
  array(spec.signals).forEach((s) => {
    if (has(pre, s.name)) {
      s = extend(pre[s.name], s);
    } else {
      signals.push(s);
    }
    map3[s.name] = s;
  });
  array(config.signals).forEach((s) => {
    if (!has(map3, s.name) && !has(pre, s.name)) {
      signals.push(s);
    }
  });
  return signals;
}
function Scope$1(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}
function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}
Scope$1.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },
  fork() {
    return new Subscope(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(op) {
    this.operators.push(op);
    op.id = this.id();
    if (op.refs) {
      op.refs.forEach((ref2) => {
        ref2.$ref = op.id;
      });
      op.refs = null;
    }
    return op;
  },
  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy2({
      value: vref
    }));
  },
  addStream(stream2) {
    this.streams.push(stream2);
    stream2.id = this.id();
    return stream2;
  },
  addUpdate(update3) {
    this.updates.push(update3);
    return update3;
  },
  finish() {
    let name2, ds;
    if (this.root)
      this.root.root = true;
    for (name2 in this.signals) {
      this.signals[name2].signal = name2;
    }
    for (name2 in this.scales) {
      this.scales[name2].scale = name2;
    }
    function annotate(op, name3, type2) {
      let data3, list;
      if (op) {
        data3 = op.data || (op.data = {});
        list = data3[name3] || (data3[name3] = []);
        list.push(type2);
      }
    }
    for (name2 in this.data) {
      ds = this.data[name2];
      annotate(ds.input, name2, "input");
      annotate(ds.output, name2, "output");
      annotate(ds.values, name2, "values");
      for (const field3 in ds.index) {
        annotate(ds.index[field3], name2, "index:" + field3);
      }
    }
    return this;
  },
  pushState(encode2, parent, lookup6) {
    this._encode.push(ref(this.add(Sieve2({
      pulse: encode2
    }))));
    this._parent.push(parent);
    this._lookup.push(lookup6 ? ref(this.proxy(lookup6)) : null);
    this._markpath.push(-1);
  },
  popState() {
    this._encode.pop();
    this._parent.pop();
    this._lookup.pop();
    this._markpath.pop();
  },
  parent() {
    return peek(this._parent);
  },
  encode() {
    return peek(this._encode);
  },
  lookup() {
    return peek(this._lookup);
  },
  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },
  fieldRef(field3, name2) {
    if (isString(field3))
      return fieldRef(field3, name2);
    if (!field3.signal) {
      error("Unsupported field reference: " + $(field3));
    }
    const s = field3.signal;
    let f = this.field[s];
    if (!f) {
      const params2 = {
        name: this.signalRef(s)
      };
      if (name2)
        params2.as = name2;
      this.field[s] = f = ref(this.add(Field2(params2)));
    }
    return f;
  },
  compareRef(cmp) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr(_) ? (signal = true, this.exprRef(_.expr)) : _;
    const fields = array(cmp.field).map(check), orders = array(cmp.order).map(check);
    return signal ? ref(this.add(Compare2({
      fields,
      orders
    }))) : compareRef(fields, orders);
  },
  keyRef(fields, flat) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
    const sig = this.signals;
    fields = array(fields).map(check);
    return signal ? ref(this.add(Key2({
      fields,
      flat
    }))) : keyRef(fields, flat);
  },
  sortRef(sort2) {
    if (!sort2)
      return sort2;
    const a2 = aggrField(sort2.op, sort2.field), o = sort2.order || Ascending;
    return o.signal ? ref(this.add(Compare2({
      fields: a2,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a2, o);
  },
  event(source3, type2) {
    const key2 = source3 + ":" + type2;
    if (!this.events[key2]) {
      const id2 = this.id();
      this.streams.push({
        id: id2,
        source: source3,
        type: type2
      });
      this.events[key2] = id2;
    }
    return this.events[key2];
  },
  hasOwnSignal(name2) {
    return has(this.signals, name2);
  },
  addSignal(name2, value3) {
    if (this.hasOwnSignal(name2)) {
      error("Duplicate signal name: " + $(name2));
    }
    const op = value3 instanceof Entry ? value3 : this.add(operator(value3));
    return this.signals[name2] = op;
  },
  getSignal(name2) {
    if (!this.signals[name2]) {
      error("Unrecognized signal name: " + $(name2));
    }
    return this.signals[name2];
  },
  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!has(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }
    return ref(this.lambdas[s]);
  },
  parseLambdas() {
    const code = Object.keys(this.lambdas);
    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i], e = parser2(s, this), op = this.lambdas[s];
      op.params = e.$params;
      op.update = e.$expr;
    }
  },
  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },
  objectProperty(spec) {
    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },
  exprRef(code, name2) {
    const params2 = {
      expr: parser2(code, this)
    };
    if (name2)
      params2.expr.$name = name2;
    return ref(this.add(Expression2(params2)));
  },
  addBinding(name2, bind3) {
    if (!this.bindings) {
      error("Nested signals do not support binding: " + $(name2));
    }
    this.bindings.push(extend({
      signal: name2
    }, bind3));
  },
  addScaleProj(name2, transform4) {
    if (has(this.scales, name2)) {
      error("Duplicate scale or projection name: " + $(name2));
    }
    this.scales[name2] = this.add(transform4);
  },
  addScale(name2, params2) {
    this.addScaleProj(name2, Scale2(params2));
  },
  addProjection(name2, params2) {
    this.addScaleProj(name2, Projection2(params2));
  },
  getScale(name2) {
    if (!this.scales[name2]) {
      error("Unrecognized scale name: " + $(name2));
    }
    return this.scales[name2];
  },
  scaleRef(name2) {
    return ref(this.getScale(name2));
  },
  scaleType(name2) {
    return this.getScale(name2).params.type;
  },
  projectionRef(name2) {
    return this.scaleRef(name2);
  },
  projectionType(name2) {
    return this.scaleType(name2);
  },
  addData(name2, dataScope) {
    if (has(this.data, name2)) {
      error("Duplicate data set name: " + $(name2));
    }
    return this.data[name2] = dataScope;
  },
  getData(name2) {
    if (!this.data[name2]) {
      error("Undefined data set name: " + $(name2));
    }
    return this.data[name2];
  },
  addDataPipeline(name2, entries) {
    if (has(this.data, name2)) {
      error("Duplicate data set name: " + $(name2));
    }
    return this.addData(name2, DataScope.fromEntries(this, entries));
  }
};
function propertyLambda(spec) {
  return (isArray(spec) ? arrayLambda : objectLambda)(spec);
}
function arrayLambda(array4) {
  const n = array4.length;
  let code = "[";
  for (let i = 0; i < n; ++i) {
    const value3 = array4[i];
    code += (i > 0 ? "," : "") + (isObject(value3) ? value3.signal || propertyLambda(value3) : $(value3));
  }
  return code + "]";
}
function objectLambda(obj) {
  let code = "{", i = 0, key2, value3;
  for (key2 in obj) {
    value3 = obj[key2];
    code += (++i > 1 ? "," : "") + $(key2) + ":" + (isObject(value3) ? value3.signal || propertyLambda(value3) : $(value3));
  }
  return code + "}";
}
function defaults() {
  const defaultFont = "sans-serif", defaultSymbolSize = 30, defaultStrokeWidth = 2, defaultColor = "#4c78a8", black = "#000", gray3 = "#888", lightGray = "#ddd";
  return {
    description: "Vega visualization",
    padding: 0,
    autosize: "pad",
    background: null,
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    group: null,
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    style: {
      "guide-label": {
        fill: black,
        font: defaultFont,
        fontSize: 10
      },
      "guide-title": {
        fill: black,
        font: defaultFont,
        fontSize: 11,
        fontWeight: "bold"
      },
      "group-title": {
        fill: black,
        font: defaultFont,
        fontSize: 13,
        fontWeight: "bold"
      },
      "group-subtitle": {
        fill: black,
        font: defaultFont,
        fontSize: 12
      },
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "circle"
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "square"
      },
      cell: {
        fill: "transparent",
        stroke: lightGray
      }
    },
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray3,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray3,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    axisBand: {
      tickOffset: -0.5
    },
    projection: {
      type: "mercator"
    },
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: gray3,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function parse$1(spec, config, options) {
  if (!isObject(spec)) {
    error("Input Vega specification must be an object.");
  }
  config = mergeConfig(defaults(), config, spec.config);
  return parseView(spec, new Scope$1(config, options)).toRuntime();
}

// node_modules/vega/build/vega.module.js
var name = "vega";
var version$1 = "5.20.2";
var description = "The Vega visualization grammar.";
var keywords2 = [
  "vega",
  "visualization",
  "interaction",
  "dataflow",
  "library",
  "data",
  "d3"
];
var license = "BSD-3-Clause";
var author = "UW Interactive Data Lab (http://idl.cs.washington.edu)";
var main = "build/vega-node.js";
var module = "build/vega.module.js";
var unpkg = "build/vega.min.js";
var jsdelivr = "build/vega.min.js";
var types = "index.d.ts";
var repository = "vega/vega";
var scripts = {
  bundle: "rollup -c --config-bundle",
  prebuild: "rimraf build && rimraf build-es5",
  build: "rollup -c --config-core --config-bundle --config-ie",
  postbuild: "node schema-copy",
  pretest: "yarn build --config-test",
  test: "TZ=America/Los_Angeles tape 'test/**/*-test.js'",
  prepublishOnly: "yarn test && yarn build",
  postpublish: "./schema-deploy.sh"
};
var dependencies = {
  "vega-crossfilter": "~4.0.5",
  "vega-dataflow": "~5.7.4",
  "vega-encode": "~4.8.3",
  "vega-event-selector": "~2.0.6",
  "vega-expression": "~4.0.1",
  "vega-force": "~4.0.7",
  "vega-format": "~1.0.4",
  "vega-functions": "~5.12.0",
  "vega-geo": "~4.3.8",
  "vega-hierarchy": "~4.0.9",
  "vega-label": "~1.0.0",
  "vega-loader": "~4.4.0",
  "vega-parser": "~6.1.3",
  "vega-projection": "~1.4.5",
  "vega-regression": "~1.0.9",
  "vega-runtime": "~6.1.3",
  "vega-scale": "~7.1.1",
  "vega-scenegraph": "~4.9.4",
  "vega-statistics": "~1.7.9",
  "vega-time": "~2.0.4",
  "vega-transforms": "~4.9.4",
  "vega-typings": "~0.21.0",
  "vega-util": "~1.16.1",
  "vega-view": "~5.10.1",
  "vega-view-transforms": "~4.5.8",
  "vega-voronoi": "~4.1.5",
  "vega-wordcloud": "~4.1.3"
};
var devDependencies = {
  "vega-schema": "*"
};
var gitHead = "e251dbc61ab6645689d9f349e7dd9d15ddb85bce";
var pkg = {
  name,
  version: version$1,
  description,
  keywords: keywords2,
  license,
  author,
  main,
  module,
  unpkg,
  jsdelivr,
  types,
  repository,
  scripts,
  dependencies,
  devDependencies,
  gitHead
};
extend(transforms, vega_transforms_module_exports, vega_view_transforms_module_exports, vega_encode_module_exports, vega_geo_module_exports, vega_force_module_exports, vega_label_module_exports, vega_hierarchy_module_exports, vega_regression_module_exports, vega_voronoi_module_exports, vega_wordcloud_module_exports, vega_crossfilter_module_exports);
var version = pkg.version;
export {
  Bounds,
  CanvasHandler,
  CanvasRenderer,
  DATE,
  DAY,
  DAYOFYEAR,
  Dataflow,
  Debug,
  Error$1 as Error,
  EventStream,
  Gradient,
  GroupItem,
  HOURS,
  Handler,
  Info,
  Item,
  MILLISECONDS,
  MINUTES,
  MONTH,
  Marks,
  MultiPulse,
  None,
  Operator,
  Parameters,
  Pulse,
  QUARTER,
  RenderType,
  Renderer,
  ResourceLoader,
  SECONDS,
  SVGHandler,
  SVGRenderer,
  SVGStringRenderer,
  Scenegraph,
  TIME_UNITS,
  Transform,
  View,
  WEEK,
  Warn,
  YEAR,
  accessor,
  accessorFields,
  accessorName,
  array,
  ascending,
  estimateBandwidth as bandwidthNRD,
  bin2 as bin,
  bootstrapCI,
  boundClip,
  boundContext,
  boundItem,
  boundMark,
  boundStroke,
  changeset,
  clampRange,
  codegen as codegenExpression,
  compare,
  constant,
  cumulativeLogNormal,
  cumulativeNormal,
  cumulativeUniform,
  dayofyear,
  debounce,
  defaultLocale3 as defaultLocale,
  definition,
  densityLogNormal,
  densityNormal,
  densityUniform,
  domChild,
  domClear,
  domCreate,
  domFind,
  dotbin,
  error,
  expressionFunction,
  extend,
  extent,
  extentIndex,
  falsy,
  fastmap,
  field,
  flush,
  font,
  fontFamily,
  fontSize,
  format,
  numberFormatDefaultLocale as formatLocale,
  formats,
  has as hasOwnProperty,
  id,
  identity,
  inferType,
  inferTypes,
  ingest$1 as ingest,
  inherits,
  inrange,
  interpolate,
  interpolateColors,
  interpolateRange,
  intersect2 as intersect,
  intersectBoxLine,
  intersectPath,
  intersectPoint,
  intersectRule,
  isArray,
  isBoolean,
  isDate,
  isFunction,
  isIterable,
  isNumber,
  isObject,
  isRegExp,
  isString,
  isTuple,
  key,
  lerp,
  lineHeight,
  loader,
  locale3 as locale,
  logger,
  lruCache,
  markup,
  merge,
  mergeConfig,
  multiLineOffset,
  one,
  pad,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  parse$1 as parse,
  parser as parseExpression,
  eventSelector as parseSelector,
  curves as pathCurves,
  pathEqual,
  pathParse,
  vg_rect as pathRectangle,
  pathRender,
  symbols3 as pathSymbols,
  vg_trail as pathTrail,
  peek,
  point6 as point,
  projection2 as projection,
  quantileLogNormal,
  quantileNormal,
  quantileUniform,
  quantiles,
  quantizeInterpolator,
  quarter,
  quartiles,
  random,
  integer as randomInteger,
  kde as randomKDE,
  lcg as randomLCG,
  lognormal as randomLogNormal,
  mixture as randomMixture,
  gaussian as randomNormal,
  uniform as randomUniform,
  read_default as read,
  exp2 as regressionExp,
  linear as regressionLinear,
  loess as regressionLoess,
  log2 as regressionLog,
  poly as regressionPoly,
  pow2 as regressionPow,
  quad as regressionQuad,
  renderModule,
  repeat,
  resetDefaultLocale,
  resetSVGClipId,
  resetSVGDefIds,
  responseType,
  context2 as runtimeContext,
  sampleCurve,
  sampleLogNormal,
  sampleNormal,
  sampleUniform,
  scale,
  sceneEqual,
  sceneFromJSON,
  pickVisit as scenePickVisit,
  sceneToJSON,
  visit as sceneVisit,
  zorder as sceneZOrder,
  scheme,
  serializeXML,
  setRandom,
  span,
  splitAccessPath,
  $ as stringValue,
  textMetrics,
  bin as timeBin,
  timeFloor,
  timeFormatDefaultLocale as timeFormatLocale,
  timeInterval,
  timeOffset,
  timeSequence,
  timeUnitSpecifier,
  timeUnits,
  toBoolean,
  toDate,
  toNumber,
  toSet,
  toString,
  transform,
  transforms,
  truncate,
  truthy,
  tupleid,
  typeParsers,
  utcFloor,
  utcInterval,
  utcOffset,
  utcSequence,
  utcdayofyear,
  utcquarter,
  utcweek,
  version,
  visitArray,
  week,
  writeConfig,
  zero,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog
};
